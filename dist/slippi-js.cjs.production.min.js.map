{"version":3,"file":"slippi-js.cjs.production.min.js","sources":["../src/melee/types.ts","../src/melee/characters.ts","../src/melee/moves.ts","../src/melee/stages.ts","../src/stats/common.ts","../src/stats/actions.ts","../src/stats/combos.ts","../src/types.ts","../src/stats/inputs.ts","../src/stats/conversions.ts","../src/stats/overall.ts","../src/stats/stats.ts","../src/stats/stocks.ts","../src/console/communication.ts","../src/console/types.ts","../src/console/consoleConnection.ts","../src/console/dolphinConnection.ts","../src/utils/slpReader.ts","../src/utils/slpStream.ts","../src/utils/fullwidth.ts","../src/utils/slpFile.ts","../src/utils/slpFileWriter.ts","../src/utils/slpParser.ts","../src/utils/rollbackCounter.ts","../src/SlippiGame.ts","../src/melee/animations.ts"],"sourcesContent":["export enum Character {\n  CAPTAIN_FALCON = 0,\n  DONKEY_KONG = 1,\n  FOX = 2,\n  GAME_AND_WATCH = 3,\n  KIRBY = 4,\n  BOWSER = 5,\n  LINK = 6,\n  LUIGI = 7,\n  MARIO = 8,\n  MARTH = 9,\n  MEWTWO = 10,\n  NESS = 11,\n  PEACH = 12,\n  PIKACHU = 13,\n  ICE_CLIMBERS = 14,\n  JIGGLYPUFF = 15,\n  SAMUS = 16,\n  YOSHI = 17,\n  ZELDA = 18,\n  SHEIK = 19,\n  FALCO = 20,\n  YOUNG_LINK = 21,\n  DR_MARIO = 22,\n  ROY = 23,\n  PICHU = 24,\n  GANONDORF = 25,\n  MASTER_HAND = 26,\n  WIREFRAME_MALE = 27,\n  WIREFRAME_FEMALE = 28,\n  GIGA_BOWSER = 29,\n  CRAZY_HAND = 30,\n  SANDBAG = 31,\n  POPO = 32,\n}\n\nexport enum Stage {\n  FOUNTAIN_OF_DREAMS = 2,\n  POKEMON_STADIUM = 3,\n  PEACHS_CASTLE = 4,\n  KONGO_JUNGLE = 5,\n  BRINSTAR = 6,\n  CORNERIA = 7,\n  YOSHIS_STORY = 8,\n  ONETT = 9,\n  MUTE_CITY = 10,\n  RAINBOW_CRUISE = 11,\n  JUNGLE_JAPES = 12,\n  GREAT_BAY = 13,\n  HYRULE_TEMPLE = 14,\n  BRINSTAR_DEPTHS = 15,\n  YOSHIS_ISLAND = 16,\n  GREEN_GREENS = 17,\n  FOURSIDE = 18,\n  MUSHROOM_KINGDOM = 19,\n  MUSHROOM_KINGDOM_2 = 20,\n  VENOM = 22,\n  POKE_FLOATS = 23,\n  BIG_BLUE = 24,\n  ICICLE_MOUNTAIN = 25,\n  ICETOP = 26,\n  FLAT_ZONE = 27,\n  DREAMLAND = 28,\n  YOSHIS_ISLAND_N64 = 29,\n  KONGO_JUNGLE_N64 = 30,\n  BATTLEFIELD = 31,\n  FINAL_DESTINATION = 32,\n  TARGET_TEST_MARIO = 33,\n  TARGET_TEST_CAPTAIN_FALCON = 34,\n  TARGET_TEST_YOUNG_LINK = 35,\n  TARGET_TEST_DONKEY_KONG = 36,\n  TARGET_TEST_DR_MARIO = 37,\n  TARGET_TEST_FALCO = 38,\n  TARGET_TEST_FOX = 39,\n  TARGET_TEST_ICE_CLIMBERS = 40,\n  TARGET_TEST_KIRBY = 41,\n  TARGET_TEST_BOWSER = 42,\n  TARGET_TEST_LINK = 43,\n  TARGET_TEST_LUIGI = 44,\n  TARGET_TEST_MARTH = 45,\n  TARGET_TEST_MEWTWO = 46,\n  TARGET_TEST_NESS = 47,\n  TARGET_TEST_PEACH = 48,\n  TARGET_TEST_PICHU = 49,\n  TARGET_TEST_PIKACHU = 50,\n  TARGET_TEST_JIGGLYPUFF = 51,\n  TARGET_TEST_SAMUS = 52,\n  TARGET_TEST_SHEIK = 53,\n  TARGET_TEST_YOSHI = 54,\n  TARGET_TEST_ZELDA = 55,\n  TARGET_TEST_GAME_AND_WATCH = 56,\n  TARGET_TEST_ROY = 57,\n  TARGET_TEST_GANONDORF = 58,\n  HOME_RUN_CONTEST = 84,\n}\n","import { Character } from \"./types\";\n\nexport type CharacterColor = string;\nconst DEFAULT_COLOR: CharacterColor = \"Default\";\n\nexport interface CharacterInfo {\n  id: number;\n  name: string;\n  shortName: string;\n  colors: CharacterColor[];\n}\n\nexport const UnknownCharacter: CharacterInfo = {\n  id: -1,\n  name: \"Unknown Character\",\n  shortName: \"Unknown\",\n  colors: [DEFAULT_COLOR],\n};\n\nconst externalCharacters: CharacterInfo[] = [\n  {\n    id: Character.CAPTAIN_FALCON,\n    name: \"Captain Falcon\",\n    shortName: \"Falcon\",\n    colors: [DEFAULT_COLOR, \"Black\", \"Red\", \"White\", \"Green\", \"Blue\"],\n  },\n  {\n    id: Character.DONKEY_KONG,\n    name: \"Donkey Kong\",\n    shortName: \"DK\",\n    colors: [DEFAULT_COLOR, \"Black\", \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.FOX,\n    name: \"Fox\",\n    shortName: \"Fox\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.GAME_AND_WATCH,\n    name: \"Mr. Game & Watch\",\n    shortName: \"G&W\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.KIRBY,\n    name: \"Kirby\",\n    shortName: \"Kirby\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Blue\", \"Red\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.BOWSER,\n    name: \"Bowser\",\n    shortName: \"Bowser\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Black\"],\n  },\n  {\n    id: Character.LINK,\n    name: \"Link\",\n    shortName: \"Link\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Black\", \"White\"],\n  },\n  {\n    id: Character.LUIGI,\n    name: \"Luigi\",\n    shortName: \"Luigi\",\n    colors: [DEFAULT_COLOR, \"White\", \"Blue\", \"Red\"],\n  },\n  {\n    id: Character.MARIO,\n    name: \"Mario\",\n    shortName: \"Mario\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Black\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.MARTH,\n    name: \"Marth\",\n    shortName: \"Marth\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Green\", \"Black\", \"White\"],\n  },\n  {\n    id: Character.MEWTWO,\n    name: \"Mewtwo\",\n    shortName: \"Mewtwo\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.NESS,\n    name: \"Ness\",\n    shortName: \"Ness\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.PEACH,\n    name: \"Peach\",\n    shortName: \"Peach\",\n    colors: [DEFAULT_COLOR, \"Daisy\", \"White\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.PIKACHU,\n    name: \"Pikachu\",\n    shortName: \"Pikachu\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Party Hat\", \"Cowboy Hat\"],\n  },\n  {\n    id: Character.ICE_CLIMBERS,\n    name: \"Ice Climbers\",\n    shortName: \"ICs\",\n    colors: [DEFAULT_COLOR, \"Green\", \"Orange\", \"Red\"],\n  },\n  {\n    id: Character.JIGGLYPUFF,\n    name: \"Jigglypuff\",\n    shortName: \"Puff\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Headband\", \"Crown\"],\n  },\n  {\n    id: Character.SAMUS,\n    name: \"Samus\",\n    shortName: \"Samus\",\n    colors: [DEFAULT_COLOR, \"Pink\", \"Black\", \"Green\", \"Purple\"],\n  },\n  {\n    id: Character.YOSHI,\n    name: \"Yoshi\",\n    shortName: \"Yoshi\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Yellow\", \"Pink\", \"Cyan\"],\n  },\n  {\n    id: Character.ZELDA,\n    name: \"Zelda\",\n    shortName: \"Zelda\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.SHEIK,\n    name: \"Sheik\",\n    shortName: \"Sheik\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.FALCO,\n    name: \"Falco\",\n    shortName: \"Falco\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.YOUNG_LINK,\n    name: \"Young Link\",\n    shortName: \"YLink\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"White\", \"Black\"],\n  },\n  {\n    id: Character.DR_MARIO,\n    name: \"Dr. Mario\",\n    shortName: \"Doc\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Black\"],\n  },\n  {\n    id: Character.ROY,\n    name: \"Roy\",\n    shortName: \"Roy\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Yellow\"],\n  },\n  {\n    id: Character.PICHU,\n    name: \"Pichu\",\n    shortName: \"Pichu\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.GANONDORF,\n    name: \"Ganondorf\",\n    shortName: \"Ganon\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Purple\"],\n  },\n];\n\nexport function getAllCharacters(): CharacterInfo[] {\n  return externalCharacters;\n}\n\nexport function getCharacterInfo(externalCharacterId: number): CharacterInfo {\n  const charInfo = externalCharacters[externalCharacterId];\n  if (charInfo) {\n    return charInfo;\n  }\n  return UnknownCharacter;\n}\n\nexport function getCharacterShortName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.shortName;\n}\n\nexport function getCharacterName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.name;\n}\n\n// Return a human-readable color from a characterCode.\nexport function getCharacterColorName(externalCharacterId: number, characterColor: number): CharacterColor {\n  const character = getCharacterInfo(externalCharacterId);\n  const color = character.colors[characterColor];\n  if (color) {\n    return color;\n  }\n  return DEFAULT_COLOR;\n}\n","export interface Move {\n  id: number;\n  name: string;\n  shortName: string;\n}\n\nexport const UnknownMove: Move = {\n  id: -1,\n  name: \"Unknown Move\",\n  shortName: \"unknown\",\n};\n\nconst moves: { [id: number]: Move } = {\n  1: {\n    // This includes all thrown items, zair, luigi's taunt, samus bombs, etc\n    id: 1,\n    name: \"Miscellaneous\",\n    shortName: \"misc\",\n  },\n  2: {\n    id: 2,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  3: {\n    id: 3,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  4: {\n    id: 4,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  5: {\n    id: 5,\n    name: \"Rapid Jabs\",\n    shortName: \"rapid-jabs\",\n  },\n  6: {\n    id: 6,\n    name: \"Dash Attack\",\n    shortName: \"dash\",\n  },\n  7: {\n    id: 7,\n    name: \"Forward Tilt\",\n    shortName: \"ftilt\",\n  },\n  8: {\n    id: 8,\n    name: \"Up Tilt\",\n    shortName: \"utilt\",\n  },\n  9: {\n    id: 9,\n    name: \"Down Tilt\",\n    shortName: \"dtilt\",\n  },\n  10: {\n    id: 10,\n    name: \"Forward Smash\",\n    shortName: \"fsmash\",\n  },\n  11: {\n    id: 11,\n    name: \"Up Smash\",\n    shortName: \"usmash\",\n  },\n  12: {\n    id: 12,\n    name: \"Down Smash\",\n    shortName: \"dsmash\",\n  },\n  13: {\n    id: 13,\n    name: \"Neutral Air\",\n    shortName: \"nair\",\n  },\n  14: {\n    id: 14,\n    name: \"Forward Air\",\n    shortName: \"fair\",\n  },\n  15: {\n    id: 15,\n    name: \"Back Air\",\n    shortName: \"bair\",\n  },\n  16: {\n    id: 16,\n    name: \"Up Air\",\n    shortName: \"uair\",\n  },\n  17: {\n    id: 17,\n    name: \"Down Air\",\n    shortName: \"dair\",\n  },\n  18: {\n    id: 18,\n    name: \"Neutral B\",\n    shortName: \"neutral-b\",\n  },\n  19: {\n    id: 19,\n    name: \"Side B\",\n    shortName: \"side-b\",\n  },\n  20: {\n    id: 20,\n    name: \"Up B\",\n    shortName: \"up-b\",\n  },\n  21: {\n    id: 21,\n    name: \"Down B\",\n    shortName: \"down-b\",\n  },\n  50: {\n    id: 50,\n    name: \"Getup Attack\",\n    shortName: \"getup\",\n  },\n  51: {\n    id: 51,\n    name: \"Getup Attack (Slow)\",\n    shortName: \"getup-slow\",\n  },\n  52: {\n    id: 52,\n    name: \"Grab Pummel\",\n    shortName: \"pummel\",\n  },\n  53: {\n    id: 53,\n    name: \"Forward Throw\",\n    shortName: \"fthrow\",\n  },\n  54: {\n    id: 54,\n    name: \"Back Throw\",\n    shortName: \"bthrow\",\n  },\n  55: {\n    id: 55,\n    name: \"Up Throw\",\n    shortName: \"uthrow\",\n  },\n  56: {\n    id: 56,\n    name: \"Down Throw\",\n    shortName: \"dthrow\",\n  },\n  61: {\n    id: 61,\n    name: \"Edge Attack (Slow)\",\n    shortName: \"edge-slow\",\n  },\n  62: {\n    id: 62,\n    name: \"Edge Attack\",\n    shortName: \"edge\",\n  },\n};\n\nexport function getMoveInfo(moveId: number): Move {\n  const m = moves[moveId];\n  if (!m) {\n    return UnknownMove;\n  }\n  return m;\n}\n\nexport function getMoveShortName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.shortName;\n}\n\nexport function getMoveName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.name;\n}\n","import { Stage } from \"./types\";\n\nexport interface StageInfo {\n  id: number;\n  name: string;\n}\n\nexport const UnknownStage: StageInfo = {\n  id: -1,\n  name: \"Unknown Stage\",\n};\n\nconst stages: { [id: number]: StageInfo } = {\n  [Stage.FOUNTAIN_OF_DREAMS]: {\n    id: Stage.FOUNTAIN_OF_DREAMS,\n    name: \"Fountain of Dreams\",\n  },\n  [Stage.POKEMON_STADIUM]: {\n    id: Stage.POKEMON_STADIUM,\n    name: \"Pokémon Stadium\",\n  },\n  [Stage.PEACHS_CASTLE]: {\n    id: Stage.PEACHS_CASTLE,\n    name: \"Princess Peach's Castle\",\n  },\n  [Stage.KONGO_JUNGLE]: {\n    id: Stage.KONGO_JUNGLE,\n    name: \"Kongo Jungle\",\n  },\n  [Stage.BRINSTAR]: {\n    id: Stage.BRINSTAR,\n    name: \"Brinstar\",\n  },\n  [Stage.CORNERIA]: {\n    id: Stage.CORNERIA,\n    name: \"Corneria\",\n  },\n  [Stage.YOSHIS_STORY]: {\n    id: Stage.YOSHIS_STORY,\n    name: \"Yoshi's Story\",\n  },\n  [Stage.ONETT]: {\n    id: Stage.ONETT,\n    name: \"Onett\",\n  },\n  [Stage.MUTE_CITY]: {\n    id: Stage.MUTE_CITY,\n    name: \"Mute City\",\n  },\n  [Stage.RAINBOW_CRUISE]: {\n    id: Stage.RAINBOW_CRUISE,\n    name: \"Rainbow Cruise\",\n  },\n  [Stage.JUNGLE_JAPES]: {\n    id: Stage.JUNGLE_JAPES,\n    name: \"Jungle Japes\",\n  },\n  [Stage.GREAT_BAY]: {\n    id: Stage.GREAT_BAY,\n    name: \"Great Bay\",\n  },\n  [Stage.HYRULE_TEMPLE]: {\n    id: Stage.HYRULE_TEMPLE,\n    name: \"Hyrule Temple\",\n  },\n  [Stage.BRINSTAR_DEPTHS]: {\n    id: Stage.BRINSTAR_DEPTHS,\n    name: \"Brinstar Depths\",\n  },\n  [Stage.YOSHIS_ISLAND]: {\n    id: Stage.YOSHIS_ISLAND,\n    name: \"Yoshi's Island\",\n  },\n  [Stage.GREEN_GREENS]: {\n    id: Stage.GREEN_GREENS,\n    name: \"Green Greens\",\n  },\n  [Stage.FOURSIDE]: {\n    id: Stage.FOURSIDE,\n    name: \"Fourside\",\n  },\n  [Stage.MUSHROOM_KINGDOM]: {\n    id: Stage.MUSHROOM_KINGDOM,\n    name: \"Mushroom Kingdom I\",\n  },\n  [Stage.MUSHROOM_KINGDOM_2]: {\n    id: Stage.MUSHROOM_KINGDOM_2,\n    name: \"Mushroom Kingdom II\",\n  },\n  [Stage.VENOM]: {\n    id: Stage.VENOM,\n    name: \"Venom\",\n  },\n  [Stage.POKE_FLOATS]: {\n    id: Stage.POKE_FLOATS,\n    name: \"Poké Floats\",\n  },\n  [Stage.BIG_BLUE]: {\n    id: Stage.BIG_BLUE,\n    name: \"Big Blue\",\n  },\n  [Stage.ICICLE_MOUNTAIN]: {\n    id: Stage.ICICLE_MOUNTAIN,\n    name: \"Icicle Mountain\",\n  },\n  [Stage.ICETOP]: {\n    id: Stage.ICETOP,\n    name: \"Icetop\",\n  },\n  [Stage.FLAT_ZONE]: {\n    id: Stage.FLAT_ZONE,\n    name: \"Flat Zone\",\n  },\n  [Stage.DREAMLAND]: {\n    id: Stage.DREAMLAND,\n    name: \"Dream Land N64\",\n  },\n  [Stage.YOSHIS_ISLAND_N64]: {\n    id: Stage.YOSHIS_ISLAND_N64,\n    name: \"Yoshi's Island N64\",\n  },\n  [Stage.KONGO_JUNGLE_N64]: {\n    id: Stage.KONGO_JUNGLE_N64,\n    name: \"Kongo Jungle N64\",\n  },\n  [Stage.BATTLEFIELD]: {\n    id: Stage.BATTLEFIELD,\n    name: \"Battlefield\",\n  },\n  [Stage.FINAL_DESTINATION]: {\n    id: Stage.FINAL_DESTINATION,\n    name: \"Final Destination\",\n  },\n  [Stage.TARGET_TEST_MARIO]: {\n    id: Stage.TARGET_TEST_MARIO,\n    name: \"Target Test (Mario)\",\n  },\n  [Stage.TARGET_TEST_CAPTAIN_FALCON]: {\n    id: Stage.TARGET_TEST_CAPTAIN_FALCON,\n    name: \"Target Test (Captain Falcon)\",\n  },\n  [Stage.TARGET_TEST_YOUNG_LINK]: {\n    id: Stage.TARGET_TEST_YOUNG_LINK,\n    name: \"Target Test (Young Link)\",\n  },\n  [Stage.TARGET_TEST_DONKEY_KONG]: {\n    id: Stage.TARGET_TEST_DONKEY_KONG,\n    name: \"Target Test (Donkey Kong)\",\n  },\n  [Stage.TARGET_TEST_DR_MARIO]: {\n    id: Stage.TARGET_TEST_DR_MARIO,\n    name: \"Target Test (Dr. Mario)\",\n  },\n  [Stage.TARGET_TEST_FALCO]: {\n    id: Stage.TARGET_TEST_FALCO,\n    name: \"Target Test (Falco)\",\n  },\n  [Stage.TARGET_TEST_FOX]: {\n    id: Stage.TARGET_TEST_FOX,\n    name: \"Target Test (Fox)\",\n  },\n  [Stage.TARGET_TEST_ICE_CLIMBERS]: {\n    id: Stage.TARGET_TEST_ICE_CLIMBERS,\n    name: \"Target Test (Ice Climbers)\",\n  },\n  [Stage.TARGET_TEST_KIRBY]: {\n    id: Stage.TARGET_TEST_KIRBY,\n    name: \"Target Test (Kirby)\",\n  },\n  [Stage.TARGET_TEST_BOWSER]: {\n    id: Stage.TARGET_TEST_BOWSER,\n    name: \"Target Test (Bowser)\",\n  },\n  [Stage.TARGET_TEST_LINK]: {\n    id: Stage.TARGET_TEST_LINK,\n    name: \"Target Test (Link)\",\n  },\n  [Stage.TARGET_TEST_LUIGI]: {\n    id: Stage.TARGET_TEST_LUIGI,\n    name: \"Target Test (Luigi)\",\n  },\n  [Stage.TARGET_TEST_MARTH]: {\n    id: Stage.TARGET_TEST_MARTH,\n    name: \"Target Test (Marth)\",\n  },\n  [Stage.TARGET_TEST_MEWTWO]: {\n    id: Stage.TARGET_TEST_MEWTWO,\n    name: \"Target Test (Mewtwo)\",\n  },\n  [Stage.TARGET_TEST_NESS]: {\n    id: Stage.TARGET_TEST_NESS,\n    name: \"Target Test (Ness)\",\n  },\n  [Stage.TARGET_TEST_PEACH]: {\n    id: Stage.TARGET_TEST_PEACH,\n    name: \"Target Test (Peach)\",\n  },\n  [Stage.TARGET_TEST_PICHU]: {\n    id: Stage.TARGET_TEST_PICHU,\n    name: \"Target Test (Pichu)\",\n  },\n  [Stage.TARGET_TEST_PIKACHU]: {\n    id: Stage.TARGET_TEST_PIKACHU,\n    name: \"Target Test (Pikachu)\",\n  },\n  [Stage.TARGET_TEST_JIGGLYPUFF]: {\n    id: Stage.TARGET_TEST_JIGGLYPUFF,\n    name: \"Target Test (Jigglypuff)\",\n  },\n  [Stage.TARGET_TEST_SAMUS]: {\n    id: Stage.TARGET_TEST_SAMUS,\n    name: \"Target Test (Samus)\",\n  },\n  [Stage.TARGET_TEST_SHEIK]: {\n    id: Stage.TARGET_TEST_SHEIK,\n    name: \"Target Test (Sheik)\",\n  },\n  [Stage.TARGET_TEST_YOSHI]: {\n    id: Stage.TARGET_TEST_YOSHI,\n    name: \"Target Test (Yoshi)\",\n  },\n  [Stage.TARGET_TEST_ZELDA]: {\n    id: Stage.TARGET_TEST_ZELDA,\n    name: \"Target Test (Zelda)\",\n  },\n  [Stage.TARGET_TEST_GAME_AND_WATCH]: {\n    id: Stage.TARGET_TEST_GAME_AND_WATCH,\n    name: \"Target Test (Mr. Game & Watch)\",\n  },\n  [Stage.TARGET_TEST_ROY]: {\n    id: Stage.TARGET_TEST_ROY,\n    name: \"Target Test (Roy)\",\n  },\n  [Stage.TARGET_TEST_GANONDORF]: {\n    id: Stage.TARGET_TEST_GANONDORF,\n    name: \"Target Test (Ganondorf)\",\n  },\n  [Stage.HOME_RUN_CONTEST]: {\n    id: Stage.HOME_RUN_CONTEST,\n    name: \"Home-Run Contest\",\n  },\n};\n\nexport function getStageInfo(stageId: number): StageInfo {\n  const s = stages[stageId];\n  if (!s) {\n    return UnknownStage;\n  }\n  return s;\n}\n\nexport function getStageName(stageId: number): string {\n  const stage = getStageInfo(stageId);\n  return stage.name;\n}\n","import type { GameStartType, PostFrameUpdateType } from \"../types\";\n\nexport interface StatsType {\n  gameComplete: boolean;\n  lastFrame: number;\n  playableFrameCount: number;\n  stocks: StockType[];\n  conversions: ConversionType[];\n  combos: ComboType[];\n  actionCounts: ActionCountsType[];\n  overall: OverallType[];\n}\n\nexport interface RatioType {\n  count: number;\n  total: number;\n  ratio: number | null;\n}\n\nexport interface PlayerIndexedType {\n  playerIndex: number;\n  opponentIndex: number;\n}\n\nexport interface DurationType {\n  startFrame: number;\n  endFrame?: number | null;\n}\n\nexport interface DamageType {\n  startPercent: number;\n  currentPercent: number;\n  endPercent?: number | null;\n}\n\nexport interface StockType extends DurationType, DamageType {\n  playerIndex: number;\n  count: number;\n  deathAnimation?: number | null;\n}\n\nexport interface MoveLandedType {\n  playerIndex: number;\n  frame: number;\n  moveId: number;\n  hitCount: number;\n  damage: number;\n}\n\nexport interface ComboType extends DurationType, DamageType {\n  playerIndex: number;\n  moves: MoveLandedType[];\n  didKill: boolean;\n  lastHitBy: number | null;\n}\n\nexport interface ConversionType extends ComboType {\n  openingType: string;\n}\n\nexport interface ActionCountsType {\n  playerIndex: number;\n  wavedashCount: number;\n  wavelandCount: number;\n  airDodgeCount: number;\n  dashDanceCount: number;\n  spotDodgeCount: number;\n  ledgegrabCount: number;\n  rollCount: number;\n  lCancelCount: {\n    success: number;\n    fail: number;\n  };\n  grabCount: {\n    success: number;\n    fail: number;\n  };\n  throwCount: {\n    up: number;\n    forward: number;\n    back: number;\n    down: number;\n  };\n  groundTechCount: {\n    // tech away/in are in reference to the opponents position and not the stage\n    away: number;\n    in: number;\n    neutral: number;\n    fail: number;\n  };\n  wallTechCount: {\n    success: number;\n    fail: number;\n  };\n}\n\nexport interface InputCountsType {\n  buttons: number;\n  triggers: number;\n  joystick: number;\n  cstick: number;\n  total: number;\n}\n\nexport interface OverallType {\n  playerIndex: number;\n  inputCounts: InputCountsType;\n  conversionCount: number;\n  totalDamage: number;\n  killCount: number;\n  successfulConversions: RatioType;\n  inputsPerMinute: RatioType;\n  digitalInputsPerMinute: RatioType;\n  openingsPerKill: RatioType;\n  damagePerOpening: RatioType;\n  neutralWinRatio: RatioType;\n  counterHitRatio: RatioType;\n  beneficialTradeRatio: RatioType;\n}\n\nexport enum State {\n  // Animation ID ranges\n  DAMAGE_START = 0x4b,\n  DAMAGE_END = 0x5b,\n  CAPTURE_START = 0xdf,\n  CAPTURE_END = 0xe8,\n  GUARD_START = 0xb2,\n  GUARD_END = 0xb6,\n  GROUNDED_CONTROL_START = 0xe,\n  GROUNDED_CONTROL_END = 0x18,\n  SQUAT_START = 0x27,\n  SQUAT_END = 0x29,\n  DOWN_START = 0xb7,\n  DOWN_END = 0xc6,\n  TECH_START = 0xc7,\n  TECH_END = 0xcc,\n  DYING_START = 0x0,\n  DYING_END = 0xa,\n  CONTROLLED_JUMP_START = 0x18,\n  CONTROLLED_JUMP_END = 0x22,\n  GROUND_ATTACK_START = 0x2c,\n  GROUND_ATTACK_END = 0x40,\n  AERIAL_ATTACK_START = 0x41,\n  AERIAL_ATTACK_END = 0x4a,\n\n  // Animation ID specific\n  ROLL_FORWARD = 0xe9,\n  ROLL_BACKWARD = 0xea,\n  SPOT_DODGE = 0xeb,\n  AIR_DODGE = 0xec,\n  ACTION_WAIT = 0xe,\n  ACTION_DASH = 0x14,\n  ACTION_KNEE_BEND = 0x18,\n  GUARD_ON = 0xb2,\n  TECH_MISS_UP = 0xb7,\n  TECH_MISS_DOWN = 0xbf,\n  NEUTRAL_TECH = 0xc7,\n  FORWARD_TECH = 0xc8,\n  BACKWARD_TECH = 0xc9,\n  WALL_TECH = 0xca,\n  MISSED_WALL_TECH = 0xf7,\n  DASH = 0x14,\n  TURN = 0x12,\n  LANDING_FALL_SPECIAL = 0x2b,\n  JUMP_FORWARD = 0x19,\n  JUMP_BACKWARD = 0x1a,\n  FALL_FORWARD = 0x1e,\n  FALL_BACKWARD = 0x1f,\n  GRAB = 0xd4,\n  GRAB_WAIT = 0xd8,\n  PUMMEL = 0xd9,\n  CLIFF_CATCH = 0xfc,\n  THROW_UP = 0xdd,\n  THROW_FORWARD = 0xdb,\n  THROW_DOWN = 0xde,\n  THROW_BACK = 0xdc,\n  DAMAGE_FALL = 0x26,\n\n  // Command Grabs\n  BARREL_WAIT = 0x125,\n  COMMAND_GRAB_RANGE1_START = 0x10a,\n  COMMAND_GRAB_RANGE1_END = 0x130,\n\n  COMMAND_GRAB_RANGE2_START = 0x147,\n  COMMAND_GRAB_RANGE2_END = 0x152,\n}\n\nexport const Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45,\n};\n\nexport function getSinglesPlayerPermutationsFromSettings(settings: GameStartType): PlayerIndexedType[] {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n\n  return [\n    {\n      playerIndex: settings.players[0]!.playerIndex,\n      opponentIndex: settings.players[1]!.playerIndex,\n    },\n    {\n      playerIndex: settings.players[1]!.playerIndex,\n      opponentIndex: settings.players[0]!.playerIndex,\n    },\n  ];\n}\n\nexport function didLoseStock(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): boolean {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n\n  return prevFrame.stocksRemaining! - frame.stocksRemaining! > 0;\n}\n\nexport function isInControl(state: number): boolean {\n  const ground = state >= State.GROUNDED_CONTROL_START && state <= State.GROUNDED_CONTROL_END;\n  const squat = state >= State.SQUAT_START && state <= State.SQUAT_END;\n  const groundAttack = state > State.GROUND_ATTACK_START && state <= State.GROUND_ATTACK_END;\n  const isGrab = state === State.GRAB;\n  // TODO: Add grounded b moves?\n  return ground || squat || groundAttack || isGrab;\n}\n\nexport function isTeching(state: number): boolean {\n  return state >= State.TECH_START && state <= State.TECH_END;\n}\n\nexport function isDown(state: number): boolean {\n  return state >= State.DOWN_START && state <= State.DOWN_END;\n}\n\nexport function isDamaged(state: number): boolean {\n  return (state >= State.DAMAGE_START && state <= State.DAMAGE_END) || state === State.DAMAGE_FALL;\n}\n\nexport function isGrabbed(state: number): boolean {\n  return state >= State.CAPTURE_START && state <= State.CAPTURE_END;\n}\n\n// TODO: Find better implementation of 3 seperate ranges\nexport function isCommandGrabbed(state: number): boolean {\n  return (\n    ((state >= State.COMMAND_GRAB_RANGE1_START && state <= State.COMMAND_GRAB_RANGE1_END) ||\n      (state >= State.COMMAND_GRAB_RANGE2_START && state <= State.COMMAND_GRAB_RANGE2_END)) &&\n    state !== State.BARREL_WAIT\n  );\n}\n\nexport function isDead(state: number): boolean {\n  return state >= State.DYING_START && state <= State.DYING_END;\n}\n\nexport function calcDamageTaken(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): number {\n  const percent = frame.percent ?? 0;\n  const prevPercent = prevFrame.percent ?? 0;\n\n  return percent - prevPercent;\n}\n","import { get, isEqual, keyBy, last, set, size } from \"lodash\";\n\nimport type { FrameEntryType, GameStartType } from \"../types\";\nimport type { ActionCountsType, PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings, State } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\n// Frame pattern that indicates a dash dance turn was executed\nconst dashDanceAnimations = [State.DASH, State.TURN, State.DASH];\n\ninterface PlayerActionState {\n  playerCounts: ActionCountsType;\n  animations: number[];\n}\n\nexport class ActionsComputer implements StatComputer<ActionCountsType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, PlayerActionState>();\n\n  public setup(settings: GameStartType): void {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach((indices) => {\n      const playerCounts: ActionCountsType = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0,\n        },\n        grabCount: {\n          success: 0,\n          fail: 0,\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0,\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0,\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0,\n        },\n      };\n      const playerState: PlayerActionState = {\n        playerCounts: playerCounts,\n        animations: [],\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): ActionCountsType[] {\n    return Array.from(this.state.values()).map((val) => val.playerCounts);\n  }\n}\n\nfunction didMissGroundTech(animation: State): boolean {\n  return animation === State.TECH_MISS_DOWN || animation === State.TECH_MISS_UP;\n}\n\nfunction isRolling(animation: State): boolean {\n  return animation === State.ROLL_BACKWARD || animation === State.ROLL_FORWARD;\n}\n\nfunction didStartRoll(currentAnimation: number, previousAnimation: number): boolean {\n  const isCurrentlyRolling = isRolling(currentAnimation);\n  const wasPreviouslyRolling = isRolling(previousAnimation);\n\n  return isCurrentlyRolling && !wasPreviouslyRolling;\n}\n\nfunction isSpotDodging(animation: State): boolean {\n  return animation === State.SPOT_DODGE;\n}\n\nfunction didStartGrabSuccess(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && currentAnimation <= State.GRAB_WAIT && currentAnimation > State.GRAB;\n}\nfunction didStartGrabFail(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && (currentAnimation > State.GRAB_WAIT || currentAnimation < State.GRAB);\n}\n\nfunction didStartSpotDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isSpotDodging(currentAnimation);\n  const wasPreviouslyDodging = isSpotDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isAirDodging(animation: State): boolean {\n  return animation === State.AIR_DODGE;\n}\n\nfunction didStartAirDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isAirDodging(currentAnimation);\n  const wasPreviouslyDodging = isAirDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isGrabbingLedge(animation: State): boolean {\n  return animation === State.CLIFF_CATCH;\n}\n\nfunction isAerialAttack(animation: State): boolean {\n  return animation >= State.AERIAL_ATTACK_START && animation <= State.AERIAL_ATTACK_END;\n}\n\nfunction didStartLedgegrab(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyGrabbingLedge = isGrabbingLedge(currentAnimation);\n  const wasPreviouslyGrabbingLedge = isGrabbingLedge(previousAnimation);\n\n  return isCurrentlyGrabbingLedge && !wasPreviouslyGrabbingLedge;\n}\n\nfunction handleActionCompute(state: PlayerActionState, indices: PlayerIndexedType, frame: FrameEntryType): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n  const incrementCount = (field: string, condition: boolean): void => {\n    if (!condition) {\n      return;\n    }\n\n    const current: number = get(state.playerCounts, field, 0);\n    set(state.playerCounts, field, current + 1);\n  };\n\n  // Manage animation state\n  const currentAnimation = playerFrame.actionStateId!;\n  state.animations.push(currentAnimation);\n\n  // Grab last 3 frames\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2] as number;\n  const newAnimation = currentAnimation !== prevAnimation;\n\n  // Increment counts based on conditions\n  const didDashDance = isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n\n  const didRoll = didStartRoll(currentAnimation, prevAnimation);\n  incrementCount(\"rollCount\", didRoll);\n\n  const didSpotDodge = didStartSpotDodge(currentAnimation, prevAnimation);\n  incrementCount(\"spotDodgeCount\", didSpotDodge);\n\n  const didAirDodge = didStartAirDodge(currentAnimation, prevAnimation);\n  incrementCount(\"airDodgeCount\", didAirDodge);\n\n  const didGrabLedge = didStartLedgegrab(currentAnimation, prevAnimation);\n  incrementCount(\"ledgegrabCount\", didGrabLedge);\n\n  const didGrabSucceed = didStartGrabSuccess(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.success\", didGrabSucceed);\n  const didGrabFail = didStartGrabFail(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.fail\", didGrabFail);\n\n  incrementCount(\"throwCount.up\", currentAnimation === State.THROW_UP && newAnimation);\n  incrementCount(\"throwCount.forward\", currentAnimation === State.THROW_FORWARD && newAnimation);\n  incrementCount(\"throwCount.down\", currentAnimation === State.THROW_DOWN && newAnimation);\n  incrementCount(\"throwCount.back\", currentAnimation === State.THROW_BACK && newAnimation);\n\n  if (newAnimation) {\n    const didMissTech = didMissGroundTech(currentAnimation);\n    incrementCount(\"groundTechCount.fail\", didMissTech);\n    let opponentDir = 1;\n    let facingOpponent = false;\n\n    if (playerFrame.positionX! > opponentFrame.positionX!) {\n      opponentDir = -1;\n    }\n    if (playerFrame.facingDirection == opponentDir) {\n      facingOpponent = true;\n    }\n\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.FORWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.BACKWARD_TECH && !facingOpponent);\n    incrementCount(\"groundTechCount.neutral\", currentAnimation === State.NEUTRAL_TECH);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.BACKWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.FORWARD_TECH && !facingOpponent);\n\n    incrementCount(\"wallTechCount.success\", currentAnimation === State.WALL_TECH);\n    incrementCount(\"wallTechCount.fail\", currentAnimation === State.MISSED_WALL_TECH);\n  }\n\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  }\n\n  // Handles wavedash detection (and waveland)\n  handleActionWavedash(state.playerCounts, state.animations);\n}\n\nfunction handleActionWavedash(counts: ActionCountsType, animations: State[]): void {\n  const currentAnimation = last(animations);\n  const prevAnimation = animations[animations.length - 2] as number;\n\n  const isSpecialLanding = currentAnimation === State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n\n  if (!isPossibleWavedash) {\n    return;\n  }\n\n  // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = keyBy(recentFrames, (animation) => animation);\n\n  if (size(recentAnimations) === 2 && recentAnimations[State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n\n  if (recentAnimations[State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n\n  if (recentAnimations[State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\n\nfunction isWavedashInitiationAnimation(animation: State): boolean {\n  if (animation === State.AIR_DODGE) {\n    return true;\n  }\n\n  const isAboveMin = animation >= State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\n","import { EventEmitter } from \"events\";\nimport { last } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ninterface ComboState {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n}\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private combos = new Array<ComboType>();\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos);\n\n        // Emit an event for the new combo\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: last(this.combos),\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType[] {\n    return this.combos;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  combos: ComboType[],\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      combos.push(state.combo);\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n","export enum Command {\n  MESSAGE_SIZES = 0x35,\n  GAME_START = 0x36,\n  PRE_FRAME_UPDATE = 0x37,\n  POST_FRAME_UPDATE = 0x38,\n  GAME_END = 0x39,\n  ITEM_UPDATE = 0x3b,\n  FRAME_BOOKEND = 0x3c,\n}\n\nexport interface PlayerType {\n  playerIndex: number;\n  port: number;\n  characterId: number | null;\n  characterColor: number | null;\n  startStocks: number | null;\n  type: number | null;\n  teamId: number | null;\n  controllerFix: string | null;\n  nametag: string | null;\n  displayName: string;\n  connectCode: string;\n}\n\nexport enum GameMode {\n  VS = 0x02,\n  ONLINE = 0x08,\n}\n\nexport interface GameStartType {\n  slpVersion: string | null;\n  isTeams: boolean | null;\n  isPAL: boolean | null;\n  stageId: number | null;\n  players: PlayerType[];\n  scene: number | null;\n  gameMode: GameMode | null;\n}\n\nexport interface PreFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  seed: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  joystickX: number | null;\n  joystickY: number | null;\n  cStickX: number | null;\n  cStickY: number | null;\n  trigger: number | null;\n  buttons: number | null;\n  physicalButtons: number | null;\n  physicalLTrigger: number | null;\n  physicalRTrigger: number | null;\n  percent: number | null;\n}\n\nexport interface PostFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  internalCharacterId: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  percent: number | null;\n  shieldSize: number | null;\n  lastAttackLanded: number | null;\n  currentComboCount: number | null;\n  lastHitBy: number | null;\n  stocksRemaining: number | null;\n  actionStateCounter: number | null;\n  miscActionState: number | null;\n  isAirborne: boolean | null;\n  lastGroundId: number | null;\n  jumpsRemaining: number | null;\n  lCancelStatus: number | null;\n  hurtboxCollisionState: number | null;\n  selfInducedSpeeds: SelfInducedSpeedsType | null;\n}\n\nexport interface SelfInducedSpeedsType {\n  airX: number | null;\n  y: number | null;\n  attackX: number | null;\n  attackY: number | null;\n  groundX: number | null;\n}\n\nexport interface ItemUpdateType {\n  frame: number | null;\n  typeId: number | null;\n  state: number | null;\n  facingDirection: number | null;\n  velocityX: number | null;\n  velocityY: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  damageTaken: number | null;\n  expirationTimer: number | null;\n  spawnId: number | null;\n  missileType: number | null;\n  turnipFace: number | null;\n  chargeShotLaunched: number | null;\n  chargePower: number | null;\n  owner: number | null;\n}\n\nexport interface FrameBookendType {\n  frame: number | null;\n  latestFinalizedFrame: number | null;\n}\n\nexport interface GameEndType {\n  gameEndMethod: number | null;\n  lrasInitiatorIndex: number | null;\n}\n\nexport interface MetadataType {\n  startAt?: string | null;\n  playedOn?: string | null;\n  lastFrame?: number | null;\n  players?: {\n    [playerIndex: number]: {\n      characters: {\n        [internalCharacterId: number]: number;\n      };\n      names?: {\n        netplay?: string | null;\n        code?: string | null;\n      };\n    };\n  } | null;\n  consoleNick?: string | null;\n}\n\nexport type EventPayloadTypes =\n  | GameStartType\n  | PreFrameUpdateType\n  | PostFrameUpdateType\n  | ItemUpdateType\n  | FrameBookendType\n  | GameEndType;\n\nexport type EventCallbackFunc = (command: Command, payload?: EventPayloadTypes | null) => boolean;\n\nexport interface FrameEntryType {\n  frame: number;\n  players: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  followers: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  items?: ItemUpdateType[];\n}\n\nexport enum Frames {\n  FIRST = -123,\n  FIRST_PLAYABLE = -39,\n}\n\nexport interface FramesType {\n  [frameIndex: number]: FrameEntryType;\n}\n\nexport interface RollbackFramesType {\n  [frameIndex: number]: FrameEntryType[];\n}\n\nexport interface RollbackFrames {\n  frames: RollbackFramesType;\n  count: number;\n  lengths: number[];\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\nimport type { PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nenum JoystickRegion {\n  DZ = 0,\n  NE = 1,\n  SE = 2,\n  SW = 3,\n  NW = 4,\n  N = 5,\n  E = 6,\n  S = 7,\n  W = 8,\n}\n\nexport interface PlayerInput {\n  playerIndex: number;\n  opponentIndex: number;\n  inputCount: number;\n  joystickInputCount: number;\n  cstickInputCount: number;\n  buttonInputCount: number;\n  triggerInputCount: number;\n}\n\nexport class InputComputer implements StatComputer<PlayerInput[]> {\n  private state = new Map<PlayerIndexedType, PlayerInput>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerInput = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): PlayerInput[] {\n    return Array.from(this.state.values());\n  }\n}\n\nfunction handleInputCompute(\n  frames: FramesType,\n  state: PlayerInput,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.pre;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.pre : null;\n\n  if (currentFrameNumber < Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  }\n\n  // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons!;\n  const currentButtons = playerFrame.physicalButtons!;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed;\n\n  // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX!, prevPlayerFrame.joystickY!);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX!, playerFrame.joystickY!);\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  }\n\n  // Do the same for c-stick\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX!, prevPlayerFrame.cStickY!);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX!, playerFrame.cStickY!);\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  }\n\n  // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n  if (prevPlayerFrame.physicalLTrigger! < 0.3 && playerFrame.physicalLTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n  if (prevPlayerFrame.physicalRTrigger! < 0.3 && playerFrame.physicalRTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\n\nfunction countSetBits(x: number): number {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n\n  let count;\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n  return count;\n}\n\nfunction getJoystickRegion(x: number, y: number): JoystickRegion {\n  let region = JoystickRegion.DZ;\n\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n\n  return region;\n}\n","import { EventEmitter } from \"events\";\nimport { filter, get, groupBy, last, orderBy } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface PlayerConversionState {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n}\n\ninterface MetadataType {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n}\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n","import { first, flatten, get, groupBy, keyBy, last, mapValues, zip } from \"lodash\";\n\nimport type { GameStartType } from \"../types\";\nimport type { ConversionType, InputCountsType, OverallType, RatioType } from \"./common\";\nimport type { PlayerInput } from \"./inputs\";\n\ninterface ConversionsByPlayerByOpening {\n  [playerIndex: string]: {\n    [openingType: string]: ConversionType[];\n  };\n}\n\nexport function generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount,\n}: {\n  settings: GameStartType;\n  inputs: PlayerInput[];\n  conversions: ConversionType[];\n  playableFrameCount: number;\n}): OverallType[] {\n  const inputsByPlayer = keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = groupBy(conversions, (conv) => conv.moves[0]?.playerIndex);\n  const conversionsByPlayerByOpening: ConversionsByPlayerByOpening = mapValues(conversionsByPlayer, (conversions) =>\n    groupBy(conversions, \"openingType\"),\n  );\n\n  const gameMinutes = playableFrameCount / 3600;\n\n  const overall = settings.players.map((player) => {\n    const playerIndex = player.playerIndex;\n\n    const playerInputs = get(inputsByPlayer, playerIndex) || {};\n    const inputCounts: InputCountsType = {\n      buttons: get(playerInputs, \"buttonInputCount\"),\n      triggers: get(playerInputs, \"triggerInputCount\"),\n      cstick: get(playerInputs, \"cstickInputCount\"),\n      joystick: get(playerInputs, \"joystickInputCount\"),\n      total: get(playerInputs, \"inputCount\"),\n    };\n    // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n    let conversionCount = 0;\n    let successfulConversionCount = 0;\n\n    const opponentIndices = settings.players\n      .filter((opp) => {\n        // We want players which aren't ourselves\n        if (opp.playerIndex === playerIndex) {\n          return false;\n        }\n\n        // Make sure they're not on our team either\n        return !settings.isTeams || opp.teamId !== player.teamId;\n      })\n      .map((opp) => opp.playerIndex);\n\n    let totalDamage = 0;\n    let killCount = 0;\n\n    // These are the conversions that we did on our opponents\n    originalConversions\n      // Filter down to conversions of our opponent\n      .filter((conversion) => conversion.playerIndex !== playerIndex)\n      .forEach((conversion) => {\n        conversionCount++;\n\n        // We killed the opponent\n        if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n          killCount += 1;\n        }\n        if (conversion.moves.length > 1 && conversion.moves[0]!.playerIndex === playerIndex) {\n          successfulConversionCount++;\n        }\n        conversion.moves.forEach((move) => {\n          if (move.playerIndex === playerIndex) {\n            totalDamage += move.damage;\n          }\n        });\n      });\n\n    return {\n      playerIndex: playerIndex,\n      inputCounts: inputCounts,\n      conversionCount: conversionCount,\n      totalDamage: totalDamage,\n      killCount: killCount,\n\n      successfulConversions: getRatio(successfulConversionCount, conversionCount),\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      digitalInputsPerMinute: getRatio(inputCounts.buttons, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n      counterHitRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"counter-attack\"),\n      beneficialTradeRatio: getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices),\n    };\n  });\n\n  return overall;\n}\n\nfunction getRatio(count: number, total: number): RatioType {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null,\n  };\n}\n\nfunction getOpeningRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n  type: string,\n): RatioType {\n  const openings = get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n\n  const opponentOpenings = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, type]) || []),\n  );\n\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\n\nfunction getBeneficialTradeRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n): RatioType {\n  const playerTrades = get(conversionsByPlayerByOpening, [playerIndex, \"trade\"]) || [];\n  const opponentTrades = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, \"trade\"]) || []),\n  );\n\n  const benefitsPlayer = [];\n\n  // Figure out which punishes benefited this player\n  const zippedTrades = zip(playerTrades, opponentTrades);\n  zippedTrades.forEach((conversionPair) => {\n    const playerConversion = first(conversionPair);\n    const opponentConversion = last(conversionPair);\n    if (playerConversion && opponentConversion) {\n      const playerDamage = playerConversion.currentPercent - playerConversion.startPercent;\n      const opponentDamage = opponentConversion.currentPercent - opponentConversion.startPercent;\n\n      if (playerConversion!.didKill && !opponentConversion!.didKill) {\n        benefitsPlayer.push(playerConversion);\n      } else if (playerDamage > opponentDamage) {\n        benefitsPlayer.push(playerConversion);\n      }\n    }\n  });\n\n  return getRatio(benefitsPlayer.length, playerTrades.length);\n}\n","import { get } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\n\nexport interface StatComputer<T> {\n  setup(settings: GameStartType): void;\n  processFrame(newFrame: FrameEntryType, allFrames: FramesType): void;\n  fetch(): T;\n}\n\nexport interface StatOptions {\n  processOnTheFly: boolean;\n}\n\nconst defaultOptions: StatOptions = {\n  processOnTheFly: false,\n};\n\nexport class Stats {\n  private options: StatOptions;\n  private lastProcessedFrame: number | null = null;\n  private frames: FramesType = {};\n  private players: number[] = [];\n  private allComputers = new Array<StatComputer<unknown>>();\n\n  public constructor(options?: StatOptions) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  /**\n   * Should reset the frames to their default values.\n   */\n  public setup(settings: GameStartType): void {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map((v) => v.playerIndex);\n\n    // Forward the settings on to the individual stat computer\n    this.allComputers.forEach((comp) => comp.setup(settings));\n  }\n\n  public register(...computer: StatComputer<unknown>[]): void {\n    this.allComputers.push(...computer);\n  }\n\n  public process(): void {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i];\n      // Don't attempt to compute stats on frames that have not been fully received\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach((comp) => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  public addFrame(frame: FrameEntryType): void {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\n\nfunction isCompletedFrame(players: number[], frame?: FrameEntryType): frame is FrameEntryType {\n  if (!frame) {\n    return false;\n  }\n\n  // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n  for (const player of players) {\n    const playerPostFrame = get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport type { PlayerIndexedType, StockType } from \"./common\";\nimport { didLoseStock, getSinglesPlayerPermutationsFromSettings, isDead } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface StockState {\n  stock?: StockType | null;\n}\n\nexport class StockComputer implements StatComputer<StockType[]> {\n  private state = new Map<PlayerIndexedType, StockState>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private stocks = new Array<StockType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: StockState = {\n        stock: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n\n  public fetch(): StockType[] {\n    return this.stocks;\n  }\n}\n\nfunction handleStockCompute(\n  frames: FramesType,\n  state: StockState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  stocks: StockType[],\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.post : null;\n\n  // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId!);\n    if (isPlayerDead) {\n      return;\n    }\n\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining!,\n      deathAnimation: null,\n    };\n\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = prevPlayerFrame.percent ?? 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    state.stock.currentPercent = playerFrame.percent ?? 0;\n  }\n}\n","import { decode, encode } from \"@shelacek/ubjson\";\n\nexport enum CommunicationType {\n  HANDSHAKE = 1,\n  REPLAY = 2,\n  KEEP_ALIVE = 3,\n}\n\nexport interface CommunicationMessage {\n  type: CommunicationType;\n  payload: {\n    cursor: Uint8Array;\n    clientToken: Uint8Array;\n    pos: Uint8Array;\n    nextPos: Uint8Array;\n    data: Uint8Array;\n    nick: string | null;\n    forcePos: boolean;\n    nintendontVersion: string | null;\n  };\n}\n\n// This class is responsible for handling the communication protocol between the Wii and the\n// desktop app\nexport class ConsoleCommunication {\n  private receiveBuf = Buffer.from([]);\n  private messages = new Array<CommunicationMessage>();\n\n  public receive(data: Buffer): void {\n    this.receiveBuf = Buffer.concat([this.receiveBuf, data]);\n\n    while (this.receiveBuf.length >= 4) {\n      // First get the size of the message we are expecting\n      const msgSize = this.receiveBuf.readUInt32BE(0);\n\n      if (this.receiveBuf.length < msgSize + 4) {\n        // If we haven't received all the data yet, let's wait for more\n        return;\n      }\n\n      // Here we have received all the data, so let's decode it\n      const ubjsonData = this.receiveBuf.slice(4, msgSize + 4);\n      this.messages.push(decode(ubjsonData));\n\n      // Remove the processed data from receiveBuf\n      this.receiveBuf = this.receiveBuf.slice(msgSize + 4);\n    }\n  }\n\n  public getReceiveBuffer(): Buffer {\n    return this.receiveBuf;\n  }\n\n  public getMessages(): Array<CommunicationMessage> {\n    const toReturn = this.messages;\n    this.messages = [];\n\n    return toReturn;\n  }\n\n  public genHandshakeOut(cursor: Uint8Array, clientToken: number, isRealtime = false): Buffer {\n    const clientTokenBuf = Buffer.from([0, 0, 0, 0]);\n    clientTokenBuf.writeUInt32BE(clientToken, 0);\n\n    const message = {\n      type: CommunicationType.HANDSHAKE,\n      payload: {\n        cursor: cursor,\n        clientToken: Uint8Array.from(clientTokenBuf), // TODO: Use real instance token\n        isRealtime: isRealtime,\n      },\n    };\n\n    const buf = encode(message, {\n      optimizeArrays: true,\n    });\n\n    const msg = Buffer.concat([Buffer.from([0, 0, 0, 0]), Buffer.from(buf)]);\n\n    msg.writeUInt32BE(buf.byteLength, 0);\n\n    return msg;\n  }\n}\n","import type { EventEmitter } from \"events\";\n\nexport enum ConnectionEvent {\n  CONNECT = \"connect\",\n  MESSAGE = \"message\",\n  HANDSHAKE = \"handshake\",\n  STATUS_CHANGE = \"statusChange\",\n  DATA = \"data\",\n  ERROR = \"error\",\n}\n\nexport enum ConnectionStatus {\n  DISCONNECTED = 0,\n  CONNECTING = 1,\n  CONNECTED = 2,\n  RECONNECT_WAIT = 3,\n}\n\nexport enum Ports {\n  DEFAULT = 51441,\n  LEGACY = 666,\n  RELAY_START = 53741,\n}\n\nexport interface ConnectionDetails {\n  consoleNick: string;\n  gameDataCursor: number | Uint8Array;\n  version: string;\n  clientToken?: number;\n}\n\nexport interface ConnectionSettings {\n  ipAddress: string;\n  port: number;\n}\n\nexport interface Connection extends EventEmitter {\n  getStatus(): ConnectionStatus;\n  getSettings(): ConnectionSettings;\n  getDetails(): ConnectionDetails;\n  connect(ip: string, port: number): void;\n  disconnect(): void;\n}\n","import { EventEmitter } from \"events\";\nimport net from \"net\";\nimport inject from \"reconnect-core\";\n\nimport type { CommunicationMessage } from \"./communication\";\nimport { CommunicationType, ConsoleCommunication } from \"./communication\";\nimport type { Connection, ConnectionDetails, ConnectionSettings } from \"./types\";\nimport { ConnectionEvent, ConnectionStatus, Ports } from \"./types\";\n\nexport const NETWORK_MESSAGE = \"HELO\\0\";\n\nconst DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\n\nenum CommunicationState {\n  INITIAL = \"initial\",\n  LEGACY = \"legacy\",\n  NORMAL = \"normal\",\n}\n\nconst defaultConnectionDetails: ConnectionDetails = {\n  consoleNick: \"unknown\",\n  gameDataCursor: Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),\n  version: \"\",\n  clientToken: 0,\n};\n\nconst consoleConnectionOptions = {\n  autoReconnect: true,\n};\n\nexport type ConsoleConnectionOptions = typeof consoleConnectionOptions;\n\n/**\n * Responsible for maintaining connection to a Slippi relay connection or Wii connection.\n * Events are emitted whenever data is received.\n *\n * Basic usage example:\n *\n * ```javascript\n * const { ConsoleConnection } = require(\"@slippi/slippi-js\");\n *\n * const connection = new ConsoleConnection();\n * connection.connect(\"localhost\", 667); // You should set these values appropriately\n *\n * connection.on(\"data\", (data) => {\n *   // Received data from console\n *   console.log(data);\n * });\n *\n * connection.on(\"statusChange\", (status) => {\n *   console.log(`status changed: ${status}`);\n * });\n * ```\n */\nexport class ConsoleConnection extends EventEmitter implements Connection {\n  private ipAddress: string;\n  private port: number;\n  private isRealtime: boolean;\n  private connectionStatus = ConnectionStatus.DISCONNECTED;\n  private connDetails: ConnectionDetails = { ...defaultConnectionDetails };\n  private client: net.Socket | null = null;\n  private connection: inject.Instance<unknown, net.Socket> | null = null;\n  private options: ConsoleConnectionOptions;\n  private shouldReconnect = false;\n\n  public constructor(options?: Partial<ConsoleConnectionOptions>) {\n    super();\n    this.ipAddress = \"0.0.0.0\";\n    this.port = Ports.DEFAULT;\n    this.isRealtime = false;\n    this.options = Object.assign({}, consoleConnectionOptions, options);\n  }\n\n  /**\n   * @returns The current connection status.\n   */\n  public getStatus(): ConnectionStatus {\n    return this.connectionStatus;\n  }\n\n  /**\n   * @returns The IP address and port of the current connection.\n   */\n  public getSettings(): ConnectionSettings {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port,\n    };\n  }\n\n  /**\n   * @returns The specific details about the connected console.\n   */\n  public getDetails(): ConnectionDetails {\n    return { ...this.connDetails };\n  }\n\n  /**\n   * Initiate a connection to the Wii or Slippi relay.\n   * @param ip   The IP address of the Wii or Slippi relay.\n   * @param port The port to connect to.\n   * @param isRealtime Optional. A flag to tell the Wii to send data as quickly as possible\n   * @param timeout Optional. The timeout in milliseconds when attempting to connect\n   *                to the Wii or relay.\n   */\n  public connect(ip: string, port: number, isRealtime = false, timeout = DEFAULT_CONNECTION_TIMEOUT_MS): void {\n    this.ipAddress = ip;\n    this.port = port;\n    this.isRealtime = isRealtime;\n    this._connectOnPort(ip, port, timeout);\n  }\n\n  private _connectOnPort(ip: string, port: number, timeout: number): void {\n    // set up reconnect\n    const reconnect = inject(() =>\n      net.connect({\n        host: ip,\n        port: port,\n        timeout: timeout,\n      }),\n    );\n\n    // Indicate we are connecting\n    this._setStatus(ConnectionStatus.CONNECTING);\n\n    // Prepare console communication obj for talking UBJSON\n    const consoleComms = new ConsoleCommunication();\n\n    // TODO: reconnect on failed reconnect, not sure how\n    // TODO: to do this\n    const connection = reconnect(\n      {\n        initialDelay: 2000,\n        maxDelay: 10000,\n        strategy: \"fibonacci\",\n        failAfter: Infinity,\n      },\n      (client) => {\n        this.emit(ConnectionEvent.CONNECT);\n        // We successfully connected so turn on auto-reconnect\n        this.shouldReconnect = this.options.autoReconnect;\n        this.client = client;\n\n        let commState: CommunicationState = CommunicationState.INITIAL;\n        client.on(\"data\", (data) => {\n          if (commState === CommunicationState.INITIAL) {\n            commState = this._getInitialCommState(data);\n            console.log(`Connected to ${ip}:${port} with type: ${commState}`);\n            this._setStatus(ConnectionStatus.CONNECTED);\n            console.log(data.toString(\"hex\"));\n          }\n\n          if (commState === CommunicationState.LEGACY) {\n            // If the first message received was not a handshake message, either we\n            // connected to an old Nintendont version or a relay instance\n            this._handleReplayData(data);\n            return;\n          }\n\n          try {\n            consoleComms.receive(data);\n          } catch (err) {\n            console.error(\"Failed to process new data from server...\", {\n              error: err,\n              prevDataBuf: consoleComms.getReceiveBuffer(),\n              rcvData: data,\n            });\n            client.destroy();\n            this.emit(ConnectionEvent.ERROR, err);\n            return;\n          }\n          const messages = consoleComms.getMessages();\n\n          // Process all of the received messages\n          try {\n            messages.forEach((message) => this._processMessage(message));\n          } catch (err) {\n            // Disconnect client to send another handshake message\n            console.error(err);\n            client.destroy();\n            this.emit(ConnectionEvent.ERROR, err);\n          }\n        });\n\n        client.on(\"timeout\", () => {\n          // const previouslyConnected = this.connectionStatus === ConnectionStatus.CONNECTED;\n          console.warn(`Attempted connection to ${ip}:${port} timed out after ${timeout}ms`);\n          client.destroy();\n        });\n\n        client.on(\"end\", () => {\n          console.log(\"disconnect\");\n          if (!this.shouldReconnect) {\n            client.destroy();\n          }\n        });\n\n        client.on(\"close\", () => {\n          console.log(\"connection was closed\");\n        });\n\n        const handshakeMsgOut = consoleComms.genHandshakeOut(\n          this.connDetails.gameDataCursor as Uint8Array,\n          this.connDetails.clientToken ?? 0,\n          this.isRealtime,\n        );\n\n        client.write(handshakeMsgOut);\n      },\n    );\n\n    const setConnectingStatus = (): void => {\n      // Indicate we are connecting\n      this._setStatus(this.shouldReconnect ? ConnectionStatus.RECONNECT_WAIT : ConnectionStatus.CONNECTING);\n    };\n\n    connection.on(\"connect\", setConnectingStatus);\n    connection.on(\"reconnect\", setConnectingStatus);\n\n    connection.on(\"disconnect\", () => {\n      if (!this.shouldReconnect) {\n        connection.reconnect = false;\n        connection.disconnect();\n        this._setStatus(ConnectionStatus.DISCONNECTED);\n      }\n      // TODO: Figure out how to set RECONNECT_WAIT state here. Currently it will stay on\n      // TODO: Connecting... forever\n    });\n\n    connection.on(\"error\", (err) => {\n      console.warn(`Connection on port ${port} encountered an error.`, err);\n\n      this._setStatus(ConnectionStatus.DISCONNECTED);\n      this.emit(ConnectionEvent.ERROR, `Connection on port ${port} encountered an error.\\n${err}`);\n    });\n\n    this.connection = connection;\n    connection.connect(port);\n  }\n\n  /**\n   * Terminate the current connection.\n   */\n  public disconnect(): void {\n    // Prevent reconnections and disconnect\n    if (this.connection) {\n      this.connection.reconnect = false;\n      this.connection.disconnect();\n      this.connection = null;\n    }\n\n    if (this.client) {\n      this.client.destroy();\n    }\n  }\n\n  private _getInitialCommState(data: Buffer): CommunicationState {\n    if (data.length < 13) {\n      return CommunicationState.LEGACY;\n    }\n\n    const openingBytes = Buffer.from([0x7b, 0x69, 0x04, 0x74, 0x79, 0x70, 0x65, 0x55, 0x01]);\n\n    const dataStart = data.slice(4, 13);\n\n    return dataStart.equals(openingBytes) ? CommunicationState.NORMAL : CommunicationState.LEGACY;\n  }\n\n  private _processMessage(message: CommunicationMessage): void {\n    this.emit(ConnectionEvent.MESSAGE, message);\n    switch (message.type) {\n      case CommunicationType.KEEP_ALIVE:\n        // console.log(\"Keep alive message received\");\n\n        // TODO: This is the jankiest shit ever but it will allow for relay connections not\n        // TODO: to time out as long as the main connection is still receving keep alive messages\n        // TODO: Need to figure out a better solution for this. There should be no need to have an\n        // TODO: active Wii connection for the relay connection to keep itself alive\n        const fakeKeepAlive = Buffer.from(NETWORK_MESSAGE);\n        this._handleReplayData(fakeKeepAlive);\n\n        break;\n      case CommunicationType.REPLAY:\n        const readPos = Uint8Array.from(message.payload.pos);\n        const cmp = Buffer.compare(this.connDetails.gameDataCursor as Uint8Array, readPos);\n        if (!message.payload.forcePos && cmp !== 0) {\n          // The readPos is not the one we are waiting on, throw error\n          throw new Error(\n            `Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${readPos.toString()}`,\n          );\n        }\n\n        if (message.payload.forcePos) {\n          console.warn(\n            \"Overflow occured in Nintendont, data has likely been skipped and replay corrupted. \" +\n              \"Expected, Received:\",\n            this.connDetails.gameDataCursor,\n            readPos,\n          );\n        }\n\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.nextPos);\n\n        const data = Uint8Array.from(message.payload.data);\n        this._handleReplayData(data);\n        break;\n      case CommunicationType.HANDSHAKE:\n        const { nick, nintendontVersion } = message.payload;\n        if (nick) {\n          this.connDetails.consoleNick = nick;\n        }\n        const tokenBuf = Buffer.from(message.payload.clientToken);\n        this.connDetails.clientToken = tokenBuf.readUInt32BE(0);\n        if (nintendontVersion) {\n          this.connDetails.version = nintendontVersion;\n        }\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.pos);\n        this.emit(ConnectionEvent.HANDSHAKE, this.connDetails);\n        break;\n      default:\n        // Should this be an error?\n        break;\n    }\n  }\n\n  private _handleReplayData(data: Uint8Array): void {\n    this.emit(ConnectionEvent.DATA, data);\n  }\n\n  private _setStatus(status: ConnectionStatus): void {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n}\n","import { EventEmitter } from \"events\";\n\nimport type { Connection, ConnectionDetails, ConnectionSettings } from \"./types\";\nimport { ConnectionEvent, ConnectionStatus, Ports } from \"./types\";\n\nconst MAX_PEERS = 32;\n\nexport enum DolphinMessageType {\n  CONNECT_REPLY = \"connect_reply\",\n  GAME_EVENT = \"game_event\",\n  START_GAME = \"start_game\",\n  END_GAME = \"end_game\",\n}\n\nexport class DolphinConnection extends EventEmitter implements Connection {\n  private ipAddress: string;\n  private port: number;\n  private connectionStatus = ConnectionStatus.DISCONNECTED;\n  private gameCursor = 0;\n  private nickname = \"unknown\";\n  private version = \"\";\n  private peer: any | null = null;\n\n  public constructor() {\n    super();\n    this.ipAddress = \"0.0.0.0\";\n    this.port = Ports.DEFAULT;\n  }\n\n  /**\n   * @returns The current connection status.\n   */\n  public getStatus(): ConnectionStatus {\n    return this.connectionStatus;\n  }\n\n  /**\n   * @returns The IP address and port of the current connection.\n   */\n  public getSettings(): ConnectionSettings {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port,\n    };\n  }\n\n  public getDetails(): ConnectionDetails {\n    return {\n      consoleNick: this.nickname,\n      gameDataCursor: this.gameCursor,\n      version: this.version,\n    };\n  }\n\n  public async connect(ip: string, port: number): Promise<void> {\n    console.log(`Connecting to: ${ip}:${port}`);\n    this.ipAddress = ip;\n    this.port = port;\n\n    const enet = await import(\"enet\");\n    // Create the enet client\n    const client = enet.createClient({ peers: MAX_PEERS, channels: 3, down: 0, up: 0 }, (err) => {\n      if (err) {\n        console.error(err);\n        return;\n      }\n    });\n\n    this.peer = client.connect(\n      {\n        address: this.ipAddress,\n        port: this.port,\n      },\n      3,\n      1337, // Data to send, not sure what this is or what this represents\n      (err: any, newPeer: any) => {\n        if (err) {\n          console.error(err);\n          return;\n        }\n\n        newPeer.ping();\n        this.emit(ConnectionEvent.CONNECT);\n        this._setStatus(ConnectionStatus.CONNECTED);\n      },\n    );\n\n    this.peer.on(\"connect\", () => {\n      // Reset the game cursor to the beginning of the game. Do we need to do this or\n      // should it just continue from where it left off?\n      this.gameCursor = 0;\n\n      const request = {\n        type: \"connect_request\",\n        cursor: this.gameCursor,\n      };\n      const packet = new enet.Packet(JSON.stringify(request), enet.PACKET_FLAG.RELIABLE);\n      this.peer.send(0, packet);\n    });\n\n    this.peer.on(\"message\", (packet: any) => {\n      const data = packet.data();\n      if (data.length === 0) {\n        return;\n      }\n\n      const dataString = data.toString(\"ascii\");\n      const message = JSON.parse(dataString);\n      const { dolphin_closed } = message;\n      if (dolphin_closed) {\n        // We got a disconnection request\n        this.disconnect();\n        return;\n      }\n      this.emit(ConnectionEvent.MESSAGE, message);\n      switch (message.type) {\n        case DolphinMessageType.CONNECT_REPLY:\n          this.connectionStatus = ConnectionStatus.CONNECTED;\n          this.gameCursor = message.cursor;\n          this.nickname = message.nick;\n          this.version = message.version;\n          this.emit(ConnectionEvent.HANDSHAKE, this.getDetails());\n          break;\n        case DolphinMessageType.GAME_EVENT: {\n          const { payload } = message;\n          //TODO: remove after game start and end messages have been in stable Ishii for a bit\n          if (!payload) {\n            // We got a disconnection request\n            this.disconnect();\n            return;\n          }\n\n          this._updateCursor(message, dataString);\n\n          const gameData = Buffer.from(payload, \"base64\");\n          this._handleReplayData(gameData);\n          break;\n        }\n        case DolphinMessageType.START_GAME: {\n          this._updateCursor(message, dataString);\n          break;\n        }\n        case DolphinMessageType.END_GAME: {\n          this._updateCursor(message, dataString);\n          break;\n        }\n      }\n    });\n\n    this.peer.on(\"disconnect\", () => {\n      this.disconnect();\n    });\n\n    this._setStatus(ConnectionStatus.CONNECTING);\n  }\n\n  public disconnect(): void {\n    if (this.peer) {\n      this.peer.disconnect();\n      this.peer = null;\n    }\n    this._setStatus(ConnectionStatus.DISCONNECTED);\n  }\n\n  private _handleReplayData(data: Uint8Array): void {\n    this.emit(ConnectionEvent.DATA, data);\n  }\n\n  private _setStatus(status: ConnectionStatus): void {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n\n  private _updateCursor(message: { cursor: number; next_cursor: number }, dataString: string): void {\n    const { cursor, next_cursor } = message;\n\n    if (this.gameCursor !== cursor) {\n      const err = new Error(\n        `Unexpected game data cursor. Expected: ${this.gameCursor} but got: ${cursor}. Payload: ${dataString}`,\n      );\n      console.warn(err);\n      this.emit(ConnectionEvent.ERROR, err);\n    }\n\n    this.gameCursor = next_cursor;\n  }\n}\n","import { decode } from \"@shelacek/ubjson\";\nimport fs from \"fs\";\nimport iconv from \"iconv-lite\";\nimport { mapValues } from \"lodash\";\n\nimport type { EventCallbackFunc, EventPayloadTypes, MetadataType, PlayerType, SelfInducedSpeedsType } from \"../types\";\nimport { Command } from \"../types\";\nimport { toHalfwidth } from \"./fullwidth\";\n\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\nexport interface SlpReadInput {\n  source: SlpInputSource;\n  filePath?: string;\n  buffer?: Buffer;\n}\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport interface SlpFileType {\n  ref: SlpRefType;\n  rawDataPosition: number;\n  rawDataLength: number;\n  metadataPosition: number;\n  metadataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n}\n\nexport interface SlpFileSourceRef {\n  source: SlpInputSource;\n  fileDescriptor: number;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Buffer;\n}\n\nfunction getRef(input: SlpReadInput): SlpRefType {\n  switch (input.source) {\n    case SlpInputSource.FILE:\n      if (!input.filePath) {\n        throw new Error(\"File source requires a file path\");\n      }\n      const fd = fs.openSync(input.filePath, \"r\");\n      return {\n        source: input.source,\n        fileDescriptor: fd,\n      } as SlpFileSourceRef;\n    case SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer,\n      } as SlpBufferSourceRef;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction readRef(ref: SlpRefType, buffer: Uint8Array, offset: number, length: number, position: number): number {\n  switch (ref.source) {\n    case SlpInputSource.FILE:\n      return fs.readSync((ref as SlpFileSourceRef).fileDescriptor, buffer, offset, length, position);\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.copy(buffer, offset, position, position + length);\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction getLenRef(ref: SlpRefType): number {\n  switch (ref.source) {\n    case SlpInputSource.FILE:\n      const fileStats = fs.fstatSync((ref as SlpFileSourceRef).fileDescriptor);\n      return fileStats.size;\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\n/**\n * Opens a file at path\n */\nexport function openSlpFile(input: SlpReadInput): SlpFileType {\n  const ref = getRef(input);\n\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n  const metadataLength = getMetadataLength(ref, metadataPosition);\n  const messageSizes = getMessageSizes(ref, rawDataPosition);\n\n  return {\n    ref: ref,\n    rawDataPosition: rawDataPosition,\n    rawDataLength: rawDataLength,\n    metadataPosition: metadataPosition,\n    metadataLength: metadataLength,\n    messageSizes: messageSizes,\n  };\n}\n\nexport function closeSlpFile(file: SlpFileType): void {\n  switch (file.ref.source) {\n    case SlpInputSource.FILE:\n      fs.closeSync((file.ref as SlpFileSourceRef).fileDescriptor);\n      break;\n  }\n}\n\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(ref: SlpRefType): number {\n  const buffer = new Uint8Array(1);\n  readRef(ref, buffer, 0, buffer.length, 0);\n\n  if (buffer[0] === 0x36) {\n    return 0;\n  }\n\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\n\nfunction getRawDataLength(ref: SlpRefType, position: number): number {\n  const fileSize = getLenRef(ref);\n  if (position === 0) {\n    return fileSize;\n  }\n\n  const buffer = new Uint8Array(4);\n  readRef(ref, buffer, 0, buffer.length, position - 4);\n\n  const rawDataLen = (buffer[0]! << 24) | (buffer[1]! << 16) | (buffer[2]! << 8) | buffer[3]!;\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  }\n\n  // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n  return fileSize - position;\n}\n\nfunction getMetadataLength(ref: SlpRefType, position: number): number {\n  const len = getLenRef(ref);\n  return len - position - 1;\n}\n\nfunction getMessageSizes(\n  ref: SlpRefType,\n  position: number,\n): {\n  [command: number]: number;\n} {\n  const messageSizes: {\n    [command: number]: number;\n  } = {};\n  // Support old file format\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n\n  const buffer = new Uint8Array(2);\n  readRef(ref, buffer, 0, buffer.length, position);\n  if (buffer[0] !== Command.MESSAGE_SIZES) {\n    return {};\n  }\n\n  const payloadLength = buffer[1] as number;\n  (messageSizes[0x35] as any) = payloadLength;\n\n  const messageSizesBuffer = new Uint8Array(payloadLength - 1);\n  readRef(ref, messageSizesBuffer, 0, messageSizesBuffer.length, position + 2);\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = messageSizesBuffer[i] as number;\n\n    // Get size of command\n    (messageSizes[command] as any) = (messageSizesBuffer[i + 1]! << 8) | messageSizesBuffer[i + 2]!;\n  }\n\n  return messageSizes;\n}\n\n/**\n * Iterates through slp events and parses payloads\n */\nexport function iterateEvents(\n  slpFile: SlpFileType,\n  callback: EventCallbackFunc,\n  startPos: number | null = null,\n): number {\n  const ref = slpFile.ref;\n\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength;\n\n  // Generate read buffers for each\n  const commandPayloadBuffers = mapValues(slpFile.messageSizes, (size) => new Uint8Array(size + 1));\n\n  const commandByteBuffer = new Uint8Array(1);\n  while (readPosition < stopReadingAt) {\n    readRef(ref, commandByteBuffer, 0, 1, readPosition);\n    const commandByte = commandByteBuffer[0] as number;\n    const buffer = commandPayloadBuffers[commandByte];\n    if (buffer === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n\n    if (buffer.length > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n\n    readRef(ref, buffer, 0, buffer.length, readPosition);\n    const parsedPayload = parseMessage(commandByte, buffer);\n    const shouldStop = callback(commandByte, parsedPayload);\n    if (shouldStop) {\n      break;\n    }\n\n    readPosition += buffer.length;\n  }\n\n  return readPosition;\n}\n\nexport function parseMessage(command: Command, payload: Uint8Array): EventPayloadTypes | null {\n  const view = new DataView(payload.buffer);\n  switch (command) {\n    case Command.GAME_START:\n      const getPlayerObject = (playerIndex: number): PlayerType => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let cfOption = \"None\";\n        if (dashback !== shieldDrop) {\n          cfOption = \"Mixed\";\n        } else if (dashback === 1) {\n          cfOption = \"UCF\";\n        } else if (dashback === 2) {\n          cfOption = \"Dween\";\n        }\n\n        // Nametag stuff\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = iconv\n          .decode(nametagBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\";\n\n        // Display name\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = iconv\n          .decode(displayNameBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\";\n\n        // Connect code\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = iconv\n          .decode(connectCodeBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n\n        const offset = playerIndex * 0x24;\n        return {\n          playerIndex: playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          type: readUint8(view, 0x66 + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          controllerFix: cfOption,\n          nametag: nametag,\n          displayName: displayName,\n          connectCode: connectCode,\n        };\n      };\n      return {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        isTeams: readBool(view, 0xd),\n        isPAL: readBool(view, 0x1a1),\n        stageId: readUint16(view, 0x13),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n      };\n    case Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        percent: readFloat(view, 0x3c),\n      };\n    case Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds: SelfInducedSpeedsType = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45),\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n      };\n    case Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a),\n      };\n    case Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5),\n      };\n    case Command.GAME_END:\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n      };\n    default:\n      return null;\n  }\n}\n\nfunction canReadFromView(view: DataView, offset: number, length: number): boolean {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\n\nfunction readFloat(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getFloat32(offset);\n}\n\nfunction readInt32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getInt32(offset);\n}\n\nfunction readInt8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getInt8(offset);\n}\n\nfunction readUint32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getUint32(offset);\n}\n\nfunction readUint16(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n\n  return view.getUint16(offset);\n}\n\nfunction readUint8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getUint8(offset);\n}\n\nfunction readBool(view: DataView, offset: number): boolean | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return !!view.getUint8(offset);\n}\n\nexport function getMetadata(slpFile: SlpFileType): MetadataType | null {\n  if (slpFile.metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    // $FlowFixMe\n    return null;\n  }\n\n  const buffer = new Uint8Array(slpFile.metadataLength);\n\n  readRef(slpFile.ref, buffer, 0, buffer.length, slpFile.metadataPosition);\n\n  let metadata = null;\n  try {\n    metadata = decode(buffer);\n  } catch (ex) {\n    // Do nothing\n    // console.log(ex);\n  }\n\n  // $FlowFixMe\n  return metadata;\n}\n","import type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\n\nimport { NETWORK_MESSAGE } from \"../console\";\nimport type { EventPayloadTypes } from \"../types\";\nimport { Command } from \"../types\";\nimport { parseMessage } from \"./slpReader\";\n\nexport enum SlpStreamMode {\n  AUTO = \"AUTO\", // Always reading data, but errors on invalid command\n  MANUAL = \"MANUAL\", // Stops parsing inputs after a valid game end command, requires manual restarting\n}\n\nconst defaultSettings = {\n  suppressErrors: false,\n  mode: SlpStreamMode.AUTO,\n};\n\nexport type SlpStreamSettings = typeof defaultSettings;\n\nexport type MessageSizes = Map<Command, number>;\n\nexport interface SlpCommandEventPayload {\n  command: Command;\n  payload: EventPayloadTypes | MessageSizes;\n}\n\nexport interface SlpRawEventPayload {\n  command: Command;\n  payload: Buffer;\n}\n\nexport enum SlpStreamEvent {\n  RAW = \"slp-raw\",\n  COMMAND = \"slp-command\",\n}\n\n/**\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\n * and emits an event based on what kind of Slippi messages were processed.\n *\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\n * bytes whenever it processes each command. You can manually parse this or write it to a\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\n *\n * @class SlpStream\n * @extends {Writable}\n */\nexport class SlpStream extends Writable {\n  private gameEnded = false; // True only if in manual mode and the game has completed\n  private settings: SlpStreamSettings;\n  private payloadSizes: MessageSizes | null = null;\n  private previousBuffer: Uint8Array = Buffer.from([]);\n\n  /**\n   *Creates an instance of SlpStream.\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\n   * @param {WritableOptions} [opts]\n   * @memberof SlpStream\n   */\n  public constructor(slpOptions?: Partial<SlpStreamSettings>, opts?: WritableOptions) {\n    super(opts);\n    this.settings = Object.assign({}, defaultSettings, slpOptions);\n  }\n\n  public restart(): void {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public _write(newData: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n\n    // Join the current data with the old data\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData]));\n\n    // Clear previous data\n    this.previousBuffer = Buffer.from([]);\n\n    const dataView = new DataView(data.buffer);\n\n    // Iterate through the data\n    let index = 0;\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      }\n\n      // Make sure we have enough data to read a full payload\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n      if (this.payloadSizes) {\n        payloadSize = this.payloadSizes.get(command) ?? 0;\n      }\n      const remainingLen = data.length - index;\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      }\n\n      // Only process if the game is still going\n      if (this.settings.mode === SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      }\n\n      // Increment by one for the command byte\n      index += 1;\n\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n        payloadLen = 0;\n      }\n      index += payloadLen;\n    }\n\n    callback();\n  }\n\n  private _writeCommand(command: Command, entirePayload: Uint8Array, payloadSize: number): Uint8Array {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]);\n    // Forward the raw buffer onwards\n    this.emit(SlpStreamEvent.RAW, {\n      command: command,\n      payload: bufToWrite,\n    } as SlpRawEventPayload);\n    return new Uint8Array(bufToWrite);\n  }\n\n  private _processCommand(command: Command, entirePayload: Uint8Array, dataView: DataView): number {\n    // Handle the message size command\n    if (command === Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0);\n      // Set the payload sizes\n      this.payloadSizes = processReceiveCommands(dataView);\n      // Emit the raw command event\n      this._writeCommand(command, entirePayload, payloadSize);\n      this.emit(SlpStreamEvent.COMMAND, {\n        command: command,\n        payload: this.payloadSizes,\n      } as SlpCommandEventPayload);\n      return payloadSize;\n    }\n\n    let payloadSize = 0;\n    if (this.payloadSizes) {\n      payloadSize = this.payloadSizes.get(command) ?? 0;\n    }\n\n    // Fetch the payload and parse it\n    let payload: Uint8Array;\n    let parsedPayload: EventPayloadTypes | null = null;\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n\n    switch (command) {\n      case Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n        break;\n    }\n\n    this.emit(SlpStreamEvent.COMMAND, {\n      command: command,\n      payload: parsedPayload,\n    } as SlpCommandEventPayload);\n    return payloadSize;\n  }\n}\n\nconst processReceiveCommands = (dataView: DataView): MessageSizes => {\n  const payloadSizes = new Map<Command, number>();\n  const payloadLen = dataView.getUint8(0);\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n  return payloadSizes;\n};\n","import { map } from \"lodash\";\n\nexport function toHalfwidth(str: string): string {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = (charCode: number): number => {\n    /**\n     * Standard full width encodings\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    }\n\n    // space:\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n\n    /**\n     * Exceptions found in Melee/Japanese keyboards\n     */\n    // single quote: '\n    if (charCode === 0x2019) {\n      return 0x0027;\n    }\n\n    // double quote: \"\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n\n    return charCode;\n  };\n\n  const ret = map(str, (char) => convertChar(char.charCodeAt(0)));\n\n  return String.fromCharCode(...ret);\n}\n","import type { WriteStream } from \"fs\";\nimport fs from \"fs\";\nimport { forEach } from \"lodash\";\nimport type { Moment } from \"moment\";\nimport moment from \"moment\";\nimport type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\n\nimport type { GameStartType, PostFrameUpdateType } from \"../types\";\nimport { Command } from \"../types\";\nimport type { SlpCommandEventPayload } from \"./slpStream\";\nimport { SlpStream, SlpStreamEvent, SlpStreamMode } from \"./slpStream\";\n\nconst DEFAULT_NICKNAME = \"unknown\";\n\nexport interface SlpFileMetadata {\n  startTime: Moment;\n  lastFrame: number;\n  players: {\n    [playerIndex: number]: {\n      characterUsage: {\n        [internalCharacterId: number]: number;\n      };\n      names: {\n        netplay: string;\n        code: string;\n      };\n    };\n  };\n  consoleNickname?: string;\n}\n\n/**\n * SlpFile is a class that wraps a Writable stream. It handles the writing of the binary\n * header and footer, and also handles the overwriting of the raw data length.\n *\n * @class SlpFile\n * @extends {Writable}\n */\nexport class SlpFile extends Writable {\n  private filePath: string;\n  private metadata: SlpFileMetadata;\n  private fileStream: WriteStream | null = null;\n  private rawDataLength = 0;\n  private slpStream: SlpStream;\n  private usesExternalStream = false;\n\n  /**\n   * Creates an instance of SlpFile.\n   * @param {string} filePath The file location to write to.\n   * @param {WritableOptions} [opts] Options for writing.\n   * @memberof SlpFile\n   */\n  public constructor(filePath: string, slpStream?: SlpStream, opts?: WritableOptions) {\n    super(opts);\n    this.filePath = filePath;\n    this.metadata = {\n      consoleNickname: DEFAULT_NICKNAME,\n      startTime: moment(),\n      lastFrame: -124,\n      players: {},\n    };\n    this.usesExternalStream = Boolean(slpStream);\n\n    // Create a new SlpStream if one wasn't already provided\n    // This SLP stream represents a single game not multiple, so use manual mode\n    this.slpStream = slpStream ? slpStream : new SlpStream({ mode: SlpStreamMode.MANUAL });\n\n    this._setupListeners();\n    this._initializeNewGame(this.filePath);\n  }\n\n  /**\n   * Get the current file path being written to.\n   *\n   * @returns {string} The location of the current file path\n   * @memberof SlpFile\n   */\n  public path(): string {\n    return this.filePath;\n  }\n\n  /**\n   * Sets the metadata of the Slippi file, such as consoleNickname, lastFrame, and players.\n   * @param metadata The metadata to be written\n   */\n  public setMetadata(metadata: Partial<SlpFileMetadata>): void {\n    this.metadata = Object.assign({}, this.metadata, metadata);\n  }\n\n  public _write(chunk: Uint8Array, encoding: string, callback: (error?: Error | null) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n    // Write it to the file\n    if (this.fileStream) {\n      this.fileStream.write(chunk);\n    }\n\n    // Parse the data manually if it's an internal stream\n    if (!this.usesExternalStream) {\n      this.slpStream.write(chunk);\n    }\n\n    // Keep track of the bytes we've written\n    this.rawDataLength += chunk.length;\n    callback();\n  }\n\n  /**\n   * Here we define what to do on each command. We need to populate the metadata field\n   * so we keep track of the latest frame, as well as the number of frames each character has\n   * been used.\n   *\n   * @param data The parsed data from a SlpStream\n   */\n  private _onCommand(data: SlpCommandEventPayload): void {\n    const { command, payload } = data;\n    switch (command) {\n      case Command.GAME_START:\n        const { players } = payload as GameStartType;\n        forEach(players, (player) => {\n          if (player.type === 3) {\n            return;\n          }\n\n          this.metadata.players[player.playerIndex] = {\n            characterUsage: {},\n            names: {\n              netplay: player.displayName,\n              code: player.connectCode,\n            },\n          };\n        });\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // Here we need to update some metadata fields\n        const { frame, playerIndex, isFollower, internalCharacterId } = payload as PostFrameUpdateType;\n        if (isFollower) {\n          // No need to do this for follower\n          break;\n        }\n\n        // Update frame index\n        this.metadata.lastFrame = frame!;\n\n        // Update character usage\n        const prevPlayer = this.metadata.players[playerIndex!];\n        const characterUsage = prevPlayer!.characterUsage;\n        const curCharFrames = characterUsage[internalCharacterId!] || 0;\n        const player = {\n          ...prevPlayer,\n          characterUsage: {\n            ...characterUsage,\n            [internalCharacterId!]: curCharFrames + 1,\n          },\n        };\n        (this.metadata.players as any)[playerIndex!] = player;\n        break;\n    }\n  }\n\n  private _setupListeners(): void {\n    const streamListener = (data: SlpCommandEventPayload): void => {\n      this._onCommand(data);\n    };\n    this.slpStream.on(SlpStreamEvent.COMMAND, streamListener);\n\n    this.on(\"finish\", () => {\n      // Update file with bytes written\n      const fd = fs.openSync(this.filePath, \"r+\");\n      fs.writeSync(fd, createUInt32Buffer(this.rawDataLength), 0, 4, 11);\n      fs.closeSync(fd);\n\n      // Unsubscribe from the stream\n      this.slpStream.removeListener(SlpStreamEvent.COMMAND, streamListener);\n      // Terminate the internal stream\n      if (!this.usesExternalStream) {\n        this.slpStream.end();\n      }\n    });\n  }\n\n  private _initializeNewGame(filePath: string): void {\n    this.fileStream = fs.createWriteStream(filePath, {\n      encoding: \"binary\",\n    });\n\n    const header = Buffer.concat([\n      Buffer.from(\"{U\"),\n      Buffer.from([3]),\n      Buffer.from(\"raw[$U#l\"),\n      Buffer.from([0, 0, 0, 0]),\n    ]);\n    this.fileStream.write(header);\n  }\n\n  public _final(callback: (error?: Error | null) => void): void {\n    let footer = Buffer.concat([Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"metadata{\")]);\n\n    // Write game start time\n    const startTimeStr = this.metadata.startTime.toISOString();\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([7]),\n      Buffer.from(\"startAtSU\"),\n      Buffer.from([startTimeStr.length]),\n      Buffer.from(startTimeStr),\n    ]);\n\n    // Write last frame index\n    // TODO: Get last frame\n    const lastFrame = this.metadata.lastFrame;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([9]),\n      Buffer.from(\"lastFramel\"),\n      createInt32Buffer(lastFrame),\n    ]);\n\n    // write the Console Nickname\n    const consoleNick = this.metadata.consoleNickname || DEFAULT_NICKNAME;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([11]),\n      Buffer.from(\"consoleNickSU\"),\n      Buffer.from([consoleNick.length]),\n      Buffer.from(consoleNick),\n    ]);\n\n    // Start writting player specific data\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"players{\")]);\n    const players = this.metadata.players;\n    forEach(players, (player, index) => {\n      // Start player obj with index being the player index\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([index.length]), Buffer.from(`${index}{`)]);\n\n      // Start characters key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([10]), Buffer.from(\"characters{\")]);\n\n      // Write character usage\n      forEach(player.characterUsage, (usage, internalId) => {\n        // Write this character\n        footer = Buffer.concat([\n          footer,\n          Buffer.from(\"U\"),\n          Buffer.from([internalId.length]),\n          Buffer.from(`${internalId}l`),\n          createUInt32Buffer(usage),\n        ]);\n      });\n\n      // Close characters\n      footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n      // Start names key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([5]), Buffer.from(\"names{\")]);\n\n      // Write display name\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([7]),\n        Buffer.from(\"netplaySU\"),\n        Buffer.from([player.names.netplay.length]),\n        Buffer.from(`${player.names.netplay}`),\n      ]);\n\n      // Write connect code\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([4]),\n        Buffer.from(\"codeSU\"),\n        Buffer.from([player.names.code.length]),\n        Buffer.from(`${player.names.code}`),\n      ]);\n\n      // Close names and player\n      footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n    });\n\n    // Close players\n    footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n    // Write played on\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([8]),\n      Buffer.from(\"playedOnSU\"),\n      Buffer.from([7]),\n      Buffer.from(\"network\"),\n    ]);\n\n    // Close metadata and file\n    footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n\n    // End the stream\n    if (this.fileStream) {\n      this.fileStream.write(footer, callback);\n    }\n  }\n}\n\nconst createInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32BE(number, 0);\n  return buf;\n};\n\nconst createUInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32BE(number, 0);\n  return buf;\n};\n","import type { Moment } from \"moment\";\nimport moment from \"moment\";\nimport path from \"path\";\nimport type { WritableOptions } from \"stream\";\n\nimport { Command } from \"../types\";\nimport { SlpFile } from \"./slpFile\";\nimport type { SlpRawEventPayload, SlpStreamSettings } from \"./slpStream\";\nimport { SlpStream, SlpStreamEvent } from \"./slpStream\";\n\n/**\n * The default function to use for generating new SLP files.\n */\nfunction getNewFilePath(folder: string, m: Moment): string {\n  return path.join(folder, `Game_${m.format(\"YYYYMMDD\")}T${m.format(\"HHmmss\")}.slp`);\n}\n\nexport interface SlpFileWriterOptions extends Partial<SlpStreamSettings> {\n  outputFiles: boolean;\n  folderPath: string;\n  consoleNickname: string;\n  newFilename: (folder: string, startTime: Moment) => string;\n}\n\nconst defaultSettings: SlpFileWriterOptions = {\n  outputFiles: true,\n  folderPath: \".\",\n  consoleNickname: \"unknown\",\n  newFilename: getNewFilePath,\n};\n\nexport enum SlpFileWriterEvent {\n  NEW_FILE = \"new-file\",\n  FILE_COMPLETE = \"file-complete\",\n}\n\n/**\n * SlpFileWriter lets us not only emit events as an SlpStream but also\n * writes the data that is being passed in to an SLP file. Use this if\n * you want to process Slippi data in real time but also want to be able\n * to write out the data to an SLP file.\n *\n * @export\n * @class SlpFileWriter\n * @extends {SlpStream}\n */\nexport class SlpFileWriter extends SlpStream {\n  private currentFile: SlpFile | null = null;\n  private options: SlpFileWriterOptions;\n\n  /**\n   * Creates an instance of SlpFileWriter.\n   */\n  public constructor(options?: Partial<SlpFileWriterOptions>, opts?: WritableOptions) {\n    super(options, opts);\n    this.options = Object.assign({}, defaultSettings, options);\n    this._setupListeners();\n  }\n\n  private _writePayload(payload: Buffer): void {\n    // Write data to the current file\n    if (this.currentFile) {\n      this.currentFile.write(payload);\n    }\n  }\n\n  private _setupListeners(): void {\n    this.on(SlpStreamEvent.RAW, (data: SlpRawEventPayload) => {\n      const { command, payload } = data;\n      switch (command) {\n        case Command.MESSAGE_SIZES:\n          // Create the new game first before writing the payload\n          this._handleNewGame();\n          this._writePayload(payload);\n          break;\n        case Command.GAME_END:\n          // Write payload first before ending the game\n          this._writePayload(payload);\n          this._handleEndGame();\n          break;\n        default:\n          this._writePayload(payload);\n          break;\n      }\n    });\n  }\n\n  /**\n   * Return the name of the SLP file currently being written or null if\n   * no file is being written to currently.\n   *\n   * @returns {(string | null)}\n   * @memberof SlpFileWriter\n   */\n  public getCurrentFilename(): string | null {\n    if (this.currentFile !== null) {\n      return path.resolve(this.currentFile.path());\n    }\n    return null;\n  }\n\n  /**\n   * Ends the current file being written to.\n   *\n   * @returns {(string | null)}\n   * @memberof SlpFileWriter\n   */\n  public endCurrentFile(): void {\n    this._handleEndGame();\n  }\n\n  /**\n   * Updates the settings to be the desired ones passed in.\n   *\n   * @param {Partial<SlpFileWriterOptions>} settings\n   * @memberof SlpFileWriter\n   */\n  public updateSettings(settings: Partial<SlpFileWriterOptions>): void {\n    this.options = Object.assign({}, this.options, settings);\n  }\n\n  private _handleNewGame(): void {\n    // Only create a new file if we're outputting files\n    if (this.options.outputFiles) {\n      const filePath = this.options.newFilename(this.options.folderPath, moment());\n      this.currentFile = new SlpFile(filePath, this);\n      // console.log(`Creating new file at: ${filePath}`);\n      this.emit(SlpFileWriterEvent.NEW_FILE, filePath);\n    }\n  }\n\n  private _handleEndGame(): void {\n    // End the stream\n    if (this.currentFile) {\n      // Set the console nickname\n      this.currentFile.setMetadata({\n        consoleNickname: this.options.consoleNickname,\n      });\n      this.currentFile.end();\n\n      // console.log(`Finished writing file: ${this.currentFile.path()}`);\n      this.emit(SlpFileWriterEvent.FILE_COMPLETE, this.currentFile.path());\n\n      // Clear current file\n      this.currentFile = null;\n    }\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { get, keyBy, set } from \"lodash\";\nimport semver from \"semver\";\n\nimport type {\n  FrameBookendType,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n    }\n  }\n\n  /**\n   * Resets the parser state to their default values.\n   */\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return this.latestFrameIndex < Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - Frames.FIRST_PLAYABLE;\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload as GameEndType;\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    payload = payload as PostFrameUpdateType;\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n","import type { FrameEntryType, RollbackFramesType } from \"../types\";\n\nexport class RollbackCounter {\n  private rollbackFrames: RollbackFramesType = {};\n  private rollbackFrameCount = 0;\n  private rollbackPlayerIdx: number | null = null; // for keeping track of rollbacks by following a single player\n  private lastFrameWasRollback = false;\n  private currentRollbackLength = 0;\n  private rollbackLengths: number[] = [];\n\n  public checkIfRollbackFrame(currentFrame: FrameEntryType | undefined, playerIdx: number) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n\n    if (currentFrame) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame]!.push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n    return this.lastFrameWasRollback;\n  }\n\n  public getFrames() {\n    return this.rollbackFrames;\n  }\n\n  public getCount() {\n    return this.rollbackFrameCount;\n  }\n\n  public getLengths() {\n    return this.rollbackLengths;\n  }\n}\n","import type { StatOptions, StatsType } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  generateOverallStats,\n  InputComputer,\n  Stats,\n  StockComputer,\n} from \"./stats\";\n// Type imports\nimport type { FrameEntryType, FramesType, GameEndType, GameStartType, MetadataType, RollbackFrames } from \"./types\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport type { SlpReadInput } from \"./utils/slpReader\";\nimport { closeSlpFile, getMetadata, iterateEvents, openSlpFile, SlpInputSource } from \"./utils/slpReader\";\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: string | Buffer | ArrayBuffer, opts?: StatOptions) {\n    if (typeof input === \"string\") {\n      this.input = {\n        source: SlpInputSource.FILE,\n        filePath: input,\n      };\n    } else if (input instanceof Buffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: input,\n      };\n    } else if (input instanceof ArrayBuffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: Buffer.from(input),\n      };\n    } else {\n      throw new Error(\"Cannot create SlippiGame with input of that type\");\n    }\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n    );\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(settingsOnly = false): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = openSlpFile(this.input);\n    // Generate settings from iterating through file\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return settingsOnly && this.parser.getSettings() !== null;\n      },\n      this.readPosition,\n    );\n    closeSlpFile(slpfile);\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(true);\n    return this.parser.getSettings();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(): GameEndType | null {\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getFrames(): FramesType {\n    this._process();\n    return this.parser.getFrames();\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (settings === null) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const stats = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete: this.parser.getGameEnd() !== null,\n    };\n\n    if (this.parser.getGameEnd() !== null) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n\n  public getFilePath(): string | null {\n    if (this.input.source !== SlpInputSource.FILE) {\n      return null;\n    }\n\n    return this.input.filePath ?? null;\n  }\n}\n","// eslint-disable-next-line\nexport function getDeathDirection(actionStateId: number) {\n  if (actionStateId > 0xa) {\n    return null;\n  }\n\n  switch (actionStateId) {\n    case 0:\n      return \"down\";\n    case 1:\n      return \"left\";\n    case 2:\n      return \"right\";\n    default:\n      return \"up\";\n  }\n}\n"],"names":["Character","Stage","UnknownCharacter","id","name","shortName","colors","externalCharacters","CAPTAIN_FALCON","DONKEY_KONG","FOX","GAME_AND_WATCH","KIRBY","BOWSER","LINK","LUIGI","MARIO","MARTH","MEWTWO","NESS","PEACH","PIKACHU","ICE_CLIMBERS","JIGGLYPUFF","SAMUS","YOSHI","ZELDA","SHEIK","FALCO","YOUNG_LINK","DR_MARIO","ROY","PICHU","GANONDORF","getCharacterInfo","externalCharacterId","characterColor","UnknownMove","moves","getMoveInfo","moveId","UnknownStage","stages","FOUNTAIN_OF_DREAMS","POKEMON_STADIUM","PEACHS_CASTLE","KONGO_JUNGLE","BRINSTAR","CORNERIA","YOSHIS_STORY","ONETT","MUTE_CITY","RAINBOW_CRUISE","JUNGLE_JAPES","GREAT_BAY","HYRULE_TEMPLE","BRINSTAR_DEPTHS","YOSHIS_ISLAND","GREEN_GREENS","FOURSIDE","MUSHROOM_KINGDOM","MUSHROOM_KINGDOM_2","VENOM","POKE_FLOATS","BIG_BLUE","ICICLE_MOUNTAIN","ICETOP","FLAT_ZONE","DREAMLAND","YOSHIS_ISLAND_N64","KONGO_JUNGLE_N64","BATTLEFIELD","FINAL_DESTINATION","TARGET_TEST_MARIO","TARGET_TEST_CAPTAIN_FALCON","TARGET_TEST_YOUNG_LINK","TARGET_TEST_DONKEY_KONG","TARGET_TEST_DR_MARIO","TARGET_TEST_FALCO","TARGET_TEST_FOX","TARGET_TEST_ICE_CLIMBERS","TARGET_TEST_KIRBY","TARGET_TEST_BOWSER","TARGET_TEST_LINK","TARGET_TEST_LUIGI","TARGET_TEST_MARTH","TARGET_TEST_MEWTWO","TARGET_TEST_NESS","TARGET_TEST_PEACH","TARGET_TEST_PICHU","TARGET_TEST_PIKACHU","TARGET_TEST_JIGGLYPUFF","TARGET_TEST_SAMUS","TARGET_TEST_SHEIK","TARGET_TEST_YOSHI","TARGET_TEST_ZELDA","TARGET_TEST_GAME_AND_WATCH","TARGET_TEST_ROY","TARGET_TEST_GANONDORF","HOME_RUN_CONTEST","getStageInfo","stageId","State","Timers","PUNISH_RESET_FRAMES","RECOVERY_RESET_FRAMES","COMBO_STRING_RESET_FRAMES","getSinglesPlayerPermutationsFromSettings","settings","players","length","playerIndex","opponentIndex","didLoseStock","frame","prevFrame","stocksRemaining","isInControl","state","ground","GROUNDED_CONTROL_START","GROUNDED_CONTROL_END","squat","SQUAT_START","SQUAT_END","groundAttack","GROUND_ATTACK_START","GROUND_ATTACK_END","isGrab","GRAB","isTeching","TECH_START","TECH_END","isDown","DOWN_START","DOWN_END","isDamaged","DAMAGE_START","DAMAGE_END","DAMAGE_FALL","isGrabbed","CAPTURE_START","CAPTURE_END","isCommandGrabbed","COMMAND_GRAB_RANGE1_START","COMMAND_GRAB_RANGE1_END","COMMAND_GRAB_RANGE2_START","COMMAND_GRAB_RANGE2_END","BARREL_WAIT","isDead","DYING_START","DYING_END","calcDamageTaken","percent","dashDanceAnimations","DASH","TURN","ActionsComputer","playerPermutations","Array","Map","setup","forEach","indices","set","playerCounts","wavedashCount","wavelandCount","airDodgeCount","dashDanceCount","spotDodgeCount","ledgegrabCount","rollCount","lCancelCount","success","fail","grabCount","throwCount","up","forward","back","down","groundTechCount","away","in","neutral","wallTechCount","animations","processFrame","this","get","playerFrame","post","opponentFrame","incrementCount","field","condition","current","currentAnimation","actionStateId","push","last3Frames","slice","prevAnimation","newAnimation","isEqual","didRoll","previousAnimation","isCurrentlyRolling","isRolling","wasPreviouslyRolling","didStartRoll","didSpotDodge","isCurrentlyDodging","isSpotDodging","wasPreviouslyDodging","didStartSpotDodge","didAirDodge","isAirDodging","didStartAirDodge","didGrabLedge","isCurrentlyGrabbingLedge","isGrabbingLedge","wasPreviouslyGrabbingLedge","didStartLedgegrab","didGrabSucceed","GRAB_WAIT","didStartGrabSuccess","didGrabFail","didStartGrabFail","THROW_UP","THROW_FORWARD","THROW_DOWN","THROW_BACK","animation","TECH_MISS_DOWN","TECH_MISS_UP","opponentDir","facingOpponent","positionX","facingDirection","FORWARD_TECH","BACKWARD_TECH","NEUTRAL_TECH","WALL_TECH","MISSED_WALL_TECH","AERIAL_ATTACK_START","AERIAL_ATTACK_END","isAerialAttack","lCancelStatus","counts","isSpecialLanding","last","LANDING_FALL_SPECIAL","isAcceptablePrevious","AIR_DODGE","isAboveMin","CONTROLLED_JUMP_START","isBelowMax","CONTROLLED_JUMP_END","isWavedashInitiationAnimation","recentFrames","recentAnimations","keyBy","size","ACTION_KNEE_BEND","handleActionWavedash","handleActionCompute","fetch","from","values","map","val","ROLL_BACKWARD","ROLL_FORWARD","SPOT_DODGE","CLIFF_CATCH","ComboEvent","Command","GameMode","Frames","JoystickRegion","ComboComputer","EventEmitter","combos","combo","move","resetCounter","lastHitAnimation","event","allFrames","frames","currentFrameNumber","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","opntIsDamaged","opntIsGrabbed","opntIsCommandGrabbed","opntDamageTaken","actionStateCounter","comboStarted","startFrame","endFrame","startPercent","currentPercent","endPercent","didKill","lastHitBy","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","opntIsDowned","opntDidLoseStock","opntIsDying","shouldTerminate","COMBO_END","handleComboCompute","emit","ConversionComputer","constructor","conversions","metadata","lastEndFrameByOppIdx","conversion","terminated","openingType","opntInControl","handleConversionCompute","_populateConversionTypes","conversionsToHandle","filter","groupedConversions","groupBy","orderBy","isTrade","lastMove","oppEndFrame","InputComputer","inputCount","joystickInputCount","cstickInputCount","buttonInputCount","triggerInputCount","pre","FIRST_PLAYABLE","newInputsPressed","x","count","bits","countSetBits","physicalButtons","prevAnalogRegion","getJoystickRegion","joystickX","joystickY","currentAnalogRegion","DZ","prevCstickRegion","cStickX","cStickY","currentCstickRegion","physicalLTrigger","physicalRTrigger","handleInputCompute","y","region","NE","SE","SW","NW","N","E","S","W","generateOverallStats","inputs","playableFrameCount","inputsByPlayer","originalConversions","conversionsByPlayer","conv","_conv$moves$","conversionsByPlayerByOpening","mapValues","gameMinutes","player","playerInputs","inputCounts","buttons","triggers","cstick","joystick","total","conversionCount","successfulConversionCount","opponentIndices","opp","isTeams","teamId","totalDamage","killCount","successfulConversions","getRatio","inputsPerMinute","digitalInputsPerMinute","openingsPerKill","damagePerOpening","neutralWinRatio","getOpeningRatio","counterHitRatio","beneficialTradeRatio","getBeneficialTradeRatio","ratio","type","openings","opponentOpenings","flatten","playerTrades","opponentTrades","benefitsPlayer","zip","conversionPair","playerConversion","first","opponentConversion","playerDamage","opponentDamage","defaultOptions","processOnTheFly","Stats","options","lastProcessedFrame","allComputers","Object","assign","v","comp","register","computer","process","i","FIRST","isCompletedFrame","addFrame","StockComputer","stocks","stock","deathAnimation","handleStockCompute","CommunicationType","ConnectionEvent","ConnectionStatus","Ports","CommunicationState","ConsoleCommunication","receiveBuf","Buffer","messages","receive","data","concat","msgSize","readUInt32BE","ubjsonData","decode","getReceiveBuffer","getMessages","toReturn","genHandshakeOut","cursor","clientToken","isRealtime","clientTokenBuf","writeUInt32BE","message","HANDSHAKE","payload","Uint8Array","buf","encode","optimizeArrays","msg","byteLength","defaultConnectionDetails","consoleNick","gameDataCursor","version","consoleConnectionOptions","autoReconnect","DolphinMessageType","SlpInputSource","SlpStreamMode","toHalfwidth","str","ret","char","convertChar","charCode","charCodeAt","String","fromCharCode","readRef","ref","buffer","offset","position","source","FILE","fs","readSync","fileDescriptor","BUFFER","copy","Error","getLenRef","fstatSync","openSlpFile","input","filePath","fd","openSync","getRef","rawDataPosition","getRawDataPosition","rawDataLength","fileSize","rawDataLen","getRawDataLength","metadataPosition","metadataLength","getMetadataLength","messageSizes","MESSAGE_SIZES","payloadLength","messageSizesBuffer","getMessageSizes","closeSlpFile","file","closeSync","parseMessage","command","view","DataView","GAME_START","getPlayerObject","cfOffset","dashback","readUint32","cfOption","nametagStart","nametagBuf","nameTagString","iconv","split","shift","nametag","displayNameStart","displayNameBuf","displayNameString","displayName","connectCodeStart","connectCodeBuf","connectCodeString","connectCode","port","characterId","readUint8","startStocks","controllerFix","slpVersion","readBool","isPAL","readUint16","scene","gameMode","PRE_FRAME_UPDATE","readInt32","isFollower","seed","readFloat","positionY","trigger","POST_FRAME_UPDATE","selfInducedSpeeds","airX","attackX","attackY","groundX","internalCharacterId","shieldSize","currentComboCount","miscActionState","isAirborne","lastGroundId","jumpsRemaining","hurtboxCollisionState","ITEM_UPDATE","typeId","velocityX","velocityY","damageTaken","expirationTimer","spawnId","missileType","turnipFace","chargeShotLaunched","chargePower","owner","readInt8","FRAME_BOOKEND","latestFinalizedFrame","GAME_END","gameEndMethod","lrasInitiatorIndex","canReadFromView","getFloat32","getInt32","getInt8","getUint32","getUint16","getUint8","defaultSettings","suppressErrors","mode","AUTO","SlpStreamEvent","SlpStream","Writable","slpOptions","opts","gameEnded","payloadSizes","previousBuffer","restart","_write","newData","encoding","callback","dataView","index","toString","payloadSize","MANUAL","payloadPtr","payloadDataView","payloadLen","_processCommand","err","_writeCommand","entirePayload","payloadBuf","bufToWrite","RAW","processReceiveCommands","COMMAND","parsedPayload","commandByte","SlpFile","slpStream","fileStream","usesExternalStream","consoleNickname","startTime","moment","lastFrame","Boolean","_setupListeners","_initializeNewGame","path","setMetadata","chunk","write","_onCommand","characterUsage","names","netplay","code","prevPlayer","curCharFrames","streamListener","on","writeSync","createUInt32Buffer","removeListener","end","createWriteStream","header","_final","footer","startTimeStr","toISOString","createInt32Buffer","usage","internalId","number","alloc","writeInt32BE","outputFiles","folderPath","newFilename","folder","m","join","format","SlpFileWriterEvent","SlpParserEvent","RollbackCounter","rollbackFrames","rollbackFrameCount","rollbackPlayerIdx","lastFrameWasRollback","currentRollbackLength","rollbackLengths","checkIfRollbackFrame","currentFrame","playerIdx","getFrames","getCount","getLengths","defaultSlpParserOptions","strict","SlpParser","rollbackCounter","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","handleCommand","_handleGameStart","_handlePostFrameUpdate","_handleFrameUpdate","_handleItemUpdate","_handleFrameBookend","_handleGameEnd","reset","getLatestFrameNumber","getPlayableFrameCount","getLatestFrame","frameIndex","getSettings","getGameEnd","getRollbackFrames","lengths","getFrame","num","_finalizeFrames","END","semver","gte","_completeSettings","playersByIndex","location","ROLLBACK_FRAME","lte","FRAME","items","_this$frames$currentF2","ONLINE","frameToFinalize","playerFrameInfo","FINALIZED_FRAME","SETTINGS","ipAddress","connectionStatus","DISCONNECTED","connDetails","client","connection","shouldReconnect","DEFAULT","getStatus","getDetails","connect","ip","timeout","_connectOnPort","reconnect","inject","net","host","_setStatus","CONNECTING","consoleComms","initialDelay","maxDelay","strategy","failAfter","Infinity","CONNECT","commState","INITIAL","_getInitialCommState","console","log","CONNECTED","LEGACY","_handleReplayData","error","prevDataBuf","rcvData","destroy","ERROR","_processMessage","warn","handshakeMsgOut","setConnectingStatus","RECONNECT_WAIT","disconnect","openingBytes","equals","NORMAL","MESSAGE","KEEP_ALIVE","fakeKeepAlive","REPLAY","readPos","pos","cmp","compare","forcePos","nextPos","nick","nintendontVersion","tokenBuf","DATA","status","STATUS_CHANGE","gameCursor","nickname","peer","enet","Promise","createClient","peers","channels","address","newPeer","ping","packet","Packet","JSON","stringify","PACKET_FLAG","RELIABLE","send","dataString","parse","dolphin_closed","CONNECT_REPLY","GAME_EVENT","_updateCursor","gameData","START_GAME","END_GAME","next_cursor","finalStats","parser","readPosition","actionsComputer","conversionComputer","comboComputer","stockComputer","inputComputer","statsComputer","ArrayBuffer","_process","settingsOnly","slpfile","slpFile","startPos","stopReadingAt","commandPayloadBuffers","commandByteBuffer","undefined","iterateEvents","getStats","overall","stats","actionCounts","gameComplete","getMetadata","ex","getFilePath","currentFile","_writePayload","_handleNewGame","_handleEndGame","getCurrentFilename","resolve","endCurrentFile","updateSettings","NEW_FILE","FILE_COMPLETE"],"mappings":"6oBAAYA,EAoCAC,mDApCAD,0BAAAA,EAAAA,oBAAAA,4DAEVA,iCACAA,iBACAA,uCACAA,qBACAA,uBACAA,mBACAA,qBACAA,qBACAA,qBACAA,wBACAA,oBACAA,sBACAA,0BACAA,oCACAA,gCACAA,sBACAA,sBACAA,sBACAA,sBACAA,sBACAA,gCACAA,4BACAA,kBACAA,sBACAA,8BACAA,kCACAA,wCACAA,4CACAA,kCACAA,gCACAA,0BACAA,oBAGUC,sBAAAA,EAAAA,gBAAAA,gEAEVA,yCACAA,qCACAA,mCACAA,2BACAA,2BACAA,mCACAA,qBACAA,8BACAA,wCACAA,oCACAA,8BACAA,sCACAA,0CACAA,sCACAA,oCACAA,4BACAA,4CACAA,gDACAA,sBACAA,kCACAA,4BACAA,0CACAA,wBACAA,8BACAA,8BACAA,8CACAA,4CACAA,kCACAA,8CACAA,8CACAA,gEACAA,wDACAA,0DACAA,oDACAA,8CACAA,0CACAA,4DACAA,8CACAA,gDACAA,4CACAA,8CACAA,8CACAA,gDACAA,4CACAA,8CACAA,8CACAA,kDACAA,wDACAA,8CACAA,8CACAA,8CACAA,8CACAA,gEACAA,0CACAA,sDACAA,4CC1FF,MASaC,EAAkC,CAC7CC,IAAK,EACLC,KAAM,oBACNC,UAAW,UACXC,OAAQ,CAb4B,YAgBhCC,EAAsC,CAC1C,CACEJ,GAAIH,kBAAUQ,eACdJ,KAAM,iBACNC,UAAW,SACXC,OAAQ,CArB0B,UAqBV,QAAS,MAAO,QAAS,QAAS,SAE5D,CACEH,GAAIH,kBAAUS,YACdL,KAAM,cACNC,UAAW,KACXC,OAAQ,CA3B0B,UA2BV,QAAS,MAAO,OAAQ,UAElD,CACEH,GAAIH,kBAAUU,IACdN,KAAM,MACNC,UAAW,MACXC,OAAQ,CAjC0B,UAiCV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,kBAAUW,eACdP,KAAM,mBACNC,UAAW,MACXC,OAAQ,CAvC0B,UAuCV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,kBAAUY,MACdR,KAAM,QACNC,UAAW,QACXC,OAAQ,CA7C0B,UA6CV,SAAU,OAAQ,MAAO,QAAS,UAE5D,CACEH,GAAIH,kBAAUa,OACdT,KAAM,SACNC,UAAW,SACXC,OAAQ,CAnD0B,UAmDV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,kBAAUc,KACdV,KAAM,OACNC,UAAW,OACXC,OAAQ,CAzD0B,UAyDV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,kBAAUe,MACdX,KAAM,QACNC,UAAW,QACXC,OAAQ,CA/D0B,UA+DV,QAAS,OAAQ,QAE3C,CACEH,GAAIH,kBAAUgB,MACdZ,KAAM,QACNC,UAAW,QACXC,OAAQ,CArE0B,UAqEV,SAAU,QAAS,OAAQ,UAErD,CACEH,GAAIH,kBAAUiB,MACdb,KAAM,QACNC,UAAW,QACXC,OAAQ,CA3E0B,UA2EV,MAAO,QAAS,QAAS,UAEnD,CACEH,GAAIH,kBAAUkB,OACdd,KAAM,SACNC,UAAW,SACXC,OAAQ,CAjF0B,UAiFV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,kBAAUmB,KACdf,KAAM,OACNC,UAAW,OACXC,OAAQ,CAvF0B,UAuFV,SAAU,OAAQ,UAE5C,CACEH,GAAIH,kBAAUoB,MACdhB,KAAM,QACNC,UAAW,QACXC,OAAQ,CA7F0B,UA6FV,QAAS,QAAS,OAAQ,UAEpD,CACEH,GAAIH,kBAAUqB,QACdjB,KAAM,UACNC,UAAW,UACXC,OAAQ,CAnG0B,UAmGV,MAAO,YAAa,eAE9C,CACEH,GAAIH,kBAAUsB,aACdlB,KAAM,eACNC,UAAW,MACXC,OAAQ,CAzG0B,UAyGV,QAAS,SAAU,QAE7C,CACEH,GAAIH,kBAAUuB,WACdnB,KAAM,aACNC,UAAW,OACXC,OAAQ,CA/G0B,UA+GV,MAAO,OAAQ,WAAY,UAErD,CACEH,GAAIH,kBAAUwB,MACdpB,KAAM,QACNC,UAAW,QACXC,OAAQ,CArH0B,UAqHV,OAAQ,QAAS,QAAS,WAEpD,CACEH,GAAIH,kBAAUyB,MACdrB,KAAM,QACNC,UAAW,QACXC,OAAQ,CA3H0B,UA2HV,MAAO,OAAQ,SAAU,OAAQ,SAE3D,CACEH,GAAIH,kBAAU0B,MACdtB,KAAM,QACNC,UAAW,QACXC,OAAQ,CAjI0B,UAiIV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,kBAAU2B,MACdvB,KAAM,QACNC,UAAW,QACXC,OAAQ,CAvI0B,UAuIV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,kBAAU4B,MACdxB,KAAM,QACNC,UAAW,QACXC,OAAQ,CA7I0B,UA6IV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,kBAAU6B,WACdzB,KAAM,aACNC,UAAW,QACXC,OAAQ,CAnJ0B,UAmJV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,kBAAU8B,SACd1B,KAAM,YACNC,UAAW,MACXC,OAAQ,CAzJ0B,UAyJV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,kBAAU+B,IACd3B,KAAM,MACNC,UAAW,MACXC,OAAQ,CA/J0B,UA+JV,MAAO,OAAQ,QAAS,WAElD,CACEH,GAAIH,kBAAUgC,MACd5B,KAAM,QACNC,UAAW,QACXC,OAAQ,CArK0B,UAqKV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,kBAAUiC,UACd7B,KAAM,YACNC,UAAW,QACXC,OAAQ,CA3K0B,UA2KV,MAAO,OAAQ,QAAS,qBAQpC4B,EAAiBC,UACd5B,EAAmB4B,IAI7BjC,8EARAK,qDAW6B4B,UAClBD,EAAiBC,GAClB9B,qCAGc8B,UACbD,EAAiBC,GAClB/B,qCAImB+B,EAA6BC,UAC/CF,EAAiBC,GACX7B,OAAO8B,IAxMK,YCG/B,MAAMC,EAAoB,CAC/BlC,IAAK,EACLC,KAAM,eACNC,UAAW,WAGPiC,EAAgC,GACjC,CAEDnC,GAAI,EACJC,KAAM,gBACNC,UAAW,UAEV,CACDF,GAAI,EACJC,KAAM,MACNC,UAAW,SAEV,CACDF,GAAI,EACJC,KAAM,MACNC,UAAW,SAEV,CACDF,GAAI,EACJC,KAAM,MACNC,UAAW,SAEV,CACDF,GAAI,EACJC,KAAM,aACNC,UAAW,gBAEV,CACDF,GAAI,EACJC,KAAM,cACNC,UAAW,UAEV,CACDF,GAAI,EACJC,KAAM,eACNC,UAAW,WAEV,CACDF,GAAI,EACJC,KAAM,UACNC,UAAW,WAEV,CACDF,GAAI,EACJC,KAAM,YACNC,UAAW,YAET,CACFF,GAAI,GACJC,KAAM,gBACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,aACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,WAET,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,WAET,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,WAET,CACFF,GAAI,GACJC,KAAM,SACNC,UAAW,WAET,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,WAET,CACFF,GAAI,GACJC,KAAM,YACNC,UAAW,gBAET,CACFF,GAAI,GACJC,KAAM,SACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,OACNC,UAAW,WAET,CACFF,GAAI,GACJC,KAAM,SACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,eACNC,UAAW,YAET,CACFF,GAAI,GACJC,KAAM,sBACNC,UAAW,iBAET,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,gBACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,aACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,aACNC,UAAW,aAET,CACFF,GAAI,GACJC,KAAM,qBACNC,UAAW,gBAET,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,kBAICkC,EAAYC,UAChBF,EAAME,IAEPH,8EAKsBG,UAClBD,EAAYC,GACbnC,gCAGcmC,UACbD,EAAYC,GACbpC,OC9KP,MAAMqC,EAA0B,CACrCtC,IAAK,EACLC,KAAM,iBAGFsC,EAAsC,EACzCzC,cAAM0C,oBAAqB,CAC1BxC,GAAIF,cAAM0C,mBACVvC,KAAM,uBAEPH,cAAM2C,iBAAkB,CACvBzC,GAAIF,cAAM2C,gBACVxC,KAAM,oBAEPH,cAAM4C,eAAgB,CACrB1C,GAAIF,cAAM4C,cACVzC,KAAM,4BAEPH,cAAM6C,cAAe,CACpB3C,GAAIF,cAAM6C,aACV1C,KAAM,iBAEPH,cAAM8C,UAAW,CAChB5C,GAAIF,cAAM8C,SACV3C,KAAM,aAEPH,cAAM+C,UAAW,CAChB7C,GAAIF,cAAM+C,SACV5C,KAAM,aAEPH,cAAMgD,cAAe,CACpB9C,GAAIF,cAAMgD,aACV7C,KAAM,kBAEPH,cAAMiD,OAAQ,CACb/C,GAAIF,cAAMiD,MACV9C,KAAM,UAEPH,cAAMkD,WAAY,CACjBhD,GAAIF,cAAMkD,UACV/C,KAAM,cAEPH,cAAMmD,gBAAiB,CACtBjD,GAAIF,cAAMmD,eACVhD,KAAM,mBAEPH,cAAMoD,cAAe,CACpBlD,GAAIF,cAAMoD,aACVjD,KAAM,iBAEPH,cAAMqD,WAAY,CACjBnD,GAAIF,cAAMqD,UACVlD,KAAM,cAEPH,cAAMsD,eAAgB,CACrBpD,GAAIF,cAAMsD,cACVnD,KAAM,kBAEPH,cAAMuD,iBAAkB,CACvBrD,GAAIF,cAAMuD,gBACVpD,KAAM,oBAEPH,cAAMwD,eAAgB,CACrBtD,GAAIF,cAAMwD,cACVrD,KAAM,mBAEPH,cAAMyD,cAAe,CACpBvD,GAAIF,cAAMyD,aACVtD,KAAM,iBAEPH,cAAM0D,UAAW,CAChBxD,GAAIF,cAAM0D,SACVvD,KAAM,aAEPH,cAAM2D,kBAAmB,CACxBzD,GAAIF,cAAM2D,iBACVxD,KAAM,uBAEPH,cAAM4D,oBAAqB,CAC1B1D,GAAIF,cAAM4D,mBACVzD,KAAM,wBAEPH,cAAM6D,OAAQ,CACb3D,GAAIF,cAAM6D,MACV1D,KAAM,UAEPH,cAAM8D,aAAc,CACnB5D,GAAIF,cAAM8D,YACV3D,KAAM,gBAEPH,cAAM+D,UAAW,CAChB7D,GAAIF,cAAM+D,SACV5D,KAAM,aAEPH,cAAMgE,iBAAkB,CACvB9D,GAAIF,cAAMgE,gBACV7D,KAAM,oBAEPH,cAAMiE,QAAS,CACd/D,GAAIF,cAAMiE,OACV9D,KAAM,WAEPH,cAAMkE,WAAY,CACjBhE,GAAIF,cAAMkE,UACV/D,KAAM,cAEPH,cAAMmE,WAAY,CACjBjE,GAAIF,cAAMmE,UACVhE,KAAM,mBAEPH,cAAMoE,mBAAoB,CACzBlE,GAAIF,cAAMoE,kBACVjE,KAAM,uBAEPH,cAAMqE,kBAAmB,CACxBnE,GAAIF,cAAMqE,iBACVlE,KAAM,qBAEPH,cAAMsE,aAAc,CACnBpE,GAAIF,cAAMsE,YACVnE,KAAM,gBAEPH,cAAMuE,mBAAoB,CACzBrE,GAAIF,cAAMuE,kBACVpE,KAAM,sBAEPH,cAAMwE,mBAAoB,CACzBtE,GAAIF,cAAMwE,kBACVrE,KAAM,wBAEPH,cAAMyE,4BAA6B,CAClCvE,GAAIF,cAAMyE,2BACVtE,KAAM,iCAEPH,cAAM0E,wBAAyB,CAC9BxE,GAAIF,cAAM0E,uBACVvE,KAAM,6BAEPH,cAAM2E,yBAA0B,CAC/BzE,GAAIF,cAAM2E,wBACVxE,KAAM,8BAEPH,cAAM4E,sBAAuB,CAC5B1E,GAAIF,cAAM4E,qBACVzE,KAAM,4BAEPH,cAAM6E,mBAAoB,CACzB3E,GAAIF,cAAM6E,kBACV1E,KAAM,wBAEPH,cAAM8E,iBAAkB,CACvB5E,GAAIF,cAAM8E,gBACV3E,KAAM,sBAEPH,cAAM+E,0BAA2B,CAChC7E,GAAIF,cAAM+E,yBACV5E,KAAM,+BAEPH,cAAMgF,mBAAoB,CACzB9E,GAAIF,cAAMgF,kBACV7E,KAAM,wBAEPH,cAAMiF,oBAAqB,CAC1B/E,GAAIF,cAAMiF,mBACV9E,KAAM,yBAEPH,cAAMkF,kBAAmB,CACxBhF,GAAIF,cAAMkF,iBACV/E,KAAM,uBAEPH,cAAMmF,mBAAoB,CACzBjF,GAAIF,cAAMmF,kBACVhF,KAAM,wBAEPH,cAAMoF,mBAAoB,CACzBlF,GAAIF,cAAMoF,kBACVjF,KAAM,wBAEPH,cAAMqF,oBAAqB,CAC1BnF,GAAIF,cAAMqF,mBACVlF,KAAM,yBAEPH,cAAMsF,kBAAmB,CACxBpF,GAAIF,cAAMsF,iBACVnF,KAAM,uBAEPH,cAAMuF,mBAAoB,CACzBrF,GAAIF,cAAMuF,kBACVpF,KAAM,wBAEPH,cAAMwF,mBAAoB,CACzBtF,GAAIF,cAAMwF,kBACVrF,KAAM,wBAEPH,cAAMyF,qBAAsB,CAC3BvF,GAAIF,cAAMyF,oBACVtF,KAAM,0BAEPH,cAAM0F,wBAAyB,CAC9BxF,GAAIF,cAAM0F,uBACVvF,KAAM,6BAEPH,cAAM2F,mBAAoB,CACzBzF,GAAIF,cAAM2F,kBACVxF,KAAM,wBAEPH,cAAM4F,mBAAoB,CACzB1F,GAAIF,cAAM4F,kBACVzF,KAAM,wBAEPH,cAAM6F,mBAAoB,CACzB3F,GAAIF,cAAM6F,kBACV1F,KAAM,wBAEPH,cAAM8F,mBAAoB,CACzB5F,GAAIF,cAAM8F,kBACV3F,KAAM,wBAEPH,cAAM+F,4BAA6B,CAClC7F,GAAIF,cAAM+F,2BACV5F,KAAM,mCAEPH,cAAMgG,iBAAkB,CACvB9F,GAAIF,cAAMgG,gBACV7F,KAAM,sBAEPH,cAAMiG,uBAAwB,CAC7B/F,GAAIF,cAAMiG,sBACV9F,KAAM,4BAEPH,cAAMkG,kBAAmB,CACxBhG,GAAIF,cAAMkG,iBACV/F,KAAM,8BAIMgG,EAAaC,UACjB3D,EAAO2D,IAER5D,MC9HC6D,wEDmIiBD,UACbD,EAAaC,GACdjG,OCrIHkG,sBAAAA,EAAAA,gBAAAA,qDAGVA,gCACAA,uCACAA,mCACAA,mCACAA,+BACAA,wDACAA,oDACAA,kCACAA,8BACAA,iCACAA,6BACAA,iCACAA,6BACAA,iCACAA,8BACAA,sDACAA,kDACAA,kDACAA,8CACAA,kDACAA,8CAGAA,qCACAA,uCACAA,iCACAA,+BACAA,kCACAA,kCACAA,4CACAA,6BACAA,qCACAA,yCACAA,qCACAA,qCACAA,uCACAA,+BACAA,6CACAA,oBACAA,oBACAA,oDACAA,oCACAA,sCACAA,oCACAA,sCACAA,qBACAA,+BACAA,yBACAA,mCACAA,6BACAA,uCACAA,iCACAA,iCACAA,kCAGAA,mCACAA,+DACAA,2DAEAA,+DACAA,iEAGWC,EAAS,CACpBC,oBAAqB,GACrBC,sBAAuB,GACvBC,0BAA2B,aAGbC,EAAyCC,UAClDA,GAAwC,IAA5BA,EAASC,QAAQC,OAK3B,CACL,CACEC,YAAaH,EAASC,QAAQ,GAAIE,YAClCC,cAAeJ,EAASC,QAAQ,GAAIE,aAEtC,CACEA,YAAaH,EAASC,QAAQ,GAAIE,YAClCC,cAAeJ,EAASC,QAAQ,GAAIE,cAV/B,YAeKE,EAAaC,EAA4BC,YAClDD,IAAUC,IAIRA,EAAUC,gBAAmBF,EAAME,gBAAmB,WAG/CC,EAAYC,SACpBC,EAASD,GAAShB,cAAMkB,wBAA0BF,GAAShB,cAAMmB,qBACjEC,EAAQJ,GAAShB,cAAMqB,aAAeL,GAAShB,cAAMsB,UACrDC,EAAeP,EAAQhB,cAAMwB,qBAAuBR,GAAShB,cAAMyB,kBACnEC,EAASV,IAAUhB,cAAM2B,YAExBV,GAAUG,GAASG,GAAgBG,WAG5BE,EAAUZ,UACjBA,GAAShB,cAAM6B,YAAcb,GAAShB,cAAM8B,kBAGrCC,EAAOf,UACdA,GAAShB,cAAMgC,YAAchB,GAAShB,cAAMiC,kBAGrCC,EAAUlB,UAChBA,GAAShB,cAAMmC,cAAgBnB,GAAShB,cAAMoC,YAAepB,IAAUhB,cAAMqC,qBAGvEC,EAAUtB,UACjBA,GAAShB,cAAMuC,eAAiBvB,GAAShB,cAAMwC,qBAIxCC,EAAiBzB,UAE3BA,GAAShB,cAAM0C,2BAA6B1B,GAAShB,cAAM2C,yBAC1D3B,GAAShB,cAAM4C,2BAA6B5B,GAAShB,cAAM6C,0BAC9D7B,IAAUhB,cAAM8C,qBAIJC,EAAO/B,UACdA,GAAShB,cAAMgD,aAAehC,GAAShB,cAAMiD,mBAGtCC,EAAgBtC,EAA4BC,2BAC1CD,EAAMuC,WAAW,aACbtC,EAAUsC,WAAW,GC3P3C,MAAMC,EAAsB,CAACpD,cAAMqD,KAAMrD,cAAMsD,KAAMtD,cAAMqD,YAO9CE,qBACHC,mBAAqB,IAAIC,WACzBzC,MAAQ,IAAI0C,IAEbC,MAAMrD,QACNU,MAAQ,IAAI0C,SACZF,mBAAqBnD,EAAyCC,QAC9DkD,mBAAmBI,SAASC,SAwC1B7C,MAAM8C,IAAID,EAJwB,CACrCE,aApCqC,CACrCtD,YAAaoD,EAAQpD,YACrBuD,cAAe,EACfC,cAAe,EACfC,cAAe,EACfC,eAAgB,EAChBC,eAAgB,EAChBC,eAAgB,EAChBC,UAAW,EACXC,aAAc,CACZC,QAAS,EACTC,KAAM,GAERC,UAAW,CACTF,QAAS,EACTC,KAAM,GAERE,WAAY,CACVC,GAAI,EACJC,QAAS,EACTC,KAAM,EACNC,KAAM,GAERC,gBAAiB,CAEfC,KAAM,EACNC,GAAI,EACJC,QAAS,EACTV,KAAM,GAERW,cAAe,CACbZ,QAAS,EACTC,KAAM,IAKRY,WAAY,QAMXC,aAAa1E,QACb4C,mBAAmBI,SAASC,UACzB7C,EAAQuE,KAAKvE,MAAMwE,IAAI3B,GACzB7C,GAsEV,SAA6BA,EAA0B6C,EAA4BjD,SAC3E6E,EAAc7E,EAAML,QAAQsD,EAAQpD,aAAciF,KAClDC,EAAgB/E,EAAML,QAAQsD,EAAQnD,eAAgBgF,KACtDE,EAAiB,CAACC,EAAeC,SAChCA,eAICC,EAAkBP,MAAIxE,EAAM+C,aAAc8B,EAAO,GACvD/B,MAAI9C,EAAM+C,aAAc8B,EAAOE,EAAU,IAIrCC,EAAmBP,EAAYQ,cACrCjF,EAAMqE,WAAWa,KAAKF,SAGhBG,EAAcnF,EAAMqE,WAAWe,OAAO,GACtCC,EAAgBF,EAAYA,EAAY3F,OAAS,GACjD8F,EAAeN,IAAqBK,EAI1CT,EAAe,iBADMW,UAAQJ,EAAa/C,UAGpCoD,EA5ER,SAAsBR,EAA0BS,SACxCC,EAAqBC,EAAUX,GAC/BY,EAAuBD,EAAUF,UAEhCC,IAAuBE,EAwEdC,CAAab,EAAkBK,GAC/CT,EAAe,YAAaY,SAEtBM,EA7DR,SAA2Bd,EAAyBS,SAC5CM,EAAqBC,EAAchB,GACnCiB,EAAuBD,EAAcP,UAEpCM,IAAuBE,EAyDTC,CAAkBlB,EAAkBK,GACzDT,EAAe,iBAAkBkB,SAE3BK,EArDR,SAA0BnB,EAAyBS,SAC3CM,EAAqBK,EAAapB,GAClCiB,EAAuBG,EAAaX,UAEnCM,IAAuBE,EAiDVI,CAAiBrB,EAAkBK,GACvDT,EAAe,gBAAiBuB,SAE1BG,EAzCR,SAA2BtB,EAAyBS,SAC5Cc,EAA2BC,EAAgBxB,GAC3CyB,EAA6BD,EAAgBf,UAE5Cc,IAA6BE,EAqCfC,CAAkB1B,EAAkBK,GACzDT,EAAe,iBAAkB0B,SAE3BK,EA7ER,SAA6B3B,EAAyBS,UAC7CA,IAAsBzG,cAAM2B,MAAQqE,GAAoBhG,cAAM4H,WAAa5B,EAAmBhG,cAAM2B,KA4EpFkG,CAAoB7B,EAAkBK,GAC7DT,EAAe,oBAAqB+B,SAC9BG,EA5ER,SAA0B9B,EAAyBS,UAC1CA,IAAsBzG,cAAM2B,OAASqE,EAAmBhG,cAAM4H,WAAa5B,EAAmBhG,cAAM2B,MA2EvFoG,CAAiB/B,EAAkBK,MACvDT,EAAe,iBAAkBkC,GAEjClC,EAAe,gBAAiBI,IAAqBhG,cAAMgI,UAAY1B,GACvEV,EAAe,qBAAsBI,IAAqBhG,cAAMiI,eAAiB3B,GACjFV,EAAe,kBAAmBI,IAAqBhG,cAAMkI,YAAc5B,GAC3EV,EAAe,kBAAmBI,IAAqBhG,cAAMmI,YAAc7B,GAEvEA,EAAc,CAEhBV,EAAe,wBA5GQwC,EA2GepC,KA1GnBhG,cAAMqI,gBAAkBD,IAAcpI,cAAMsI,kBA4G3DC,EAAc,EACdC,GAAiB,EAEjB/C,EAAYgD,UAAa9C,EAAc8C,YACzCF,GAAe,GAEb9C,EAAYiD,iBAAmBH,IACjCC,GAAiB,GAGnB5C,EAAe,qBAAsBI,IAAqBhG,cAAM2I,cAAgBH,GAChF5C,EAAe,qBAAsBI,IAAqBhG,cAAM4I,gBAAkBJ,GAClF5C,EAAe,0BAA2BI,IAAqBhG,cAAM6I,cACrEjD,EAAe,uBAAwBI,IAAqBhG,cAAM4I,eAAiBJ,GACnF5C,EAAe,uBAAwBI,IAAqBhG,cAAM2I,eAAiBH,GAEnF5C,EAAe,wBAAyBI,IAAqBhG,cAAM8I,WACnElD,EAAe,qBAAsBI,IAAqBhG,cAAM+I,kBA9HpE,IAA2BX,GAgD3B,SAAwBA,UACfA,GAAapI,cAAMgJ,qBAAuBZ,GAAapI,cAAMiJ,mBAgFhEC,CAAelD,KACjBJ,EAAe,uBAAsD,IAA9BH,EAAY0D,eACnDvD,EAAe,oBAAmD,IAA9BH,EAAY0D,gBAOpD,SAA8BC,EAA0B/D,SAIhDgE,EAHmBC,OAAKjE,KAGgBrF,cAAMuJ,qBAC9CC,EAkCR,SAAuCpB,MACjCA,IAAcpI,cAAMyJ,iBACf,QAGHC,EAAatB,GAAapI,cAAM2J,sBAChCC,EAAaxB,GAAapI,cAAM6J,2BAC/BH,GAAcE,EAzCQE,CAHPzE,EAAWA,EAAW7E,OAAS,QAI1B6I,IAAoBG,eASzCO,EAAe1E,EAAWe,OAAO,GACjC4D,EAAmBC,QAAMF,GAAe3B,GAAcA,IAE7B,IAA3B8B,OAAKF,IAA2BA,EAAiBhK,cAAMyJ,aAMvDO,EAAiBhK,cAAMyJ,aAGzBL,EAAOlF,eAAiB,GAGtB8F,EAAiBhK,cAAMmK,kBAEzBf,EAAOpF,eAAiB,EAGxBoF,EAAOnF,eAAiB,GAtC1BmG,CAAqBpJ,EAAM+C,aAAc/C,EAAMqE,YAjJzCgF,CAAoBrJ,EAAO6C,EAASjD,MAKnC0J,eACE7G,MAAM8G,KAAKhF,KAAKvE,MAAMwJ,UAAUC,KAAKC,GAAQA,EAAI3G,gBAQ5D,SAAS4C,EAAUyB,UACVA,IAAcpI,cAAM2K,eAAiBvC,IAAcpI,cAAM4K,aAUlE,SAAS5D,EAAcoB,UACdA,IAAcpI,cAAM6K,WAiB7B,SAASzD,EAAagB,UACbA,IAAcpI,cAAMyJ,UAU7B,SAASjC,EAAgBY,UAChBA,IAAcpI,cAAM8K,YC1G7B,IAAYC,ECnBAC,EAwBAC,GA+IAC,GCjKPC,IFaL,SAAYJ,GACVA,4BACAA,8BACAA,wBAHF,CAAYA,IAAAA,aAcCK,WAAsBC,kDACzB7H,mBAAqB,IAAIC,WACzBzC,MAAQ,IAAI0C,SACZ4H,OAAS,IAAI7H,WACbnD,SAAiC,KAElCqD,MAAMrD,QAENA,SAAWA,OACXU,MAAQ,IAAI0C,SACZ4H,OAAS,QACT9H,mBAAqBnD,EAAyCC,QAE9DkD,mBAAmBI,SAASC,SAQ1B7C,MAAM8C,IAAID,EAPiB,CAC9B0H,MAAO,KACPC,KAAM,KACNC,aAAc,EACdC,iBAAkB,KAClBC,MAAO,UAMNrG,aAAa1E,EAAuBgL,QACpCpI,mBAAmBI,SAASC,UACzB7C,EAAQuE,KAAKvE,MAAMwE,IAAI3B,GACzB7C,IAoBV,SACE6K,EACA7K,EACA6C,EACAjD,EACA0K,SAEMQ,EAAqBlL,EAAMA,MAC3B6E,EAAc7E,EAAML,QAAQsD,EAAQpD,aAAciF,KAClDC,EAAgB/E,EAAML,QAAQsD,EAAQnD,eAAgBgF,KAEtDqG,EAAkBD,EAAqB,MACzCE,EAA8C,KAC9CC,EAAgD,KAEhDJ,EAAOE,KACTC,EAAkBH,EAAOE,GAAkBxL,QAAQsD,EAAQpD,aAAciF,KACzEuG,EAAoBJ,EAAOE,GAAkBxL,QAAQsD,EAAQnD,eAAgBgF,YAGzEwG,EAAmBvG,EAAcM,cACjCkG,EAAgBjK,EAAUgK,GAC1BE,EAAgB9J,EAAU4J,GAC1BG,EAAuB5J,EAAiByJ,GACxCI,EAAkBL,EAAoB/I,EAAgByC,EAAesG,GAAqB,MAQlExG,EAAYQ,gBAAkBjF,EAAM0K,kBAC5CjG,EAAY8G,oBACRP,EAAkBA,EAAgBO,mBAAsB,MAGhFvL,EAAM0K,iBAAmB,MAKvBS,GAAiBC,GAAiBC,EAAsB,KACtDG,GAAe,UACdxL,EAAMuK,QACTvK,EAAMuK,MAAQ,CACZ9K,YAAaoD,EAAQnD,cACrB+L,WAAYX,EACZY,SAAU,KACVC,aAAcV,YAAoBA,EAAkB9I,WAAe,EACnEyJ,wBAAgBjH,EAAcxC,WAAW,EACzC0J,WAAY,KACZ7Q,MAAO,GACP8Q,SAAS,EACTC,UAAWlJ,EAAQpD,aAGrB6K,EAAOpF,KAAKlF,EAAMuK,OAGlBiB,GAAe,GAGbF,IAG6B,OAA3BtL,EAAM0K,mBACR1K,EAAMwK,KAAO,CACX/K,YAAaoD,EAAQpD,YACrBG,MAAOkL,EACP5P,OAAQuJ,EAAYuH,iBACpBC,SAAU,EACVC,OAAQ,GAGVlM,EAAMuK,MAAMvP,MAAMkK,KAAKlF,EAAMwK,MAGxBgB,IACHxL,EAAM2K,MAAQZ,EAAWoC,eAIzBnM,EAAMwK,OACRxK,EAAMwK,KAAKyB,UAAY,EACvBjM,EAAMwK,KAAK0B,QAAUZ,GAKvBtL,EAAM0K,iBAAmBM,EAAkBA,EAAgB/F,cAAgB,MAGzEuG,IACFxL,EAAM2K,MAAQZ,EAAWqC,iBAIxBpM,EAAMuK,mBAML8B,EAAgBzL,EAAUsK,GAC1BoB,EAAevL,EAAOmK,GACtBqB,EAAmBtB,GAAqBtL,EAAagF,EAAesG,GACpEuB,EAAczK,EAAOmJ,SAGtBqB,IACHvM,EAAMuK,MAAMqB,wBAAiBjH,EAAcxC,WAAW,GAGpDgJ,GAAiBC,GAAiBC,GAAwBgB,GAAiBC,GAAgBE,EAE7FxM,EAAMyK,aAAe,EAErBzK,EAAMyK,cAAgB,MAGpBgC,GAAkB,QAGlBF,IACFvM,EAAMuK,MAAMuB,SAAU,EACtBW,GAAkB,GAIhBzM,EAAMyK,aAAexL,EAAOG,4BAC9BqN,GAAkB,GAIhBA,IACFzM,EAAMuK,MAAMmB,SAAWjH,EAAY7E,MACnCI,EAAMuK,MAAMsB,WAAaZ,YAAoBA,EAAkB9I,WAAe,EAC9EnC,EAAM2K,MAAQZ,EAAW2C,UAEzB1M,EAAMuK,MAAQ,KACdvK,EAAMwK,KAAO,MAhKTmC,CAAmB/B,EAAW5K,EAAO6C,EAASjD,EAAO2E,KAAK+F,QAGtC,OAAhBtK,EAAM2K,aACHiC,KAAK5M,EAAM2K,MAAO,CACrBJ,MAAOjC,OAAK/D,KAAK+F,QACjBhL,SAAUiF,KAAKjF,WAEjBU,EAAM2K,MAAQ,UAMfrB,eACE/E,KAAK+F,cG/CHuC,WAA2BxC,eAOtCyC,2BANQtK,mBAAqB,IAAIC,WACzBsK,YAAc,IAAItK,WAClBzC,MAAQ,IAAI0C,SACZsK,qBACA1N,SAAiC,UAIlC0N,SAAW,CACdC,qBAAsB,IAInBtK,MAAMrD,QAENkD,mBAAqBnD,EAAyCC,QAC9DyN,YAAc,QACd/M,MAAQ,IAAI0C,SACZsK,SAAW,CACdC,qBAAsB,SAEnB3N,SAAWA,OAEXkD,mBAAmBI,SAASC,SAO1B7C,MAAM8C,IAAID,EAN4B,CACzCqK,WAAY,KACZ1C,KAAM,KACNC,aAAc,EACdC,iBAAkB,UAMjBpG,aAAa1E,EAAuBgL,QACpCpI,mBAAmBI,SAASC,UACzB7C,EAAQuE,KAAKvE,MAAMwE,IAAI3B,MACzB7C,EAAO,OACHmN,EAkDd,SACEtC,EACA7K,EACA6C,EACAjD,EACAmN,SAEMjC,EAAqBlL,EAAMA,MAC3B6E,EAAmC7E,EAAML,QAAQsD,EAAQpD,aAAciF,KACvEC,EAAgB/E,EAAML,QAAQsD,EAAQnD,eAAgBgF,KAEtDqG,EAAkBD,EAAqB,MACzCE,EAA8C,KAC9CC,EAAgD,KAEhDJ,EAAOE,KACTC,EAAkBH,EAAOE,GAAkBxL,QAAQsD,EAAQpD,aAAciF,KACzEuG,EAAoBJ,EAAOE,GAAkBxL,QAAQsD,EAAQnD,eAAgBgF,YAGzEwG,EAAmBvG,EAAcM,cACjCkG,EAAgBjK,EAAUgK,GAC1BE,EAAgB9J,EAAU4J,GAC1BG,EAAuB5J,EAAiByJ,GACxCI,EAAkBL,EAAoB/I,EAAgByC,EAAesG,GAAqB,cAQlExG,EAAYQ,gBAAkBjF,EAAM0K,kBAC5CjG,EAAY8G,oBACRP,EAAkBA,EAAgBO,mBAAsB,MAGhFvL,EAAM0K,iBAAmB,OAKvBS,GAAiBC,GAAiBC,KAC/BrL,EAAMkN,aACTlN,EAAMkN,WAAa,CACjBzN,YAAaoD,EAAQnD,cACrBqM,UAAWlJ,EAAQpD,YACnBgM,WAAYX,EACZY,SAAU,KACVC,aAAcV,YAAoBA,EAAkB9I,WAAe,EACnEyJ,wBAAgBjH,EAAcxC,WAAW,EACzC0J,WAAY,KACZ7Q,MAAO,GACP8Q,SAAS,EACTsB,YAAa,WAGfL,EAAY7H,KAAKlF,EAAMkN,aAGrB5B,IAG6B,OAA3BtL,EAAM0K,mBACR1K,EAAMwK,KAAO,CACX/K,YAAaoD,EAAQpD,YACrBG,MAAOkL,EACP5P,OAAQuJ,EAAYuH,iBACpBC,SAAU,EACVC,OAAQ,GAGVlM,EAAMkN,WAAWlS,MAAMkK,KAAKlF,EAAMwK,OAGhCxK,EAAMwK,OACRxK,EAAMwK,KAAKyB,UAAY,EACvBjM,EAAMwK,KAAK0B,QAAUZ,GAKvBtL,EAAM0K,iBAAmBM,EAAkBA,EAAgB/F,cAAgB,QAI1EjF,EAAMkN,kBAGF,QAGHG,EAAgBtN,EAAYmL,GAC5BqB,EAAmBtB,GAAqBtL,EAAagF,EAAesG,SAGrEsB,IACHvM,EAAMkN,WAAWtB,wBAAiBjH,EAAcxC,WAAW,IAGzDgJ,GAAiBC,GAAiBC,KAEpCrL,EAAMyK,aAAe,IAGgC,IAAvBzK,EAAMyK,cAAsB4C,GACzBrN,EAAMyK,aAAe,KAKtDzK,EAAMyK,cAAgB,OAGpBgC,GAAkB,eAGlBF,IACFvM,EAAMkN,WAAWpB,SAAU,EAC3BW,GAAkB,GAIhBzM,EAAMyK,aAAexL,EAAOC,sBAC9BuN,GAAkB,GAIhBA,IACFzM,EAAMkN,WAAWxB,SAAWjH,EAAY7E,MACxCI,EAAMkN,WAAWrB,WAAaZ,YAAoBA,EAAkB9I,WAAe,EAEnFnC,EAAMkN,WAAa,KACnBlN,EAAMwK,KAAO,MAGRiC,EA1LkBa,CAAwB1C,EAAW5K,EAAO6C,EAASjD,EAAO2E,KAAKwI,aAC9EI,QACGP,KAAK,aAAc,CACtBrC,MAAOjC,OAAK/D,KAAKwI,aACjBzN,SAAUiF,KAAKjF,eAOlBgK,oBACAiE,2BACEhJ,KAAKwI,YAGNQ,iCAEAC,EAAsBC,SAAOlJ,KAAKwI,aAAcG,GAClB,YAA3BA,EAAWE,cAIdM,EAAqBC,UAAQH,EAAqB,cAC9BI,UAAQF,GAAqBX,GAAgBvI,MAAIuI,EAAa,CAAC,EAAG,iBAG1EnK,SAASmK,UACnBc,EAAUd,EAAYvN,QAAU,EACtCuN,EAAYnK,SAASsK,YAEdF,SAASC,qBAAqBC,EAAWzN,aAAeyN,EAAWxB,SAEpEmC,cAEFX,EAAWE,YAAc,eAKrBU,EAAWxF,OAAK4E,EAAWlS,OAC3B+S,EACJxJ,KAAKyI,SAASC,qBAAqBa,EAAWA,EAASrO,YAAcyN,EAAWzN,aAElFyN,EAAWE,YADaW,GAAeA,EAAcb,EAAWzB,WACrB,iBAAmB,qBFjH1DzB,wBAAAA,EAAAA,kBAAAA,yDAEVA,gCACAA,4CACAA,8CACAA,4BACAA,kCACAA,sCAiBUC,yBAAAA,GAAAA,mBAAAA,oCAEVA,yBA6IUC,uBAAAA,GAAAA,iBAAAA,2CAEVA,2CCnKF,SAAKC,GACHA,eACAA,eACAA,eACAA,eACAA,eACAA,aACAA,aACAA,aACAA,aATF,CAAKA,KAAAA,cAsBQ6D,sBACHhO,MAAQ,IAAI0C,SACZF,mBAAqB,IAAIC,MAE1BE,MAAMrD,QAENU,MAAQ,IAAI0C,SACZF,mBAAqBnD,EAAyCC,QAE9DkD,mBAAmBI,SAASC,SAU1B7C,MAAM8C,IAAID,EATkB,CAC/BpD,YAAaoD,EAAQpD,YACrBC,cAAemD,EAAQnD,cACvBuO,WAAY,EACZC,mBAAoB,EACpBC,iBAAkB,EAClBC,iBAAkB,EAClBC,kBAAmB,OAMlB/J,aAAa1E,EAAuBgL,QACpCpI,mBAAmBI,SAASC,UACzB7C,EAAQuE,KAAKvE,MAAMwE,IAAI3B,GACzB7C,GAWV,SACE6K,EACA7K,EACA6C,EACAjD,SAEM6E,EAAc7E,EAAML,QAAQsD,EAAQpD,aAAc6O,IAClDxD,EAAqBrG,EAAY7E,MACjCmL,EAAkBD,EAAqB,EACvCE,EAAkBH,EAAOE,GAAmBF,EAAOE,GAAkBxL,QAAQsD,EAAQpD,aAAc6O,IAAM,QAE3GxD,EAAqBZ,eAAOqE,iBAAmBvD,eAU7CwD,EAmCR,SAAsBC,OAOhBC,EAFAC,EAAOF,MAGNC,EAAQ,EAAGC,EAAMD,GAAS,EAC7BC,GAAQA,EAAO,SAEVD,EA9CkBE,EAHQ5D,EAAgB6D,gBAC1BpK,EAAYoK,gBAC8B,MAEjE7O,EAAMiO,YAAcO,EACpBxO,EAAMoO,kBAAoBI,QAIpBM,EAAmBC,GAAkB/D,EAAgBgE,UAAYhE,EAAgBiE,WACjFC,EAAsBH,GAAkBtK,EAAYuK,UAAYvK,EAAYwK,WAC9EH,IAAqBI,GAAuBA,IAAwB/E,GAAegF,KACrFnP,EAAMiO,YAAc,EACpBjO,EAAMkO,oBAAsB,SAIxBkB,EAAmBL,GAAkB/D,EAAgBqE,QAAUrE,EAAgBsE,SAC/EC,EAAsBR,GAAkBtK,EAAY4K,QAAU5K,EAAY6K,SAC5EF,IAAqBG,GAAuBA,IAAwBpF,GAAegF,KACrFnP,EAAMiO,YAAc,EACpBjO,EAAMmO,kBAAoB,GAOxBnD,EAAgBwE,iBAAoB,IAAO/K,EAAY+K,kBAAqB,KAC9ExP,EAAMiO,YAAc,EACpBjO,EAAMqO,mBAAqB,GAEzBrD,EAAgByE,iBAAoB,IAAOhL,EAAYgL,kBAAqB,KAC9EzP,EAAMiO,YAAc,EACpBjO,EAAMqO,mBAAqB,GA9DvBqB,CAAmB9E,EAAW5K,EAAO6C,EAASjD,MAK7C0J,eACE7G,MAAM8G,KAAKhF,KAAKvE,MAAMwJ,WA0EjC,SAASuF,GAAkBN,EAAWkB,OAChCC,EAASzF,GAAegF,UAExBV,GAAK,OAAUkB,GAAK,MACtBC,EAASzF,GAAe0F,GACfpB,GAAK,OAAUkB,IAAM,MAC9BC,EAASzF,GAAe2F,GACfrB,IAAM,OAAUkB,IAAM,MAC/BC,EAASzF,GAAe4F,GACftB,IAAM,OAAUkB,GAAK,MAC9BC,EAASzF,GAAe6F,GACfL,GAAK,MACdC,EAASzF,GAAe8F,EACfxB,GAAK,MACdmB,EAASzF,GAAe+F,EACfP,IAAM,MACfC,EAASzF,GAAegG,EACf1B,IAAM,QACfmB,EAASzF,GAAeiG,GAGnBR,WEhJOS,IAAqB/Q,SACnCA,EADmCgR,OAEnCA,EAFmCvD,YAGnCA,EAHmCwD,mBAInCA,UAOMC,EAAiBvH,QAAMqH,EAAQ,eAC/BG,EAAsB1D,EACtB2D,EAAsB/C,UAAQZ,GAAc4D,0BAASA,EAAK3V,MAAM,WAAX4V,EAAenR,eACpEoR,EAA6DC,YAAUJ,GAAsB3D,GACjGY,UAAQZ,EAAa,iBAGjBgE,EAAcR,EAAqB,YAEzBjR,EAASC,QAAQkK,KAAKuH,UAC9BvR,EAAcuR,EAAOvR,YAErBwR,EAAezM,MAAIgM,EAAgB/Q,IAAgB,GACnDyR,EAA+B,CACnCC,QAAS3M,MAAIyM,EAAc,oBAC3BG,SAAU5M,MAAIyM,EAAc,qBAC5BI,OAAQ7M,MAAIyM,EAAc,oBAC1BK,SAAU9M,MAAIyM,EAAc,sBAC5BM,MAAO/M,MAAIyM,EAAc,mBAIvBO,EAAkB,EAClBC,EAA4B,QAE1BC,EAAkBpS,EAASC,QAC9BkO,QAAQkE,GAEHA,EAAIlS,cAAgBA,KAKhBH,EAASsS,SAAWD,EAAIE,SAAWb,EAAOa,UAEnDpI,KAAKkI,GAAQA,EAAIlS,kBAEhBqS,EAAc,EACdC,EAAY,SAGhBtB,EAEGhD,QAAQP,GAAeA,EAAWzN,cAAgBA,IAClDmD,SAASsK,IACRsE,IAGItE,EAAWpB,SAAWoB,EAAWnB,YAActM,IACjDsS,GAAa,GAEX7E,EAAWlS,MAAMwE,OAAS,GAAK0N,EAAWlS,MAAM,GAAIyE,cAAgBA,GACtEgS,IAEFvE,EAAWlS,MAAM4H,SAAS4H,IACpBA,EAAK/K,cAAgBA,IACvBqS,GAAetH,EAAK0B,cAKrB,CACLzM,YAAaA,EACbyR,YAAaA,EACbM,gBAAiBA,EACjBM,YAAaA,EACbC,UAAWA,EAEXC,sBAAuBC,GAASR,EAA2BD,GAC3DU,gBAAiBD,GAASf,EAAYK,MAAOR,GAC7CoB,uBAAwBF,GAASf,EAAYC,QAASJ,GACtDqB,gBAAiBH,GAAST,EAAiBO,GAC3CM,iBAAkBJ,GAASH,EAAaN,GACxCc,gBAAiBC,GAAgB1B,EAA8BpR,EAAaiS,EAAiB,eAC7Fc,gBAAiBD,GAAgB1B,EAA8BpR,EAAaiS,EAAiB,kBAC7Fe,qBAAsBC,GAAwB7B,EAA8BpR,EAAaiS,OAO/F,SAASO,GAASvD,EAAe6C,SACxB,CACL7C,MAAOA,EACP6C,MAAOA,EACPoB,MAAOpB,EAAQ7C,EAAQ6C,EAAQ,MAInC,SAASgB,GACP1B,EACApR,EACAiS,EACAkB,SAEMC,EAAWrO,MAAIqM,EAA8B,CAACpR,EAAamT,KAAU,GAErEE,EAAmBC,UACvBrB,EAAgBjI,KAAK/J,GAAkB8E,MAAIqM,EAA8B,CAACnR,EAAekT,KAAU,aAG9FX,GAASY,EAASrT,OAAQqT,EAASrT,OAASsT,EAAiBtT,QAGtE,SAASkT,GACP7B,EACApR,EACAiS,SAEMsB,EAAexO,MAAIqM,EAA8B,CAACpR,EAAa,WAAa,GAC5EwT,EAAiBF,UACrBrB,EAAgBjI,KAAK/J,GAAkB8E,MAAIqM,EAA8B,CAACnR,EAAe,WAAa,MAGlGwT,EAAiB,UAGFC,MAAIH,EAAcC,GAC1BrQ,SAASwQ,UACdC,EAAmBC,QAAMF,GACzBG,EAAqBjL,OAAK8K,MAC5BC,GAAoBE,EAAoB,OACpCC,EAAeH,EAAiBzH,eAAiByH,EAAiB1H,aAClE8H,EAAiBF,EAAmB3H,eAAiB2H,EAAmB5H,cAE1E0H,EAAkBvH,UAAYyH,EAAoBzH,SAE3C0H,EAAeC,IADxBP,EAAehO,KAAKmO,OAOnBpB,GAASiB,EAAe1T,OAAQwT,EAAaxT,QC9ItD,MAAMkU,GAA8B,CAClCC,iBAAiB,SAGNC,GAOX9G,YAAmB+G,QANXA,oBACAC,mBAAoC,UACpCjJ,OAAqB,QACrBtL,QAAoB,QACpBwU,aAAe,IAAItR,WAGpBoR,QAAUG,OAAOC,OAAO,GAAIP,GAAgBG,GAM5ClR,MAAMrD,QAENuL,OAAS,QACTtL,QAAUD,EAASC,QAAQkK,KAAKyK,GAAMA,EAAEzU,mBAGxCsU,aAAanR,SAASuR,GAASA,EAAKxR,MAAMrD,KAG1C8U,YAAYC,QACZN,aAAa7O,QAAQmP,GAGrBC,aACuB,IAAxB/P,KAAKhF,QAAQC,kBAIb+U,EAAgC,OAA5BhQ,KAAKuP,mBAA8BvP,KAAKuP,mBAAqB,EAAI5J,eAAOsK,WACzEjQ,KAAKsG,OAAO0J,IAAI,OACf3U,EAAQ2E,KAAKsG,OAAO0J,OAErBE,GAAiBlQ,KAAKhF,QAASK,eAG/BmU,aAAanR,SAASuR,GAASA,EAAK7P,aAAa1E,EAAO2E,KAAKsG,eAC7DiJ,mBAAqBS,EAC1BA,KAIGG,SAAS9U,QACTiL,OAAOjL,EAAMA,OAASA,EAEvB2E,KAAKsP,QAAQF,sBACVW,WAKX,SAASG,GAAiBlV,EAAmBK,OACtCA,SACI,MAOJ,MAAMoR,KAAUzR,MACKiF,MAAI5E,EAAO,CAAC,UAAWoR,EAAQ,gBAE9C,SAIJ,QChFI2D,sBACH3U,MAAQ,IAAI0C,SACZF,mBAAqB,IAAIC,WACzBmS,OAAS,IAAInS,MAEdE,MAAMrD,QAENU,MAAQ,IAAI0C,SACZF,mBAAqBnD,EAAyCC,QAC9DsV,OAAS,QAETpS,mBAAmBI,SAASC,SAI1B7C,MAAM8C,IAAID,EAHiB,CAC9BgS,MAAO,UAMNvQ,aAAa1E,EAAuBgL,QACpCpI,mBAAmBI,SAASC,UACzB7C,EAAQuE,KAAKvE,MAAMwE,IAAI3B,GACzB7C,GAWV,SACE6K,EACA7K,EACA6C,EACAjD,EACAgV,SAEMnQ,EAAc7E,EAAML,QAAQsD,EAAQpD,aAAciF,KAClDoG,EAAqBrG,EAAY7E,MACjCmL,EAAkBD,EAAqB,EACvCE,EAAkBH,EAAOE,GAAmBF,EAAOE,GAAkBxL,QAAQsD,EAAQpD,aAAciF,KAAO,QAI3G1E,EAAM6U,MAkBJ,GAAI7J,GAAmBrL,EAAa8E,EAAauG,GAAkB,OACxEhL,EAAM6U,MAAMnJ,SAAWjH,EAAY7E,MACnCI,EAAM6U,MAAMhJ,oBAAab,EAAgB7I,WAAW,EACpDnC,EAAM6U,MAAMC,eAAiBrQ,EAAYQ,cACzCjF,EAAM6U,MAAQ,SACT,OACL7U,EAAM6U,MAAMjJ,wBAAiBnH,EAAYtC,WAAW,MAxBpC,IACKJ,EAAO0C,EAAYQ,sBAKxCjF,EAAM6U,MAAQ,CACZpV,YAAaoD,EAAQpD,YACrBgM,WAAYX,EACZY,SAAU,KACVC,aAAc,EACdE,WAAY,KACZD,eAAgB,EAChB8C,MAAOjK,EAAY3E,gBACnBgV,eAAgB,MAGlBF,EAAO1P,KAAKlF,EAAM6U,QAzCdE,CAAmBnK,EAAW5K,EAAO6C,EAASjD,EAAO2E,KAAKqQ,WAKzDtL,eACE/E,KAAKqQ,QCpChB,IAAYI,GCAAC,GASAC,GAOAC,GCLPC,GFXOJ,kCAAAA,GAAAA,4BAAAA,2DAEVA,yBACAA,uCAmBWK,sBACHC,WAAaC,OAAOhM,KAAK,SACzBiM,SAAW,IAAI/S,MAEhBgT,QAAQC,YACRJ,WAAaC,OAAOI,OAAO,CAACpR,KAAK+Q,WAAYI,IAE3CnR,KAAK+Q,WAAW9V,QAAU,GAAG,OAE5BoW,EAAUrR,KAAK+Q,WAAWO,aAAa,MAEzCtR,KAAK+Q,WAAW9V,OAASoW,EAAU,eAMjCE,EAAavR,KAAK+Q,WAAWlQ,MAAM,EAAGwQ,EAAU,QACjDJ,SAAStQ,KAAK6Q,SAAOD,SAGrBR,WAAa/Q,KAAK+Q,WAAWlQ,MAAMwQ,EAAU,IAI/CI,0BACEzR,KAAK+Q,WAGPW,oBACCC,EAAW3R,KAAKiR,qBACjBA,SAAW,GAETU,EAGFC,gBAAgBC,EAAoBC,EAAqBC,GAAa,SACrEC,EAAiBhB,OAAOhM,KAAK,CAAC,EAAG,EAAG,EAAG,IAC7CgN,EAAeC,cAAcH,EAAa,SAEpCI,EAAU,CACd7D,KAAMoC,0BAAkB0B,UACxBC,QAAS,CACPP,OAAQA,EACRC,YAAaO,WAAWrN,KAAKgN,GAC7BD,WAAYA,IAIVO,EAAMC,SAAOL,EAAS,CAC1BM,gBAAgB,IAGZC,EAAMzB,OAAOI,OAAO,CAACJ,OAAOhM,KAAK,CAAC,EAAG,EAAG,EAAG,IAAKgM,OAAOhM,KAAKsN,YAElEG,EAAIR,cAAcK,EAAII,WAAY,GAE3BD,GC/EC/B,gCAAAA,GAAAA,0BAAAA,+CAEVA,qBACAA,yBACAA,gCACAA,eACAA,iBAGUC,iCAAAA,GAAAA,2BAAAA,gEAEVA,iCACAA,+BACAA,yCAGUC,sBAAAA,GAAAA,gBAAAA,+CAEVA,2BACAA,uCCRF,SAAKC,GACHA,oBACAA,kBACAA,kBAHF,CAAKA,KAAAA,QAML,MAAM8B,GAA8C,CAClDC,YAAa,UACbC,eAAgBR,WAAWrN,KAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IACtD8N,QAAS,GACThB,YAAa,GAGTiB,GAA2B,CAC/BC,eAAe,GCpBjB,IAAYC,GCEAC,GCDAC,YCNIC,GAAYC,SAgCpBC,EAAMpO,MAAImO,GAAME,IAASC,OA9BVC,EA8BsBF,EAAKG,WAAW,IAzB1C,OAAUD,EAAW,MACjBA,EAAW,MAArB,GAIQ,QAAbA,EACK,GAOQ,OAAbA,EACK,GAIQ,OAAbA,EACK,GAGFA,EA3BYA,IAAAA,YAgCdE,OAAOC,gBAAgBN,GF4BhC,SAASO,GAAQC,EAAiBC,EAAoBC,EAAgB/Y,EAAgBgZ,UAC5EH,EAAII,aACLhB,GAAeiB,YACXC,UAAGC,SAAUP,EAAyBQ,eAAgBP,EAAQC,EAAQ/Y,EAAQgZ,QAClFf,GAAeqB,cACVT,EAA2BC,OAAOS,KAAKT,EAAQC,EAAQC,EAAUA,EAAWhZ,iBAE9E,IAAIwZ,MAAM,8BAItB,SAASC,GAAUZ,UACTA,EAAII,aACLhB,GAAeiB,YACAC,UAAGO,UAAWb,EAAyBQ,gBACxC3P,UACduO,GAAeqB,cACVT,EAA2BC,OAAO9Y,qBAEpC,IAAIwZ,MAAM,uCAONG,GAAYC,SACpBf,EAhDR,SAAgBe,UACNA,EAAMX,aACPhB,GAAeiB,SACbU,EAAMC,eACH,IAAIL,MAAM,0CAEZM,EAAKX,UAAGY,SAASH,EAAMC,SAAU,WAChC,CACLZ,OAAQW,EAAMX,OACdI,eAAgBS,QAEf7B,GAAeqB,aACX,CACLL,OAAQW,EAAMX,OACdH,OAAQc,EAAMd,sBAGV,IAAIU,MAAM,8BA+BRQ,CAAOJ,GAEbK,EAyBR,SAA4BpB,SACpBC,EAAS,IAAI1B,WAAW,UAC9BwB,GAAQC,EAAKC,EAAQ,EAAGA,EAAO9Y,OAAQ,GAErB,KAAd8Y,EAAO,IAIPA,EAAO,KAAO,IAAIL,WAAW,GAHxB,EAOF,GArCiByB,CAAmBrB,GACrCsB,EAuCR,SAA0BtB,EAAiBG,SACnCoB,EAAWX,GAAUZ,MACV,IAAbG,SACKoB,QAGHtB,EAAS,IAAI1B,WAAW,GAC9BwB,GAAQC,EAAKC,EAAQ,EAAGA,EAAO9Y,OAAQgZ,EAAW,SAE5CqB,EAAcvB,EAAO,IAAO,GAAOA,EAAO,IAAO,GAAOA,EAAO,IAAO,EAAKA,EAAO,UACpFuB,EAAa,EAERA,EAMFD,EAAWpB,EAzDIsB,CAAiBzB,EAAKoB,GACtCM,EAAmBN,EAAkBE,EAAgB,GACrDK,EA0DR,SAA2B3B,EAAiBG,UAC9BS,GAAUZ,GACTG,EAAW,EA5DDyB,CAAkB5B,EAAK0B,GACxCG,EA8DR,SACE7B,EACAG,SAIM0B,EAEF,MAEa,IAAb1B,SACF0B,EAAa,IAAQ,IACrBA,EAAa,IAAQ,EACrBA,EAAa,IAAQ,GACrBA,EAAa,IAAQ,EACdA,QAGH5B,EAAS,IAAI1B,WAAW,MAC9BwB,GAAQC,EAAKC,EAAQ,EAAGA,EAAO9Y,OAAQgZ,GACnCF,EAAO,KAAOtO,gBAAQmQ,oBACjB,SAGHC,EAAgB9B,EAAO,GAC5B4B,EAAa,IAAgBE,QAExBC,EAAqB,IAAIzD,WAAWwD,EAAgB,GAC1DhC,GAAQC,EAAKgC,EAAoB,EAAGA,EAAmB7a,OAAQgZ,EAAW,OACrE,IAAIjE,EAAI,EAAGA,EAAI6F,EAAgB,EAAG7F,GAAK,EAIzC2F,EAHeG,EAAmB9F,IAGD8F,EAAmB9F,EAAI,IAAO,EAAK8F,EAAmB9F,EAAI,UAGvF2F,EAlGcI,CAAgBjC,EAAKoB,SAEnC,CACLpB,IAAKA,EACLoB,gBAAiBA,EACjBE,cAAeA,EACfI,iBAAkBA,EAClBC,eAAgBA,EAChBE,aAAcA,YAIFK,GAAaC,GACnBA,EAAKnC,IAAII,SACVhB,GAAeiB,MAClBC,UAAG8B,UAAWD,EAAKnC,IAAyBQ,yBAiIlC6B,GAAaC,EAAkBhE,SACvCiE,EAAO,IAAIC,SAASlE,EAAQ2B,eAC1BqC,QACD3Q,gBAAQ8Q,iBACLC,EAAmBtb,UAEjBub,EAAyB,EAAdvb,EACXwb,EAAWC,GAAWN,EAAM,IAAQI,OAEtCG,EAAW,OACXF,IAFeC,GAAWN,EAAM,IAAQI,GAG1CG,EAAW,QACW,IAAbF,EACTE,EAAW,MACW,IAAbF,IACTE,EAAW,eAMPC,EAAe,IAFC,GACA3b,EAEhB4b,EAAa1E,EAAQvR,MAAMgW,EAAcA,EAHzB,IAIhBE,EAAgBC,UACnBxF,OAAOsF,EAAsB,aAC7BG,MAAM,MACNC,QACGC,EAAUJ,EAAgB3D,GAAY2D,GAAiB,GAKvDK,EAAmB,IAFC,GACAlc,EAEpBmc,EAAiBjF,EAAQvR,MAAMuW,EAAkBA,EAH7B,IAIpBE,EAAoBN,UACvBxF,OAAO6F,EAA0B,aACjCJ,MAAM,MACNC,QACGK,EAAcD,EAAoBlE,GAAYkE,GAAqB,GAKnEE,EAAmB,IAFC,GACAtc,EAEpBuc,EAAiBrF,EAAQvR,MAAM2W,EAAkBA,EAH7B,IAIpBE,EAAoBV,UACvBxF,OAAOiG,EAA0B,aACjCR,MAAM,MACNC,QACGS,EAAcD,EAAoBtE,GAAYsE,GAAqB,GAEnE1D,EAAuB,GAAd9Y,QACR,CACLA,YAAaA,EACb0c,KAAM1c,EAAc,EACpB2c,YAAaC,GAAUzB,EAAM,IAAOrC,GACpCzd,eAAgBuhB,GAAUzB,EAAM,IAAOrC,GACvC+D,YAAaD,GAAUzB,EAAM,IAAOrC,GACpC3F,KAAMyJ,GAAUzB,EAAM,IAAOrC,GAC7B1G,OAAQwK,GAAUzB,EAAM,IAAOrC,GAC/BgE,cAAepB,EACfO,QAASA,EACTI,YAAaA,EACbI,YAAaA,UAGV,CACLM,cAAeH,GAAUzB,EAAM,MAAQyB,GAAUzB,EAAM,MAAQyB,GAAUzB,EAAM,KAC/EhJ,QAAS6K,GAAS7B,EAAM,IACxB8B,MAAOD,GAAS7B,EAAM,KACtB7b,QAAS4d,GAAW/B,EAAM,IAC1Brb,QAAS,CAAC,EAAG,EAAG,EAAG,GAAGkK,IAAIsR,GAC1B6B,MAAOP,GAAUzB,EAAM,KACvBiC,SAAUR,GAAUzB,EAAM,WAEzB5Q,gBAAQ8S,uBACJ,CACLld,MAAOmd,GAAUnC,EAAM,GACvBnb,YAAa4c,GAAUzB,EAAM,GAC7BoC,WAAYP,GAAS7B,EAAM,GAC3BqC,KAAM/B,GAAWN,EAAM,GACvB3V,cAAe0X,GAAW/B,EAAM,IAChCnT,UAAWyV,GAAUtC,EAAM,IAC3BuC,UAAWD,GAAUtC,EAAM,IAC3BlT,gBAAiBwV,GAAUtC,EAAM,IACjC5L,UAAWkO,GAAUtC,EAAM,IAC3B3L,UAAWiO,GAAUtC,EAAM,IAC3BvL,QAAS6N,GAAUtC,EAAM,IACzBtL,QAAS4N,GAAUtC,EAAM,IACzBwC,QAASF,GAAUtC,EAAM,IACzBzJ,QAAS+J,GAAWN,EAAM,IAC1B/L,gBAAiB8N,GAAW/B,EAAM,IAClCpL,iBAAkB0N,GAAUtC,EAAM,IAClCnL,iBAAkByN,GAAUtC,EAAM,IAClCzY,QAAS+a,GAAUtC,EAAM,UAExB5Q,gBAAQqT,wBACLC,EAA2C,CAC/CC,KAAML,GAAUtC,EAAM,IACtBjL,EAAGuN,GAAUtC,EAAM,IACnB4C,QAASN,GAAUtC,EAAM,IACzB6C,QAASP,GAAUtC,EAAM,IACzB8C,QAASR,GAAUtC,EAAM,WAEpB,CACLhb,MAAOmd,GAAUnC,EAAM,GACvBnb,YAAa4c,GAAUzB,EAAM,GAC7BoC,WAAYP,GAAS7B,EAAM,GAC3B+C,oBAAqBtB,GAAUzB,EAAM,GACrC3V,cAAe0X,GAAW/B,EAAM,GAChCnT,UAAWyV,GAAUtC,EAAM,IAC3BuC,UAAWD,GAAUtC,EAAM,IAC3BlT,gBAAiBwV,GAAUtC,EAAM,IACjCzY,QAAS+a,GAAUtC,EAAM,IACzBgD,WAAYV,GAAUtC,EAAM,IAC5B5O,iBAAkBqQ,GAAUzB,EAAM,IAClCiD,kBAAmBxB,GAAUzB,EAAM,IACnC7O,UAAWsQ,GAAUzB,EAAM,IAC3B9a,gBAAiBuc,GAAUzB,EAAM,IACjCrP,mBAAoB2R,GAAUtC,EAAM,IACpCkD,gBAAiBZ,GAAUtC,EAAM,IACjCmD,WAAYtB,GAAS7B,EAAM,IAC3BoD,aAAcrB,GAAW/B,EAAM,IAC/BqD,eAAgB5B,GAAUzB,EAAM,IAChCzS,cAAekU,GAAUzB,EAAM,IAC/BsD,sBAAuB7B,GAAUzB,EAAM,IACvC0C,kBAAmBA,QAElBtT,gBAAQmU,kBACJ,CACLve,MAAOmd,GAAUnC,EAAM,GACvBwD,OAAQzB,GAAW/B,EAAM,GACzB5a,MAAOqc,GAAUzB,EAAM,GACvBlT,gBAAiBwV,GAAUtC,EAAM,GACjCyD,UAAWnB,GAAUtC,EAAM,IAC3B0D,UAAWpB,GAAUtC,EAAM,IAC3BnT,UAAWyV,GAAUtC,EAAM,IAC3BuC,UAAWD,GAAUtC,EAAM,IAC3B2D,YAAa5B,GAAW/B,EAAM,IAC9B4D,gBAAiBtB,GAAUtC,EAAM,IACjC6D,QAASvD,GAAWN,EAAM,IAC1B8D,YAAarC,GAAUzB,EAAM,IAC7B+D,WAAYtC,GAAUzB,EAAM,IAC5BgE,mBAAoBvC,GAAUzB,EAAM,IACpCiE,YAAaxC,GAAUzB,EAAM,IAC7BkE,MAAOC,GAASnE,EAAM,UAErB5Q,gBAAQgV,oBACJ,CACLpf,MAAOmd,GAAUnC,EAAM,GACvBqE,qBAAsBlC,GAAUnC,EAAM,SAErC5Q,gBAAQkV,eACJ,CACLC,cAAe9C,GAAUzB,EAAM,GAC/BwE,mBAAoBL,GAASnE,EAAM,mBAG9B,MAIb,SAASyE,GAAgBzE,EAAgBrC,EAAgB/Y,UAEhD+Y,EAAS/Y,GADGob,EAAK3D,WAI1B,SAASiG,GAAUtC,EAAgBrC,UAC5B8G,GAAgBzE,EAAMrC,EAAQ,GAI5BqC,EAAK0E,WAAW/G,GAHd,KAMX,SAASwE,GAAUnC,EAAgBrC,UAC5B8G,GAAgBzE,EAAMrC,EAAQ,GAI5BqC,EAAK2E,SAAShH,GAHZ,KAMX,SAASwG,GAASnE,EAAgBrC,UAC3B8G,GAAgBzE,EAAMrC,EAAQ,GAI5BqC,EAAK4E,QAAQjH,GAHX,KAMX,SAAS2C,GAAWN,EAAgBrC,UAC7B8G,GAAgBzE,EAAMrC,EAAQ,GAI5BqC,EAAK6E,UAAUlH,GAHb,KAMX,SAASoE,GAAW/B,EAAgBrC,UAC7B8G,GAAgBzE,EAAMrC,EAAQ,GAI5BqC,EAAK8E,UAAUnH,GAHb,KAMX,SAAS8D,GAAUzB,EAAgBrC,UAC5B8G,GAAgBzE,EAAMrC,EAAQ,GAI5BqC,EAAK+E,SAASpH,GAHZ,KAMX,SAASkE,GAAS7B,EAAgBrC,UAC3B8G,GAAgBzE,EAAMrC,EAAQ,KAI1BqC,EAAK+E,SAASpH,GAHd,KDncCf,mCAAAA,GAAAA,6BAAAA,8DAEVA,2BACAA,2BACAA,uBCFF,SAAYC,GACVA,kBACAA,cAFF,CAAYA,KAAAA,QCDAC,8BAAAA,GAAAA,wBAAAA,uCAEVA,mBAGF,MAAMkI,GAAkB,CACtBC,gBAAgB,EAChBC,KAAMpI,sBAAcqI,MAiBtB,IAAYC,GAAAA,+BAAAA,GAAAA,yBAAAA,0CAEVA,+BAcWC,WAAkBC,WAY7BpT,YAAmBqT,EAAyCC,SACpDA,QAZAC,WAAY,OACZ/gB,qBACAghB,aAAoC,UACpCC,eAA6BhL,OAAOhM,KAAK,SAU1CjK,SAAW0U,OAAOC,OAAO,GAAI2L,GAAiBO,GAG9CK,eACAH,WAAY,OACZC,aAAe,KAIfG,OAAOC,EAAiBC,EAAkBC,MAC9B,WAAbD,QACI,IAAI3H,6DAA6D2H,aAInEjL,EAAOkB,WAAWrN,KAAKgM,OAAOI,OAAO,CAACpR,KAAKgc,eAAgBG,UAG5DH,eAAiBhL,OAAOhM,KAAK,UAE5BsX,EAAW,IAAIhG,SAASnF,EAAK4C,YAG/BwI,EAAQ,OACLA,EAAQpL,EAAKlW,QAAQ,IH7ED,WG+ErB+V,OAAOhM,KAAKmM,EAAKtQ,MAAM0b,EAAOA,EAAQ,IAAIC,WAAgC,CAC5ED,GAAS,iBAKLnG,EAAUkG,EAASlB,SAASmB,OAC9BE,EAAc,WACdzc,KAAK+b,eACPU,WAAczc,KAAK+b,aAAa9b,IAAImW,MAAY,GAE7BjF,EAAKlW,OAASshB,EAChBE,EAAc,EAAG,MAG7BT,eAAiB7K,EAAKtQ,MAAM0b,YAK/Bvc,KAAKjF,SAASwgB,OAASpI,sBAAcuJ,QAAU1c,KAAK8b,gBAKxDS,GAAS,QAEHI,EAAaxL,EAAKtQ,MAAM0b,GACxBK,EAAkB,IAAItG,SAASnF,EAAK4C,OAAQwI,OAC9CM,EAAa,MAEfA,EAAa7c,KAAK8c,gBAAgB1G,EAASuG,EAAYC,GACvD,MAAOG,OAEF/c,KAAKjF,SAASugB,qBACXyB,EAERF,EAAa,EAEfN,GAASM,EAGXR,IAGMW,cAAc5G,EAAkB6G,EAA2BR,SAC3DS,EAAaD,EAAcpc,MAAM,EAAG4b,GACpCU,EAAanM,OAAOI,OAAO,CAACJ,OAAOhM,KAAK,CAACoR,IAAW8G,gBAErD7U,KAAKoT,uBAAe2B,IAAK,CAC5BhH,QAASA,EACThE,QAAS+K,IAEJ,IAAI9K,WAAW8K,GAGhBL,gBAAgB1G,EAAkB6G,EAA2BX,MAE/DlG,IAAY3Q,gBAAQmQ,cAAe,OAC/B6G,EAAcH,EAASlB,SAAS,eAEjCW,aAAesB,GAAuBf,QAEtCU,cAAc5G,EAAS6G,EAAeR,QACtCpU,KAAKoT,uBAAe6B,QAAS,CAChClH,QAASA,EACThE,QAASpS,KAAK+b,eAETU,MAGLA,EAAc,QACdzc,KAAK+b,eACPU,WAAczc,KAAK+b,aAAa9b,IAAImW,MAAY,OAI9ChE,EACAmL,EAA0C,YAC1Cd,EAAc,IAChBrK,EAAUpS,KAAKgd,cAAc5G,EAAS6G,EAAeR,GACrDc,EAAgBpH,GAAaC,EAAShE,IAEnCmL,GAIGnH,IACD3Q,gBAAQkV,UAEP3a,KAAKjF,SAASwgB,OAASpI,sBAAcuJ,cAClCZ,WAAY,QAKlBzT,KAAKoT,uBAAe6B,QAAS,CAChClH,QAASA,EACThE,QAASmL,IAEJd,GAhBEA,GAoBb,MAAMY,GAA0Bf,UACxBP,EAAe,IAAI5d,IACnB0e,EAAaP,EAASlB,SAAS,OAChC,IAAIpL,EAAI,EAAGA,EAAI6M,EAAY7M,GAAK,EAAG,OAChCwN,EAAclB,EAASlB,SAASpL,GAChCyM,EAAcH,EAASnB,UAAUnL,EAAI,GAC3C+L,EAAaxd,IAAIif,EAAaf,UAEzBV,SEjKI0B,WAAgB9B,WAc3BpT,YAAmBuM,EAAkB4I,EAAuB7B,SACpDA,QAdA/G,qBACArM,qBACAkV,WAAiC,UACjCvI,cAAgB,OAChBsI,sBACAE,oBAAqB,OAUtB9I,SAAWA,OACXrM,SAAW,CACdoV,gBA5CmB,UA6CnBC,UAAWC,YACXC,WAAY,IACZhjB,QAAS,SAEN4iB,mBAAqBK,QAAQP,QAI7BA,UAAYA,GAAwB,IAAIhC,GAAU,CAAEH,KAAMpI,sBAAcuJ,cAExEwB,uBACAC,mBAAmBne,KAAK8U,UASxBsJ,cACEpe,KAAK8U,SAOPuJ,YAAY5V,QACZA,SAAWgH,OAAOC,OAAO,GAAI1P,KAAKyI,SAAUA,GAG5CyT,OAAOoC,EAAmBlC,EAAkBC,MAChC,WAAbD,QACI,IAAI3H,6DAA6D2H,OAGrEpc,KAAK2d,iBACFA,WAAWY,MAAMD,GAInBte,KAAK4d,yBACHF,UAAUa,MAAMD,QAIlBlJ,eAAiBkJ,EAAMrjB,OAC5BohB,IAUMmC,WAAWrN,SACXiF,QAAEA,EAAFhE,QAAWA,GAAYjB,SACrBiF,QACD3Q,gBAAQ8Q,iBACLvb,QAAEA,GAAYoX,EACpB/T,UAAQrD,GAAUyR,IACI,IAAhBA,EAAO4B,YAIN5F,SAASzN,QAAQyR,EAAOvR,aAAe,CAC1CujB,eAAgB,GAChBC,MAAO,CACLC,QAASlS,EAAO8K,YAChBqH,KAAMnS,EAAOkL,6BAKhBlS,gBAAQqT,wBAELzd,MAAEA,EAAFH,YAASA,EAATud,WAAsBA,EAAtBW,oBAAkCA,GAAwBhH,KAC5DqG,aAMChQ,SAASuV,UAAY3iB,QAGpBwjB,EAAa7e,KAAKyI,SAASzN,QAAQE,GACnCujB,EAAiBI,EAAYJ,eAC7BK,EAAgBL,EAAerF,IAAyB,EACxD3M,EAAS,IACVoS,EACHJ,eAAgB,IACXA,GACFrF,GAAuB0F,EAAgB,SAGtCrW,SAASzN,QAAgBE,GAAgBuR,GAK7CyR,wBACAa,EAAkB5N,SACjBqN,WAAWrN,SAEbuM,UAAUsB,GAAGvD,uBAAe6B,QAASyB,QAErCC,GAAG,UAAU,WAEVjK,EAAKX,UAAGY,SAAShV,KAAK8U,SAAU,MACtCV,UAAG6K,UAAUlK,EAAImK,GAAmBlf,KAAKoV,eAAgB,EAAG,EAAG,IAC/DhB,UAAG8B,UAAUnB,QAGR2I,UAAUyB,eAAe1D,uBAAe6B,QAASyB,GAEjD/e,KAAK4d,yBACHF,UAAU0B,SAKbjB,mBAAmBrJ,QACpB6I,WAAavJ,UAAGiL,kBAAkBvK,EAAU,CAC/CsH,SAAU,iBAGNkD,EAAStO,OAAOI,OAAO,CAC3BJ,OAAOhM,KAAK,MACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,YACZgM,OAAOhM,KAAK,CAAC,EAAG,EAAG,EAAG,WAEnB2Y,WAAWY,MAAMe,GAGjBC,OAAOlD,OACRmD,EAASxO,OAAOI,OAAO,CAACJ,OAAOhM,KAAK,KAAMgM,OAAOhM,KAAK,CAAC,IAAKgM,OAAOhM,KAAK,qBAGtEya,EAAezf,KAAKyI,SAASqV,UAAU4B,cAC7CF,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,aACZgM,OAAOhM,KAAK,CAACya,EAAaxkB,SAC1B+V,OAAOhM,KAAKya,WAKRzB,EAAYhe,KAAKyI,SAASuV,UAChCwB,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,cACZ2a,GAAkB3B,WAIdpL,EAAc5S,KAAKyI,SAASoV,iBAlNb,UAmNrB2B,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC,KACbgM,OAAOhM,KAAK,iBACZgM,OAAOhM,KAAK,CAAC4N,EAAY3X,SACzB+V,OAAOhM,KAAK4N,KAId4M,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,KAAMgM,OAAOhM,KAAK,CAAC,IAAKgM,OAAOhM,KAAK,cAEhF3G,UADgB2B,KAAKyI,SAASzN,SACb,CAACyR,EAAQ8P,KAExBiD,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,KAAMgM,OAAOhM,KAAK,CAACuX,EAAMthB,SAAU+V,OAAOhM,QAAQuX,QAG9FiD,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,KAAMgM,OAAOhM,KAAK,CAAC,KAAMgM,OAAOhM,KAAK,iBAGjF3G,UAAQoO,EAAOgS,gBAAgB,CAACmB,EAAOC,KAErCL,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC6a,EAAW5kB,SACxB+V,OAAOhM,QAAQ6a,MACfX,GAAmBU,QAKvBJ,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,OAG5Cwa,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,KAAMgM,OAAOhM,KAAK,CAAC,IAAKgM,OAAOhM,KAAK,YAGhFwa,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,aACZgM,OAAOhM,KAAK,CAACyH,EAAOiS,MAAMC,QAAQ1jB,SAClC+V,OAAOhM,QAAQyH,EAAOiS,MAAMC,aAI9Ba,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,UACZgM,OAAOhM,KAAK,CAACyH,EAAOiS,MAAME,KAAK3jB,SAC/B+V,OAAOhM,QAAQyH,EAAOiS,MAAME,UAI9BY,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,WAI9Cwa,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,OAG5Cwa,EAASxO,OAAOI,OAAO,CACrBoO,EACAxO,OAAOhM,KAAK,KACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,cACZgM,OAAOhM,KAAK,CAAC,IACbgM,OAAOhM,KAAK,aAIdwa,EAASxO,OAAOI,OAAO,CAACoO,EAAQxO,OAAOhM,KAAK,QAGxChF,KAAK2d,iBACFA,WAAWY,MAAMiB,EAAQnD,IAKpC,MAAMsD,GAAqBG,UACnBxN,EAAMtB,OAAO+O,MAAM,UACzBzN,EAAI0N,aAAaF,EAAQ,GAClBxN,GAGH4M,GAAsBY,UACpBxN,EAAMtB,OAAO+O,MAAM,UACzBzN,EAAIL,cAAc6N,EAAQ,GACnBxN,GCrSH+I,GAAwC,CAC5C4E,aAAa,EACbC,WAAY,IACZrC,gBAAiB,UACjBsC,YAfF,SAAwBC,EAAgBC,UAC/BjC,UAAKkC,KAAKF,UAAgBC,EAAEE,OAAO,eAAeF,EAAEE,OAAO,mBAiBpE,IAAYC,GCXAC,GDWAD,mCAAAA,GAAAA,6BAAAA,oDAEVA,uCE/BWE,sBACHC,eAAqC,QACrCC,mBAAqB,OACrBC,kBAAmC,UACnCC,sBAAuB,OACvBC,sBAAwB,OACxBC,gBAA4B,GAE7BC,qBAAqBC,EAA0CC,MACrC,OAA3BnhB,KAAK6gB,uBAEFA,kBAAoBM,OACpB,GAAInhB,KAAK6gB,oBAAsBM,gBAIlCD,GAEElhB,KAAK2gB,eAAeO,EAAa7lB,YAC9BslB,eAAeO,EAAa7lB,OAAQsF,KAAKugB,QAEzCP,eAAeO,EAAa7lB,OAAS,CAAC6lB,QAExCN,0BACAG,6BACAD,sBAAuB,GACnB9gB,KAAK8gB,4BACTE,gBAAgBrgB,KAAKX,KAAK+gB,4BAC1BA,sBAAwB,OACxBD,sBAAuB,GAEvB9gB,KAAK8gB,qBAGPM,mBACEphB,KAAK2gB,eAGPU,kBACErhB,KAAK4gB,mBAGPU,oBACEthB,KAAKghB,iBDzBJP,+BAAAA,GAAAA,yBAAAA,gDAEVA,aACAA,iBACAA,qCACAA,mCAOF,MAAMc,GAA0B,CAC9BC,QAAQ,SAKGC,WAAkB3b,eAU7ByC,YAAmB+G,gBATXhJ,OAAqB,QACrBob,gBAAmC,IAAIhB,QACvC3lB,SAAiC,UACjC4mB,QAA8B,UAC9BC,iBAAkC,UAClCC,kBAAmB,OACnBC,mBAAqBnc,eAAOsK,MAAQ,OACpCX,oBAIDA,QAAUG,OAAOC,OAAO,GAAI6R,GAAyBjS,GAIrDyS,cAAc3L,EAAkBhE,UAC7BgE,QACD3Q,gBAAQ8Q,gBACNyL,iBAAiB5P,cAEnB3M,gBAAQqT,uBAGNmJ,uBAAuB7P,QACvB8P,mBAAmB9L,EAAShE,cAE9B3M,gBAAQ8S,sBACN2J,mBAAmB9L,EAAShE,cAE9B3M,gBAAQmU,iBACNuI,kBAAkB/P,cAEpB3M,gBAAQgV,mBACN2H,oBAAoBhQ,cAEtB3M,gBAAQkV,cACN0H,eAAejQ,IAQnBkQ,aACAhc,OAAS,QACTvL,SAAW,UACX4mB,QAAU,UACVC,iBAAmB,UACnBC,kBAAmB,OACnBC,mBAAqBnc,eAAOsK,MAAQ,EAGpCsS,6CACEviB,KAAK4hB,oBAAoBjc,eAAOsK,MAAQ,EAG1CuS,+BACyB,OAA1BxiB,KAAK4hB,kBAGF5hB,KAAK4hB,iBAAmBjc,eAAOqE,eAF7B,EAEkDhK,KAAK4hB,iBAAmBjc,eAAOqE,eAGrFyY,uBAKCpc,EAAYrG,KAAKohB,YACjBsB,EAAuC,OAA1B1iB,KAAK4hB,iBAA4B5hB,KAAK4hB,iBAAmBjc,eAAOsK,aAE5EhQ,MAAIoG,EADQrG,KAAK2hB,QAAUe,EAAaA,EAAa,IACvB,KAGhCC,qBACE3iB,KAAK6hB,iBAAmB7hB,KAAKjF,SAAW,KAG1C6nB,oBACE5iB,KAAK2hB,QAGPP,mBACEphB,KAAKsG,OAGPuc,0BACE,CACLvc,OAAQtG,KAAK0hB,gBAAgBN,YAC7BjX,MAAOnK,KAAK0hB,gBAAgBL,WAC5ByB,QAAS9iB,KAAK0hB,gBAAgBJ,cAI3ByB,SAASC,UACPhjB,KAAKsG,OAAO0c,IAAQ,KAGrBX,eAAejQ,GAES,OAA1BpS,KAAK4hB,kBAA6B5hB,KAAK4hB,mBAAqB5hB,KAAK8hB,yBAC9DmB,gBAAgBjjB,KAAK4hB,uBAIvBD,QADLvP,EAAUA,OAEL/J,KAAKoY,uBAAeyC,IAAKljB,KAAK2hB,SAG7BK,iBAAiB5P,QAClBrX,SAAWqX,OAEXrX,SAASC,QADEoX,EAAQpX,QACQkO,QAAQuD,GAA2B,IAAhBA,EAAO4B,OAItD+D,EAAQ6F,YAAckL,UAAOC,IAAIhR,EAAQ6F,WAAY,eAClDoL,oBAIDpB,uBAAuB7P,OACzBpS,KAAK6hB,qBAKLzP,EAAQ/W,OAAUsK,eAAOsK,MAAO,OAC5B/U,EAAckX,EAAQlX,YACtBooB,EAAiB5e,QAAM1E,KAAKjF,SAAUC,QAAS,sBAE7CoX,EAAQgH,0BACT,EACHkK,EAAepoB,GAAc2c,YAAc,cAExC,GACHyL,EAAepoB,GAAc2c,YAAc,IAI7CzF,EAAQ/W,MAASsK,eAAOsK,YACrBoT,qBAIDnB,mBAAmB9L,EAAkBhE,GAC3CA,EAAUA,QACJmR,EAAWnN,IAAY3Q,gBAAQ8S,iBAAmB,MAAQ,OAC1DjY,EAAQ8R,EAAQqG,WAAa,YAAc,UAC3ClS,EAAqB6L,EAAQ/W,cAC9BumB,iBAAmBrb,EACP,QAAbgd,IAAuBnR,EAAQqG,WAAY,OACvCyI,EAAelhB,KAAKsG,OAAOC,GACXvG,KAAK0hB,gBAAgBT,qBAAqBC,EAAc9O,EAAQlX,mBAG/EmN,KAAKoY,uBAAe+C,eAAgBtC,GAG7C3iB,MAAIyB,KAAKsG,OAAQ,CAACC,EAAoBjG,EAAO8R,EAAQlX,YAAcqoB,GAAWnR,GAC9E7T,MAAIyB,KAAKsG,OAAQ,CAACC,EAAoB,SAAUA,SAI1CxL,EAAWiF,KAAK2iB,eAClB5nB,GAAcA,EAASkd,aAAckL,UAAOM,IAAI1oB,EAASkd,WAAY,SAKvE1Z,MAAIyB,KAAKsG,OAAQ,CAACC,EAAoB,uBAAuB,SAJxD8B,KAAKoY,uBAAeiD,MAAO1jB,KAAKsG,OAAOC,SAEvC0c,gBAAgB1c,EAAqB,IAMtC4b,kBAAkB/P,iBAClB7L,EAAqB6L,EAAQ/W,MAC7BsoB,oBAAQ3jB,KAAKsG,OAAOC,WAAZqd,EAAiCD,SAAS,GACxDA,EAAMhjB,KAAKyR,GAGX7T,MAAIyB,KAAKsG,OAAQ,CAACC,EAAoB,SAAUod,GAG1CvB,oBAAoBhQ,SACpBsI,EAAuBtI,EAAQsI,qBAC/BnU,EAAqB6L,EAAQ/W,SACnCkD,MAAIyB,KAAKsG,OAAQ,CAACC,EAAoB,uBAAuB,QAExD8B,KAAKoY,uBAAeiD,MAAO1jB,KAAKsG,OAAOC,IAGnBvG,KAAKjF,SAAUud,WAAa5S,iBAASme,QACtCnJ,GAAwB/U,eAAOsK,MAAO,IAExDjQ,KAAKsP,QAAQkS,QAAU9G,EAAuBnU,EAxNrB,QAyNrB,IAAIkO,2DAAgFlO,UAEvF0c,gBAAgBvI,aAGhBuI,gBAAgB1c,EA9NQ,GAsOzB0c,gBAAgBD,QACfhjB,KAAK8hB,mBAAqBkB,GAAK,OAC9Bc,EAAkB9jB,KAAK8hB,mBAAqB,EAC5CzmB,EAAQ2E,KAAK+iB,SAASe,MAGxB9jB,KAAKsP,QAAQkS,WACV,MAAM/U,KAAUzM,KAAKjF,SAAUC,QAAS,OACrC+oB,EAAkB1oB,EAAML,QAAQyR,EAAOvR,gBAGzC8E,KAAKjF,SAAUC,QAAQC,OAAS,IAAM8oB,iBAIpCha,IAAEA,EAAF5J,KAAOA,GAAS4jB,MACjBha,IAAQ5J,QAEL,IAAIsU,kCACoBqP,QAAsBd,cAFlCjZ,EAAM,MAAQ,kCAEyE0C,EAAOvR,oBAOjHmN,KAAKoY,uBAAeuD,gBAAiB3oB,QACrCymB,mBAAqBgC,GAItBT,oBACDrjB,KAAK6hB,wBACHA,kBAAmB,OACnBxZ,KAAKoY,uBAAewD,SAAUjkB,KAAKjF,uIPpOP+K,eAWrCyC,YAAmB+G,gBAVX4U,sBACAtM,iBACA7F,uBACAoS,iBAAmBxT,yBAAiByT,kBACpCC,YAAiC,IAAK1R,SACtC2R,OAA4B,UAC5BC,WAA0D,UAC1DjV,oBACAkV,iBAAkB,OAInBN,UAAY,eACZtM,KAAOhH,cAAM6T,aACb1S,YAAa,OACbzC,QAAUG,OAAOC,OAAO,GAAIqD,GAA0BzD,GAMtDoV,mBACE1kB,KAAKmkB,iBAMPxB,oBACE,CACLuB,UAAWlkB,KAAKkkB,UAChBtM,KAAM5X,KAAK4X,MAOR+M,mBACE,IAAK3kB,KAAKqkB,aAWZO,QAAQC,EAAYjN,EAAc7F,GAAa,EAAO+S,EA9FzB,UA+F7BZ,UAAYW,OACZjN,KAAOA,OACP7F,WAAaA,OACbgT,eAAeF,EAAIjN,EAAMkN,GAGxBC,eAAeF,EAAYjN,EAAckN,SAEzCE,EAAYC,WAAO,IACvBC,UAAIN,QAAQ,CACVO,KAAMN,EACNjN,KAAMA,EACNkN,QAASA,WAKRM,WAAWzU,yBAAiB0U,kBAG3BC,EAAe,IAAIxU,GAInByT,EAAaS,EACjB,CACEO,aAAc,IACdC,SAAU,IACVC,SAAU,YACVC,UAAWC,WAEZrB,eACMjc,KAAKqI,wBAAgBkV,cAErBpB,gBAAkBxkB,KAAKsP,QAAQ0D,mBAC/BsR,OAASA,MAEVuB,EAAgChV,GAAmBiV,QACvDxB,EAAOtF,GAAG,QAAS7N,OACb0U,IAAchV,GAAmBiV,UACnCD,EAAY7lB,KAAK+lB,qBAAqB5U,GACtC6U,QAAQC,oBAAoBpB,KAAMjN,gBAAmBiO,UAChDT,WAAWzU,yBAAiBuV,WACjCF,QAAQC,IAAI9U,EAAKqL,SAAS,SAGxBqJ,IAAchV,GAAmBsV,wBAG9BC,kBAAkBjV,OAKvBmU,EAAapU,QAAQC,GACrB,MAAO4L,UACPiJ,QAAQK,MAAM,4CAA6C,CACzDA,MAAOtJ,EACPuJ,YAAahB,EAAa7T,mBAC1B8U,QAASpV,IAEXmT,EAAOkC,oBACFne,KAAKqI,wBAAgB+V,MAAO1J,SAG7B9L,EAAWqU,EAAa5T,kBAI5BT,EAAS5S,SAAS6T,GAAYlS,KAAK0mB,gBAAgBxU,KACnD,MAAO6K,GAEPiJ,QAAQK,MAAMtJ,GACduH,EAAOkC,eACFne,KAAKqI,wBAAgB+V,MAAO1J,OAIrCuH,EAAOtF,GAAG,WAAW,KAEnBgH,QAAQW,gCAAgC9B,KAAMjN,qBAAwBkN,OACtER,EAAOkC,aAGTlC,EAAOtF,GAAG,OAAO,KACfgH,QAAQC,IAAI,cACPjmB,KAAKwkB,iBACRF,EAAOkC,aAIXlC,EAAOtF,GAAG,SAAS,KACjBgH,QAAQC,IAAI,kCAGRW,EAAkBtB,EAAa1T,gBACnC5R,KAAKqkB,YAAYxR,wBACjB7S,KAAKqkB,YAAYvS,eAAe,EAChC9R,KAAK+R,YAGPuS,EAAO/F,MAAMqI,MAIXC,EAAsB,UAErBzB,WAAWplB,KAAKwkB,gBAAkB7T,yBAAiBmW,eAAiBnW,yBAAiB0U,aAG5Fd,EAAWvF,GAAG,UAAW6H,GACzBtC,EAAWvF,GAAG,YAAa6H,GAE3BtC,EAAWvF,GAAG,cAAc,KACrBhf,KAAKwkB,kBACRD,EAAWS,WAAY,EACvBT,EAAWwC,kBACN3B,WAAWzU,yBAAiByT,kBAMrCG,EAAWvF,GAAG,SAAUjC,IACtBiJ,QAAQW,2BAA2B/O,0BAA8BmF,QAE5DqI,WAAWzU,yBAAiByT,mBAC5B/b,KAAKqI,wBAAgB+V,4BAA6B7O,4BAA+BmF,aAGnFwH,WAAaA,EAClBA,EAAWK,QAAQhN,GAMdmP,aAED/mB,KAAKukB,kBACFA,WAAWS,WAAY,OACvBT,WAAWwC,kBACXxC,WAAa,MAGhBvkB,KAAKskB,aACFA,OAAOkC,UAIRT,qBAAqB5U,MACvBA,EAAKlW,OAAS,UACT4V,GAAmBsV,aAGtBa,EAAehW,OAAOhM,KAAK,CAAC,IAAM,IAAM,EAAM,IAAM,IAAM,IAAM,IAAM,GAAM,WAEhEmM,EAAKtQ,MAAM,EAAG,IAEfomB,OAAOD,GAAgBnW,GAAmBqW,OAASrW,GAAmBsV,OAGjFO,gBAAgBxU,eACjB7J,KAAKqI,wBAAgByW,QAASjV,GAC3BA,EAAQ7D,WACToC,0BAAkB2W,iBAOfC,EAAgBrW,OAAOhM,KA7QN,eA8QlBohB,kBAAkBiB,cAGpB5W,0BAAkB6W,aACfC,EAAUlV,WAAWrN,KAAKkN,EAAQE,QAAQoV,KAC1CC,EAAMzW,OAAO0W,QAAQ1nB,KAAKqkB,YAAYxR,eAA8B0U,OACrErV,EAAQE,QAAQuV,UAAoB,IAARF,QAEzB,IAAIhT,2DAC6CzU,KAAKqkB,YAAYxR,eAAe2J,yBAAyB+K,EAAQ/K,cAItHtK,EAAQE,QAAQuV,UAClB3B,QAAQW,KACN,yGAEA3mB,KAAKqkB,YAAYxR,eACjB0U,QAIClD,YAAYxR,eAAiBR,WAAWrN,KAAKkN,EAAQE,QAAQwV,eAE5DzW,EAAOkB,WAAWrN,KAAKkN,EAAQE,QAAQjB,WACxCiV,kBAAkBjV,cAEpBV,0BAAkB0B,gBACf0V,KAAEA,EAAFC,kBAAQA,GAAsB5V,EAAQE,QACxCyV,SACGxD,YAAYzR,YAAciV,SAE3BE,EAAW/W,OAAOhM,KAAKkN,EAAQE,QAAQN,kBACxCuS,YAAYvS,YAAciW,EAASzW,aAAa,GACjDwW,SACGzD,YAAYvR,QAAUgV,QAExBzD,YAAYxR,eAAiBR,WAAWrN,KAAKkN,EAAQE,QAAQoV,UAC7Dnf,KAAKqI,wBAAgByB,UAAWnS,KAAKqkB,cAQxC+B,kBAAkBjV,QACnB9I,KAAKqI,wBAAgBsX,KAAM7W,GAG1BiU,WAAW6C,GAEbjoB,KAAKmkB,mBAAqB8D,SACvB9D,iBAAmB8D,OACnB5f,KAAKqI,wBAAgBwX,cAAeloB,KAAKmkB,2FC/Tbre,eASrCyC,2BARQ2b,sBACAtM,iBACAuM,iBAAmBxT,yBAAiByT,kBACpC+D,WAAa,OACbC,SAAW,eACXtV,QAAU,QACVuV,KAAmB,UAIpBnE,UAAY,eACZtM,KAAOhH,cAAM6T,QAMbC,mBACE1kB,KAAKmkB,iBAMPxB,oBACE,CACLuB,UAAWlkB,KAAKkkB,UAChBtM,KAAM5X,KAAK4X,MAIR+M,mBACE,CACL/R,YAAa5S,KAAKooB,SAClBvV,eAAgB7S,KAAKmoB,WACrBrV,QAAS9S,KAAK8S,uBAIG+R,EAAYjN,GAC/BoO,QAAQC,sBAAsBpB,KAAMjN,UAC/BsM,UAAYW,OACZjN,KAAOA,QAEN0Q,QAAaC,oDAAO,YAEpBjE,EAASgE,EAAKE,aAAa,CAAEC,MAxDrB,GAwDuCC,SAAU,EAAGlpB,KAAM,EAAGH,GAAI,IAAM0d,IAC/EA,GACFiJ,QAAQK,MAAMtJ,WAKbsL,KAAO/D,EAAOM,QACjB,CACE+D,QAAS3oB,KAAKkkB,UACdtM,KAAM5X,KAAK4X,MAEb,EACA,OACCmF,EAAU6L,KACL7L,EACFiJ,QAAQK,MAAMtJ,IAIhB6L,EAAQC,YACHxgB,KAAKqI,wBAAgBkV,cACrBR,WAAWzU,yBAAiBuV,oBAIhCmC,KAAKrJ,GAAG,WAAW,UAGjBmJ,WAAa,QAMZW,EAAS,IAAIR,EAAKS,OAAOC,KAAKC,UAJpB,CACd5a,KAAM,kBACNwD,OAAQ7R,KAAKmoB,aAEyCG,EAAKY,YAAYC,eACpEd,KAAKe,KAAK,EAAGN,WAGfT,KAAKrJ,GAAG,WAAY8J,UACjB3X,EAAO2X,EAAO3X,UACA,IAAhBA,EAAKlW,oBAIHouB,EAAalY,EAAKqL,SAAS,SAC3BtK,EAAU8W,KAAKM,MAAMD,IACrBE,eAAEA,GAAmBrX,KACvBqX,OAEGxC,8BAGF1e,KAAKqI,wBAAgByW,QAASjV,GAC3BA,EAAQ7D,WACT4E,2BAAmBuW,mBACjBrF,iBAAmBxT,yBAAiBuV,eACpCiC,WAAajW,EAAQL,YACrBuW,SAAWlW,EAAQ2V,UACnB/U,QAAUZ,EAAQY,aAClBzK,KAAKqI,wBAAgByB,UAAWnS,KAAK2kB,yBAEvC1R,2BAAmBwW,kBAChBrX,QAAEA,GAAYF,MAEfE,mBAEE2U,kBAIF2C,cAAcxX,EAASmX,SAEtBM,EAAW3Y,OAAOhM,KAAKoN,EAAS,eACjCgU,kBAAkBuD,cAGpB1W,2BAAmB2W,gBAInB3W,2BAAmB4W,cACjBH,cAAcxX,EAASmX,YAM7BhB,KAAKrJ,GAAG,cAAc,UACpB+H,qBAGF3B,WAAWzU,yBAAiB0U,YAG5B0B,aACD/mB,KAAKqoB,YACFA,KAAKtB,kBACLsB,KAAO,WAETjD,WAAWzU,yBAAiByT,cAG3BgC,kBAAkBjV,QACnB9I,KAAKqI,wBAAgBsX,KAAM7W,GAG1BiU,WAAW6C,GAEbjoB,KAAKmkB,mBAAqB8D,SACvB9D,iBAAmB8D,OACnB5f,KAAKqI,wBAAgBwX,cAAeloB,KAAKmkB,mBAI1CuF,cAAcxX,EAAkDmX,SAChExX,OAAEA,EAAFiY,YAAUA,GAAgB5X,KAE5BlS,KAAKmoB,aAAetW,EAAQ,OACxBkL,EAAM,IAAItI,gDAC4BzU,KAAKmoB,uBAAuBtW,eAAoBwX,KAE5FrD,QAAQW,KAAK5J,QACR1U,KAAKqI,wBAAgB+V,MAAO1J,QAG9BoL,WAAa2B,yDMzKa,0BPTJ,kCSuB7BvhB,YAAmBsM,EAAsCgH,WAZjDhH,kBACApM,SAAgC,UAChCshB,WAA+B,UAC/BC,mBACAC,aAA8B,UAC9BC,gBAAmC,IAAIlsB,OACvCmsB,mBAAyC,IAAI7hB,QAC7C8hB,cAA+B,IAAIvkB,QACnCwkB,cAA+B,IAAIja,QACnCka,cAA+B,IAAI7gB,QACjC8gB,qBAGa,iBAAV1V,OACJA,MAAQ,CACXX,OAAQhB,GAAeiB,KACvBW,SAAUD,QAEP,GAAIA,aAAiB7D,YACrB6D,MAAQ,CACXX,OAAQhB,GAAeqB,OACvBR,OAAQc,OAEL,CAAA,KAAIA,aAAiB2V,mBAMpB,IAAI/V,MAAM,yDALXI,MAAQ,CACXX,OAAQhB,GAAeqB,OACvBR,OAAQ/C,OAAOhM,KAAK6P,SAOnB0V,cAAgB,IAAIlb,GAAMwM,QAC1B0O,cAAc1a,SACjB7P,KAAKkqB,gBACLlqB,KAAKoqB,cACLpqB,KAAKmqB,mBACLnqB,KAAKsqB,cACLtqB,KAAKqqB,oBAEFL,OAAS,IAAIvI,QACbuI,OAAOhL,GAAGyB,uBAAewD,UAAWlpB,SAClCwvB,cAAcnsB,MAAMrD,WAGtBivB,OAAOhL,GAAGyB,uBAAeuD,iBAAkB3oB,SACzCkvB,cAAcpa,SAAS9U,MAIxBovB,SAASC,GAAe,MACG,OAA7B1qB,KAAKgqB,OAAOpH,0BAGV+H,EAAU/V,GAAY5U,KAAK6U,YAE5BoV,sBP6HPW,EACAvO,EACAwO,EAA0B,YAEpB/W,EAAM8W,EAAQ9W,QAEhBmW,EAA4B,OAAbY,GAAqBA,EAAW,EAAIA,EAAWD,EAAQ1V,sBACpE4V,EAAgBF,EAAQ1V,gBAAkB0V,EAAQxV,cAGlD2V,EAAwBxe,YAAUqe,EAAQjV,cAAehR,GAAS,IAAI0N,WAAW1N,EAAO,KAExFqmB,EAAoB,IAAI3Y,WAAW,QAClC4X,EAAea,GAAe,CACnCjX,GAAQC,EAAKkX,EAAmB,EAAG,EAAGf,SAChCzM,EAAcwN,EAAkB,GAChCjX,EAASgX,EAAsBvN,WACtByN,IAAXlX,SAEKkW,KAGLlW,EAAO9Y,OAAS6vB,EAAgBb,SAC3BA,KAGTpW,GAAQC,EAAKC,EAAQ,EAAGA,EAAO9Y,OAAQgvB,GAEpB5N,EAASmB,EADNrH,GAAaqH,EAAazJ,UAMhDkW,GAAgBlW,EAAO9Y,cAGlBgvB,EOjKeiB,CAClBP,GACA,CAACvU,EAAShE,MACHA,SAKA4X,OAAOjI,cAAc3L,EAAShE,GAC5BsY,GAA8C,OAA9B1qB,KAAKgqB,OAAOrH,gBAErC3iB,KAAKiqB,cAEPjU,GAAa2U,GAORhI,0BAEA8H,UAAS,GACPzqB,KAAKgqB,OAAOrH,cAGdF,6BACAgI,WACEzqB,KAAKgqB,OAAOvH,iBAGdG,yBACA6H,WACEzqB,KAAKgqB,OAAOpH,aAGdxB,wBACAqJ,WACEzqB,KAAKgqB,OAAO5I,YAGdyB,gCACA4H,WACEzqB,KAAKgqB,OAAOnH,oBAGdsI,cACDnrB,KAAK+pB,kBACA/pB,KAAK+pB,gBAGTU,iBAEC1vB,EAAWiF,KAAKgqB,OAAOrH,iBACZ,OAAb5nB,SACK,UAIJwvB,cAAcxa,gBACbhE,EAAS/L,KAAKsqB,cAAcvlB,QAC5BsL,EAASrQ,KAAKqqB,cAActlB,QAC5ByD,EAAcxI,KAAKmqB,mBAAmBplB,QACtCiH,EAAqBhM,KAAKgqB,OAAOxH,wBACjC4I,EAAUtf,GAAqB,CAAE/Q,SAAAA,EAAUgR,OAAAA,EAAQvD,YAAAA,EAAawD,mBAAAA,IAEhEqf,EAAQ,CACZrN,UAAWhe,KAAKgqB,OAAOzH,uBACvBvW,mBAAAA,EACAqE,OAAQA,EACR7H,YAAaA,EACbzC,OAAQ/F,KAAKoqB,cAAcrlB,QAC3BumB,aAActrB,KAAKkqB,gBAAgBnlB,QACnCqmB,QAASA,EACTG,aAA2C,OAA7BvrB,KAAKgqB,OAAOpH,qBAGK,OAA7B5iB,KAAKgqB,OAAOpH,oBAKTmH,WAAasB,GAGbA,EAGFG,iBACDxrB,KAAKyI,gBACAzI,KAAKyI,eAERkiB,EAAU/V,GAAY5U,KAAK6U,mBAC5BpM,kBPsSmBmiB,MACtBA,EAAQnV,gBAAkB,SAGrB,WAGH1B,EAAS,IAAI1B,WAAWuY,EAAQnV,gBAEtC5B,GAAQ+W,EAAQ9W,IAAKC,EAAQ,EAAGA,EAAO9Y,OAAQ2vB,EAAQpV,sBAEnD/M,EAAW,SAEbA,EAAW+I,SAAOuC,GAClB,MAAO0X,WAMFhjB,EO1TW+iB,CAAYb,GAC5B3U,GAAa2U,GACN3qB,KAAKyI,SAGPijB,2BACD1rB,KAAK6U,MAAMX,SAAWhB,GAAeiB,KAChC,cAGFnU,KAAK6U,MAAMC,YAAY,8DHtIC4G,GAOjCnT,YAAmB+G,EAAyCuM,SACpDvM,EAASuM,QAPT8P,YAA8B,UAC9Brc,oBAODA,QAAUG,OAAOC,OAAO,GAAI2L,GAAiB/L,QAC7C4O,kBAGC0N,cAAcxZ,GAEhBpS,KAAK2rB,kBACFA,YAAYpN,MAAMnM,GAInB8L,uBACDc,GAAGvD,uBAAe2B,KAAMjM,UACrBiF,QAAEA,EAAFhE,QAAWA,GAAYjB,SACrBiF,QACD3Q,gBAAQmQ,mBAENiW,sBACAD,cAAcxZ,cAEhB3M,gBAAQkV,cAENiR,cAAcxZ,QACd0Z,oCAGAF,cAAcxZ,OAapB2Z,4BACoB,OAArB/rB,KAAK2rB,YACAvN,UAAK4N,QAAQhsB,KAAK2rB,YAAYvN,QAEhC,KASF6N,sBACAH,iBASAI,eAAenxB,QACfuU,QAAUG,OAAOC,OAAO,GAAI1P,KAAKsP,QAASvU,GAGzC8wB,oBAEF7rB,KAAKsP,QAAQ2Q,YAAa,OACtBnL,EAAW9U,KAAKsP,QAAQ6Q,YAAYngB,KAAKsP,QAAQ4Q,WAAYnC,kBAC9D4N,YAAc,IAAIlO,GAAQ3I,EAAU9U,WAEpCqI,KAAKmY,2BAAmB2L,SAAUrX,IAInCgX,iBAEF9rB,KAAK2rB,mBAEFA,YAAYtN,YAAY,CAC3BR,gBAAiB7d,KAAKsP,QAAQuO,uBAE3B8N,YAAYvM,WAGZ/W,KAAKmY,2BAAmB4L,cAAepsB,KAAK2rB,YAAYvN,aAGxDuN,YAAc,2KI/ISjrB,MAC5BA,EAAgB,UACX,YAGDA,QACD,QACI,YACJ,QACI,YACJ,QACI,sBAEA"}