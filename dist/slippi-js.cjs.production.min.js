"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var e = require("lodash"),
  t = require("events"),
  r = require("fs"),
  s = require("moment"),
  n = require("stream"),
  o = require("@shelacek/ubjson"),
  a = require("net"),
  i = require("reconnect-core"),
  l = require("iconv-lite"),
  c = require("path"),
  u = require("semver");
function p(e) {
  return e && "object" == typeof e && "default" in e ? e : { default: e };
}
function T(e) {
  if (e && e.__esModule) return e;
  var t = Object.create(null);
  return (
    e &&
      Object.keys(e).forEach(function (r) {
        if ("default" !== r) {
          var s = Object.getOwnPropertyDescriptor(e, r);
          Object.defineProperty(
            t,
            r,
            s.get
              ? s
              : {
                  enumerable: !0,
                  get: function () {
                    return e[r];
                  },
                },
          );
        }
      }),
    (t.default = e),
    t
  );
}
var E,
  m,
  h = p(r),
  S = p(s),
  A = p(a),
  _ = p(i),
  d = p(l),
  f = p(c),
  R = p(u);
(exports.Character = void 0),
  ((E = exports.Character || (exports.Character = {}))[(E.CAPTAIN_FALCON = 0)] = "CAPTAIN_FALCON"),
  (E[(E.DONKEY_KONG = 1)] = "DONKEY_KONG"),
  (E[(E.FOX = 2)] = "FOX"),
  (E[(E.GAME_AND_WATCH = 3)] = "GAME_AND_WATCH"),
  (E[(E.KIRBY = 4)] = "KIRBY"),
  (E[(E.BOWSER = 5)] = "BOWSER"),
  (E[(E.LINK = 6)] = "LINK"),
  (E[(E.LUIGI = 7)] = "LUIGI"),
  (E[(E.MARIO = 8)] = "MARIO"),
  (E[(E.MARTH = 9)] = "MARTH"),
  (E[(E.MEWTWO = 10)] = "MEWTWO"),
  (E[(E.NESS = 11)] = "NESS"),
  (E[(E.PEACH = 12)] = "PEACH"),
  (E[(E.PIKACHU = 13)] = "PIKACHU"),
  (E[(E.ICE_CLIMBERS = 14)] = "ICE_CLIMBERS"),
  (E[(E.JIGGLYPUFF = 15)] = "JIGGLYPUFF"),
  (E[(E.SAMUS = 16)] = "SAMUS"),
  (E[(E.YOSHI = 17)] = "YOSHI"),
  (E[(E.ZELDA = 18)] = "ZELDA"),
  (E[(E.SHEIK = 19)] = "SHEIK"),
  (E[(E.FALCO = 20)] = "FALCO"),
  (E[(E.YOUNG_LINK = 21)] = "YOUNG_LINK"),
  (E[(E.DR_MARIO = 22)] = "DR_MARIO"),
  (E[(E.ROY = 23)] = "ROY"),
  (E[(E.PICHU = 24)] = "PICHU"),
  (E[(E.GANONDORF = 25)] = "GANONDORF"),
  (E[(E.MASTER_HAND = 26)] = "MASTER_HAND"),
  (E[(E.WIREFRAME_MALE = 27)] = "WIREFRAME_MALE"),
  (E[(E.WIREFRAME_FEMALE = 28)] = "WIREFRAME_FEMALE"),
  (E[(E.GIGA_BOWSER = 29)] = "GIGA_BOWSER"),
  (E[(E.CRAZY_HAND = 30)] = "CRAZY_HAND"),
  (E[(E.SANDBAG = 31)] = "SANDBAG"),
  (E[(E.POPO = 32)] = "POPO"),
  (exports.Stage = void 0),
  ((m = exports.Stage || (exports.Stage = {}))[(m.FOUNTAIN_OF_DREAMS = 2)] = "FOUNTAIN_OF_DREAMS"),
  (m[(m.POKEMON_STADIUM = 3)] = "POKEMON_STADIUM"),
  (m[(m.PEACHS_CASTLE = 4)] = "PEACHS_CASTLE"),
  (m[(m.KONGO_JUNGLE = 5)] = "KONGO_JUNGLE"),
  (m[(m.BRINSTAR = 6)] = "BRINSTAR"),
  (m[(m.CORNERIA = 7)] = "CORNERIA"),
  (m[(m.YOSHIS_STORY = 8)] = "YOSHIS_STORY"),
  (m[(m.ONETT = 9)] = "ONETT"),
  (m[(m.MUTE_CITY = 10)] = "MUTE_CITY"),
  (m[(m.RAINBOW_CRUISE = 11)] = "RAINBOW_CRUISE"),
  (m[(m.JUNGLE_JAPES = 12)] = "JUNGLE_JAPES"),
  (m[(m.GREAT_BAY = 13)] = "GREAT_BAY"),
  (m[(m.HYRULE_TEMPLE = 14)] = "HYRULE_TEMPLE"),
  (m[(m.BRINSTAR_DEPTHS = 15)] = "BRINSTAR_DEPTHS"),
  (m[(m.YOSHIS_ISLAND = 16)] = "YOSHIS_ISLAND"),
  (m[(m.GREEN_GREENS = 17)] = "GREEN_GREENS"),
  (m[(m.FOURSIDE = 18)] = "FOURSIDE"),
  (m[(m.MUSHROOM_KINGDOM = 19)] = "MUSHROOM_KINGDOM"),
  (m[(m.MUSHROOM_KINGDOM_2 = 20)] = "MUSHROOM_KINGDOM_2"),
  (m[(m.VENOM = 22)] = "VENOM"),
  (m[(m.POKE_FLOATS = 23)] = "POKE_FLOATS"),
  (m[(m.BIG_BLUE = 24)] = "BIG_BLUE"),
  (m[(m.ICICLE_MOUNTAIN = 25)] = "ICICLE_MOUNTAIN"),
  (m[(m.ICETOP = 26)] = "ICETOP"),
  (m[(m.FLAT_ZONE = 27)] = "FLAT_ZONE"),
  (m[(m.DREAMLAND = 28)] = "DREAMLAND"),
  (m[(m.YOSHIS_ISLAND_N64 = 29)] = "YOSHIS_ISLAND_N64"),
  (m[(m.KONGO_JUNGLE_N64 = 30)] = "KONGO_JUNGLE_N64"),
  (m[(m.BATTLEFIELD = 31)] = "BATTLEFIELD"),
  (m[(m.FINAL_DESTINATION = 32)] = "FINAL_DESTINATION"),
  (m[(m.TARGET_TEST_MARIO = 33)] = "TARGET_TEST_MARIO"),
  (m[(m.TARGET_TEST_CAPTAIN_FALCON = 34)] = "TARGET_TEST_CAPTAIN_FALCON"),
  (m[(m.TARGET_TEST_YOUNG_LINK = 35)] = "TARGET_TEST_YOUNG_LINK"),
  (m[(m.TARGET_TEST_DONKEY_KONG = 36)] = "TARGET_TEST_DONKEY_KONG"),
  (m[(m.TARGET_TEST_DR_MARIO = 37)] = "TARGET_TEST_DR_MARIO"),
  (m[(m.TARGET_TEST_FALCO = 38)] = "TARGET_TEST_FALCO"),
  (m[(m.TARGET_TEST_FOX = 39)] = "TARGET_TEST_FOX"),
  (m[(m.TARGET_TEST_ICE_CLIMBERS = 40)] = "TARGET_TEST_ICE_CLIMBERS"),
  (m[(m.TARGET_TEST_KIRBY = 41)] = "TARGET_TEST_KIRBY"),
  (m[(m.TARGET_TEST_BOWSER = 42)] = "TARGET_TEST_BOWSER"),
  (m[(m.TARGET_TEST_LINK = 43)] = "TARGET_TEST_LINK"),
  (m[(m.TARGET_TEST_LUIGI = 44)] = "TARGET_TEST_LUIGI"),
  (m[(m.TARGET_TEST_MARTH = 45)] = "TARGET_TEST_MARTH"),
  (m[(m.TARGET_TEST_MEWTWO = 46)] = "TARGET_TEST_MEWTWO"),
  (m[(m.TARGET_TEST_NESS = 47)] = "TARGET_TEST_NESS"),
  (m[(m.TARGET_TEST_PEACH = 48)] = "TARGET_TEST_PEACH"),
  (m[(m.TARGET_TEST_PICHU = 49)] = "TARGET_TEST_PICHU"),
  (m[(m.TARGET_TEST_PIKACHU = 50)] = "TARGET_TEST_PIKACHU"),
  (m[(m.TARGET_TEST_JIGGLYPUFF = 51)] = "TARGET_TEST_JIGGLYPUFF"),
  (m[(m.TARGET_TEST_SAMUS = 52)] = "TARGET_TEST_SAMUS"),
  (m[(m.TARGET_TEST_SHEIK = 53)] = "TARGET_TEST_SHEIK"),
  (m[(m.TARGET_TEST_YOSHI = 54)] = "TARGET_TEST_YOSHI"),
  (m[(m.TARGET_TEST_ZELDA = 55)] = "TARGET_TEST_ZELDA"),
  (m[(m.TARGET_TEST_GAME_AND_WATCH = 56)] = "TARGET_TEST_GAME_AND_WATCH"),
  (m[(m.TARGET_TEST_ROY = 57)] = "TARGET_TEST_ROY"),
  (m[(m.TARGET_TEST_GANONDORF = 58)] = "TARGET_TEST_GANONDORF"),
  (m[(m.HOME_RUN_CONTEST = 84)] = "HOME_RUN_CONTEST");
const C = { id: -1, name: "Unknown Character", shortName: "Unknown", colors: ["Default"] },
  N = [
    {
      id: exports.Character.CAPTAIN_FALCON,
      name: "Captain Falcon",
      shortName: "Falcon",
      colors: ["Default", "Black", "Red", "White", "Green", "Blue"],
    },
    {
      id: exports.Character.DONKEY_KONG,
      name: "Donkey Kong",
      shortName: "DK",
      colors: ["Default", "Black", "Red", "Blue", "Green"],
    },
    { id: exports.Character.FOX, name: "Fox", shortName: "Fox", colors: ["Default", "Red", "Blue", "Green"] },
    {
      id: exports.Character.GAME_AND_WATCH,
      name: "Mr. Game & Watch",
      shortName: "G&W",
      colors: ["Default", "Red", "Blue", "Green"],
    },
    {
      id: exports.Character.KIRBY,
      name: "Kirby",
      shortName: "Kirby",
      colors: ["Default", "Yellow", "Blue", "Red", "Green", "White"],
    },
    { id: exports.Character.BOWSER, name: "Bowser", shortName: "Bowser", colors: ["Default", "Red", "Blue", "Black"] },
    {
      id: exports.Character.LINK,
      name: "Link",
      shortName: "Link",
      colors: ["Default", "Red", "Blue", "Black", "White"],
    },
    { id: exports.Character.LUIGI, name: "Luigi", shortName: "Luigi", colors: ["Default", "White", "Blue", "Red"] },
    {
      id: exports.Character.MARIO,
      name: "Mario",
      shortName: "Mario",
      colors: ["Default", "Yellow", "Black", "Blue", "Green"],
    },
    {
      id: exports.Character.MARTH,
      name: "Marth",
      shortName: "Marth",
      colors: ["Default", "Red", "Green", "Black", "White"],
    },
    { id: exports.Character.MEWTWO, name: "Mewtwo", shortName: "Mewtwo", colors: ["Default", "Red", "Blue", "Green"] },
    { id: exports.Character.NESS, name: "Ness", shortName: "Ness", colors: ["Default", "Yellow", "Blue", "Green"] },
    {
      id: exports.Character.PEACH,
      name: "Peach",
      shortName: "Peach",
      colors: ["Default", "Daisy", "White", "Blue", "Green"],
    },
    {
      id: exports.Character.PIKACHU,
      name: "Pikachu",
      shortName: "Pikachu",
      colors: ["Default", "Red", "Party Hat", "Cowboy Hat"],
    },
    {
      id: exports.Character.ICE_CLIMBERS,
      name: "Ice Climbers",
      shortName: "ICs",
      colors: ["Default", "Green", "Orange", "Red"],
    },
    {
      id: exports.Character.JIGGLYPUFF,
      name: "Jigglypuff",
      shortName: "Puff",
      colors: ["Default", "Red", "Blue", "Headband", "Crown"],
    },
    {
      id: exports.Character.SAMUS,
      name: "Samus",
      shortName: "Samus",
      colors: ["Default", "Pink", "Black", "Green", "Purple"],
    },
    {
      id: exports.Character.YOSHI,
      name: "Yoshi",
      shortName: "Yoshi",
      colors: ["Default", "Red", "Blue", "Yellow", "Pink", "Cyan"],
    },
    {
      id: exports.Character.ZELDA,
      name: "Zelda",
      shortName: "Zelda",
      colors: ["Default", "Red", "Blue", "Green", "White"],
    },
    {
      id: exports.Character.SHEIK,
      name: "Sheik",
      shortName: "Sheik",
      colors: ["Default", "Red", "Blue", "Green", "White"],
    },
    { id: exports.Character.FALCO, name: "Falco", shortName: "Falco", colors: ["Default", "Red", "Blue", "Green"] },
    {
      id: exports.Character.YOUNG_LINK,
      name: "Young Link",
      shortName: "YLink",
      colors: ["Default", "Red", "Blue", "White", "Black"],
    },
    {
      id: exports.Character.DR_MARIO,
      name: "Dr. Mario",
      shortName: "Doc",
      colors: ["Default", "Red", "Blue", "Green", "Black"],
    },
    { id: exports.Character.ROY, name: "Roy", shortName: "Roy", colors: ["Default", "Red", "Blue", "Green", "Yellow"] },
    { id: exports.Character.PICHU, name: "Pichu", shortName: "Pichu", colors: ["Default", "Red", "Blue", "Green"] },
    {
      id: exports.Character.GANONDORF,
      name: "Ganondorf",
      shortName: "Ganon",
      colors: ["Default", "Red", "Blue", "Green", "Purple"],
    },
  ];
function g(e) {
  return N[e] || C;
}
var I = {
  __proto__: null,
  UnknownCharacter: C,
  getAllCharacters: function () {
    return N;
  },
  getCharacterInfo: g,
  getCharacterShortName: function (e) {
    return g(e).shortName;
  },
  getCharacterName: function (e) {
    return g(e).name;
  },
  getCharacterColorName: function (e, t) {
    return g(e).colors[t] || "Default";
  },
};
const x = { id: -1, name: "Unknown Move", shortName: "unknown" },
  O = {
    1: { id: 1, name: "Miscellaneous", shortName: "misc" },
    2: { id: 2, name: "Jab", shortName: "jab" },
    3: { id: 3, name: "Jab", shortName: "jab" },
    4: { id: 4, name: "Jab", shortName: "jab" },
    5: { id: 5, name: "Rapid Jabs", shortName: "rapid-jabs" },
    6: { id: 6, name: "Dash Attack", shortName: "dash" },
    7: { id: 7, name: "Forward Tilt", shortName: "ftilt" },
    8: { id: 8, name: "Up Tilt", shortName: "utilt" },
    9: { id: 9, name: "Down Tilt", shortName: "dtilt" },
    10: { id: 10, name: "Forward Smash", shortName: "fsmash" },
    11: { id: 11, name: "Up Smash", shortName: "usmash" },
    12: { id: 12, name: "Down Smash", shortName: "dsmash" },
    13: { id: 13, name: "Neutral Air", shortName: "nair" },
    14: { id: 14, name: "Forward Air", shortName: "fair" },
    15: { id: 15, name: "Back Air", shortName: "bair" },
    16: { id: 16, name: "Up Air", shortName: "uair" },
    17: { id: 17, name: "Down Air", shortName: "dair" },
    18: { id: 18, name: "Neutral B", shortName: "neutral-b" },
    19: { id: 19, name: "Side B", shortName: "side-b" },
    20: { id: 20, name: "Up B", shortName: "up-b" },
    21: { id: 21, name: "Down B", shortName: "down-b" },
    50: { id: 50, name: "Getup Attack", shortName: "getup" },
    51: { id: 51, name: "Getup Attack (Slow)", shortName: "getup-slow" },
    52: { id: 52, name: "Grab Pummel", shortName: "pummel" },
    53: { id: 53, name: "Forward Throw", shortName: "fthrow" },
    54: { id: 54, name: "Back Throw", shortName: "bthrow" },
    55: { id: 55, name: "Up Throw", shortName: "uthrow" },
    56: { id: 56, name: "Down Throw", shortName: "dthrow" },
    61: { id: 61, name: "Edge Attack (Slow)", shortName: "edge-slow" },
    62: { id: 62, name: "Edge Attack", shortName: "edge" },
  };
function D(e) {
  return O[e] || x;
}
var G = {
  __proto__: null,
  UnknownMove: x,
  getMoveInfo: D,
  getMoveShortName: function (e) {
    return D(e).shortName;
  },
  getMoveName: function (e) {
    return D(e).name;
  },
};
const F = { id: -1, name: "Unknown Stage" },
  y = {
    [exports.Stage.FOUNTAIN_OF_DREAMS]: { id: exports.Stage.FOUNTAIN_OF_DREAMS, name: "Fountain of Dreams" },
    [exports.Stage.POKEMON_STADIUM]: { id: exports.Stage.POKEMON_STADIUM, name: "Pokémon Stadium" },
    [exports.Stage.PEACHS_CASTLE]: { id: exports.Stage.PEACHS_CASTLE, name: "Princess Peach's Castle" },
    [exports.Stage.KONGO_JUNGLE]: { id: exports.Stage.KONGO_JUNGLE, name: "Kongo Jungle" },
    [exports.Stage.BRINSTAR]: { id: exports.Stage.BRINSTAR, name: "Brinstar" },
    [exports.Stage.CORNERIA]: { id: exports.Stage.CORNERIA, name: "Corneria" },
    [exports.Stage.YOSHIS_STORY]: { id: exports.Stage.YOSHIS_STORY, name: "Yoshi's Story" },
    [exports.Stage.ONETT]: { id: exports.Stage.ONETT, name: "Onett" },
    [exports.Stage.MUTE_CITY]: { id: exports.Stage.MUTE_CITY, name: "Mute City" },
    [exports.Stage.RAINBOW_CRUISE]: { id: exports.Stage.RAINBOW_CRUISE, name: "Rainbow Cruise" },
    [exports.Stage.JUNGLE_JAPES]: { id: exports.Stage.JUNGLE_JAPES, name: "Jungle Japes" },
    [exports.Stage.GREAT_BAY]: { id: exports.Stage.GREAT_BAY, name: "Great Bay" },
    [exports.Stage.HYRULE_TEMPLE]: { id: exports.Stage.HYRULE_TEMPLE, name: "Hyrule Temple" },
    [exports.Stage.BRINSTAR_DEPTHS]: { id: exports.Stage.BRINSTAR_DEPTHS, name: "Brinstar Depths" },
    [exports.Stage.YOSHIS_ISLAND]: { id: exports.Stage.YOSHIS_ISLAND, name: "Yoshi's Island" },
    [exports.Stage.GREEN_GREENS]: { id: exports.Stage.GREEN_GREENS, name: "Green Greens" },
    [exports.Stage.FOURSIDE]: { id: exports.Stage.FOURSIDE, name: "Fourside" },
    [exports.Stage.MUSHROOM_KINGDOM]: { id: exports.Stage.MUSHROOM_KINGDOM, name: "Mushroom Kingdom I" },
    [exports.Stage.MUSHROOM_KINGDOM_2]: { id: exports.Stage.MUSHROOM_KINGDOM_2, name: "Mushroom Kingdom II" },
    [exports.Stage.VENOM]: { id: exports.Stage.VENOM, name: "Venom" },
    [exports.Stage.POKE_FLOATS]: { id: exports.Stage.POKE_FLOATS, name: "Poké Floats" },
    [exports.Stage.BIG_BLUE]: { id: exports.Stage.BIG_BLUE, name: "Big Blue" },
    [exports.Stage.ICICLE_MOUNTAIN]: { id: exports.Stage.ICICLE_MOUNTAIN, name: "Icicle Mountain" },
    [exports.Stage.ICETOP]: { id: exports.Stage.ICETOP, name: "Icetop" },
    [exports.Stage.FLAT_ZONE]: { id: exports.Stage.FLAT_ZONE, name: "Flat Zone" },
    [exports.Stage.DREAMLAND]: { id: exports.Stage.DREAMLAND, name: "Dream Land N64" },
    [exports.Stage.YOSHIS_ISLAND_N64]: { id: exports.Stage.YOSHIS_ISLAND_N64, name: "Yoshi's Island N64" },
    [exports.Stage.KONGO_JUNGLE_N64]: { id: exports.Stage.KONGO_JUNGLE_N64, name: "Kongo Jungle N64" },
    [exports.Stage.BATTLEFIELD]: { id: exports.Stage.BATTLEFIELD, name: "Battlefield" },
    [exports.Stage.FINAL_DESTINATION]: { id: exports.Stage.FINAL_DESTINATION, name: "Final Destination" },
    [exports.Stage.TARGET_TEST_MARIO]: { id: exports.Stage.TARGET_TEST_MARIO, name: "Target Test (Mario)" },
    [exports.Stage.TARGET_TEST_CAPTAIN_FALCON]: {
      id: exports.Stage.TARGET_TEST_CAPTAIN_FALCON,
      name: "Target Test (Captain Falcon)",
    },
    [exports.Stage.TARGET_TEST_YOUNG_LINK]: {
      id: exports.Stage.TARGET_TEST_YOUNG_LINK,
      name: "Target Test (Young Link)",
    },
    [exports.Stage.TARGET_TEST_DONKEY_KONG]: {
      id: exports.Stage.TARGET_TEST_DONKEY_KONG,
      name: "Target Test (Donkey Kong)",
    },
    [exports.Stage.TARGET_TEST_DR_MARIO]: { id: exports.Stage.TARGET_TEST_DR_MARIO, name: "Target Test (Dr. Mario)" },
    [exports.Stage.TARGET_TEST_FALCO]: { id: exports.Stage.TARGET_TEST_FALCO, name: "Target Test (Falco)" },
    [exports.Stage.TARGET_TEST_FOX]: { id: exports.Stage.TARGET_TEST_FOX, name: "Target Test (Fox)" },
    [exports.Stage.TARGET_TEST_ICE_CLIMBERS]: {
      id: exports.Stage.TARGET_TEST_ICE_CLIMBERS,
      name: "Target Test (Ice Climbers)",
    },
    [exports.Stage.TARGET_TEST_KIRBY]: { id: exports.Stage.TARGET_TEST_KIRBY, name: "Target Test (Kirby)" },
    [exports.Stage.TARGET_TEST_BOWSER]: { id: exports.Stage.TARGET_TEST_BOWSER, name: "Target Test (Bowser)" },
    [exports.Stage.TARGET_TEST_LINK]: { id: exports.Stage.TARGET_TEST_LINK, name: "Target Test (Link)" },
    [exports.Stage.TARGET_TEST_LUIGI]: { id: exports.Stage.TARGET_TEST_LUIGI, name: "Target Test (Luigi)" },
    [exports.Stage.TARGET_TEST_MARTH]: { id: exports.Stage.TARGET_TEST_MARTH, name: "Target Test (Marth)" },
    [exports.Stage.TARGET_TEST_MEWTWO]: { id: exports.Stage.TARGET_TEST_MEWTWO, name: "Target Test (Mewtwo)" },
    [exports.Stage.TARGET_TEST_NESS]: { id: exports.Stage.TARGET_TEST_NESS, name: "Target Test (Ness)" },
    [exports.Stage.TARGET_TEST_PEACH]: { id: exports.Stage.TARGET_TEST_PEACH, name: "Target Test (Peach)" },
    [exports.Stage.TARGET_TEST_PICHU]: { id: exports.Stage.TARGET_TEST_PICHU, name: "Target Test (Pichu)" },
    [exports.Stage.TARGET_TEST_PIKACHU]: { id: exports.Stage.TARGET_TEST_PIKACHU, name: "Target Test (Pikachu)" },
    [exports.Stage.TARGET_TEST_JIGGLYPUFF]: {
      id: exports.Stage.TARGET_TEST_JIGGLYPUFF,
      name: "Target Test (Jigglypuff)",
    },
    [exports.Stage.TARGET_TEST_SAMUS]: { id: exports.Stage.TARGET_TEST_SAMUS, name: "Target Test (Samus)" },
    [exports.Stage.TARGET_TEST_SHEIK]: { id: exports.Stage.TARGET_TEST_SHEIK, name: "Target Test (Sheik)" },
    [exports.Stage.TARGET_TEST_YOSHI]: { id: exports.Stage.TARGET_TEST_YOSHI, name: "Target Test (Yoshi)" },
    [exports.Stage.TARGET_TEST_ZELDA]: { id: exports.Stage.TARGET_TEST_ZELDA, name: "Target Test (Zelda)" },
    [exports.Stage.TARGET_TEST_GAME_AND_WATCH]: {
      id: exports.Stage.TARGET_TEST_GAME_AND_WATCH,
      name: "Target Test (Mr. Game & Watch)",
    },
    [exports.Stage.TARGET_TEST_ROY]: { id: exports.Stage.TARGET_TEST_ROY, name: "Target Test (Roy)" },
    [exports.Stage.TARGET_TEST_GANONDORF]: { id: exports.Stage.TARGET_TEST_GANONDORF, name: "Target Test (Ganondorf)" },
    [exports.Stage.HOME_RUN_CONTEST]: { id: exports.Stage.HOME_RUN_CONTEST, name: "Home-Run Contest" },
  };
function M(e) {
  return y[e] || F;
}
var L,
  B = {
    __proto__: null,
    UnknownStage: F,
    getStageInfo: M,
    getStageName: function (e) {
      return M(e).name;
    },
  };
(exports.State = void 0),
  ((L = exports.State || (exports.State = {}))[(L.DAMAGE_START = 75)] = "DAMAGE_START"),
  (L[(L.DAMAGE_END = 91)] = "DAMAGE_END"),
  (L[(L.CAPTURE_START = 223)] = "CAPTURE_START"),
  (L[(L.CAPTURE_END = 232)] = "CAPTURE_END"),
  (L[(L.GUARD_START = 178)] = "GUARD_START"),
  (L[(L.GUARD_END = 182)] = "GUARD_END"),
  (L[(L.GROUNDED_CONTROL_START = 14)] = "GROUNDED_CONTROL_START"),
  (L[(L.GROUNDED_CONTROL_END = 24)] = "GROUNDED_CONTROL_END"),
  (L[(L.SQUAT_START = 39)] = "SQUAT_START"),
  (L[(L.SQUAT_END = 41)] = "SQUAT_END"),
  (L[(L.DOWN_START = 183)] = "DOWN_START"),
  (L[(L.DOWN_END = 198)] = "DOWN_END"),
  (L[(L.TECH_START = 199)] = "TECH_START"),
  (L[(L.TECH_END = 204)] = "TECH_END"),
  (L[(L.DYING_START = 0)] = "DYING_START"),
  (L[(L.DYING_END = 10)] = "DYING_END"),
  (L[(L.CONTROLLED_JUMP_START = 24)] = "CONTROLLED_JUMP_START"),
  (L[(L.CONTROLLED_JUMP_END = 34)] = "CONTROLLED_JUMP_END"),
  (L[(L.GROUND_ATTACK_START = 44)] = "GROUND_ATTACK_START"),
  (L[(L.GROUND_ATTACK_END = 64)] = "GROUND_ATTACK_END"),
  (L[(L.AERIAL_ATTACK_START = 65)] = "AERIAL_ATTACK_START"),
  (L[(L.AERIAL_ATTACK_END = 74)] = "AERIAL_ATTACK_END"),
  (L[(L.ROLL_FORWARD = 233)] = "ROLL_FORWARD"),
  (L[(L.ROLL_BACKWARD = 234)] = "ROLL_BACKWARD"),
  (L[(L.SPOT_DODGE = 235)] = "SPOT_DODGE"),
  (L[(L.AIR_DODGE = 236)] = "AIR_DODGE"),
  (L[(L.ACTION_WAIT = 14)] = "ACTION_WAIT"),
  (L[(L.ACTION_DASH = 20)] = "ACTION_DASH"),
  (L[(L.ACTION_KNEE_BEND = 24)] = "ACTION_KNEE_BEND"),
  (L[(L.GUARD_ON = 178)] = "GUARD_ON"),
  (L[(L.TECH_MISS_UP = 183)] = "TECH_MISS_UP"),
  (L[(L.TECH_MISS_DOWN = 191)] = "TECH_MISS_DOWN"),
  (L[(L.NEUTRAL_TECH = 199)] = "NEUTRAL_TECH"),
  (L[(L.FORWARD_TECH = 200)] = "FORWARD_TECH"),
  (L[(L.BACKWARD_TECH = 201)] = "BACKWARD_TECH"),
  (L[(L.WALL_TECH = 202)] = "WALL_TECH"),
  (L[(L.MISSED_WALL_TECH = 247)] = "MISSED_WALL_TECH"),
  (L[(L.DASH = 20)] = "DASH"),
  (L[(L.TURN = 18)] = "TURN"),
  (L[(L.LANDING_FALL_SPECIAL = 43)] = "LANDING_FALL_SPECIAL"),
  (L[(L.JUMP_FORWARD = 25)] = "JUMP_FORWARD"),
  (L[(L.JUMP_BACKWARD = 26)] = "JUMP_BACKWARD"),
  (L[(L.FALL_FORWARD = 30)] = "FALL_FORWARD"),
  (L[(L.FALL_BACKWARD = 31)] = "FALL_BACKWARD"),
  (L[(L.GRAB = 212)] = "GRAB"),
  (L[(L.GRAB_WAIT = 216)] = "GRAB_WAIT"),
  (L[(L.PUMMEL = 217)] = "PUMMEL"),
  (L[(L.CLIFF_CATCH = 252)] = "CLIFF_CATCH"),
  (L[(L.THROW_UP = 221)] = "THROW_UP"),
  (L[(L.THROW_FORWARD = 219)] = "THROW_FORWARD"),
  (L[(L.THROW_DOWN = 222)] = "THROW_DOWN"),
  (L[(L.THROW_BACK = 220)] = "THROW_BACK"),
  (L[(L.DAMAGE_FALL = 38)] = "DAMAGE_FALL"),
  (L[(L.BARREL_WAIT = 293)] = "BARREL_WAIT"),
  (L[(L.COMMAND_GRAB_RANGE1_START = 266)] = "COMMAND_GRAB_RANGE1_START"),
  (L[(L.COMMAND_GRAB_RANGE1_END = 304)] = "COMMAND_GRAB_RANGE1_END"),
  (L[(L.COMMAND_GRAB_RANGE2_START = 327)] = "COMMAND_GRAB_RANGE2_START"),
  (L[(L.COMMAND_GRAB_RANGE2_END = 338)] = "COMMAND_GRAB_RANGE2_END");
const P = { PUNISH_RESET_FRAMES: 45, RECOVERY_RESET_FRAMES: 45, COMBO_STRING_RESET_FRAMES: 45 };
function U(e) {
  return e && 2 === e.players.length
    ? [
        { playerIndex: e.players[0].playerIndex, opponentIndex: e.players[1].playerIndex },
        { playerIndex: e.players[1].playerIndex, opponentIndex: e.players[0].playerIndex },
      ]
    : [];
}
function v(e, t) {
  return !(!e || !t) && t.stocksRemaining - e.stocksRemaining > 0;
}
function w(e) {
  const t = e >= exports.State.GROUNDED_CONTROL_START && e <= exports.State.GROUNDED_CONTROL_END,
    r = e >= exports.State.SQUAT_START && e <= exports.State.SQUAT_END,
    s = e > exports.State.GROUND_ATTACK_START && e <= exports.State.GROUND_ATTACK_END,
    n = e === exports.State.GRAB;
  return t || r || s || n;
}
function k(e) {
  return e >= exports.State.TECH_START && e <= exports.State.TECH_END;
}
function H(e) {
  return e >= exports.State.DOWN_START && e <= exports.State.DOWN_END;
}
function b(e) {
  return (e >= exports.State.DAMAGE_START && e <= exports.State.DAMAGE_END) || e === exports.State.DAMAGE_FALL;
}
function W(e) {
  return e >= exports.State.CAPTURE_START && e <= exports.State.CAPTURE_END;
}
function K(e) {
  return (
    ((e >= exports.State.COMMAND_GRAB_RANGE1_START && e <= exports.State.COMMAND_GRAB_RANGE1_END) ||
      (e >= exports.State.COMMAND_GRAB_RANGE2_START && e <= exports.State.COMMAND_GRAB_RANGE2_END)) &&
    e !== exports.State.BARREL_WAIT
  );
}
function Y(e) {
  return e >= exports.State.DYING_START && e <= exports.State.DYING_END;
}
function J(e, t) {
  var r, s;
  return (null != (r = e.percent) ? r : 0) - (null != (s = t.percent) ? s : 0);
}
const z = [exports.State.DASH, exports.State.TURN, exports.State.DASH];
class $ {
  constructor() {
    (this.playerPermutations = new Array()), (this.state = new Map());
  }
  setup(e) {
    (this.state = new Map()),
      (this.playerPermutations = U(e)),
      this.playerPermutations.forEach((e) => {
        this.state.set(e, {
          playerCounts: {
            playerIndex: e.playerIndex,
            wavedashCount: 0,
            wavelandCount: 0,
            airDodgeCount: 0,
            dashDanceCount: 0,
            spotDodgeCount: 0,
            ledgegrabCount: 0,
            rollCount: 0,
            lCancelCount: { success: 0, fail: 0 },
            grabCount: { success: 0, fail: 0 },
            throwCount: { up: 0, forward: 0, back: 0, down: 0 },
            groundTechCount: { away: 0, in: 0, neutral: 0, fail: 0 },
            wallTechCount: { success: 0, fail: 0 },
          },
          animations: [],
        });
      });
  }
  processFrame(t) {
    this.playerPermutations.forEach((r) => {
      const s = this.state.get(r);
      s &&
        (function (t, r, s) {
          const n = s.players[r.playerIndex].post,
            o = s.players[r.opponentIndex].post,
            a = (r, s) => {
              if (!s) return;
              const n = e.get(t.playerCounts, r, 0);
              e.set(t.playerCounts, r, n + 1);
            },
            i = n.actionStateId;
          t.animations.push(i);
          const l = t.animations.slice(-3),
            c = l[l.length - 2],
            u = i !== c;
          a("dashDanceCount", e.isEqual(l, z));
          const p = (function (e, t) {
            const r = j(e),
              s = j(t);
            return r && !s;
          })(i, c);
          a("rollCount", p);
          const T = (function (e, t) {
            const r = Z(e),
              s = Z(t);
            return r && !s;
          })(i, c);
          a("spotDodgeCount", T);
          const E = (function (e, t) {
            const r = X(e),
              s = X(t);
            return r && !s;
          })(i, c);
          a("airDodgeCount", E);
          const m = (function (e, t) {
            const r = V(e),
              s = V(t);
            return r && !s;
          })(i, c);
          a("ledgegrabCount", m);
          const h = (function (e, t) {
            return t === exports.State.GRAB && e <= exports.State.GRAB_WAIT && e > exports.State.GRAB;
          })(i, c);
          a("grabCount.success", h);
          const S = (function (e, t) {
            return t === exports.State.GRAB && (e > exports.State.GRAB_WAIT || e < exports.State.GRAB);
          })(i, c);
          if (
            (a("grabCount.fail", S),
            a("throwCount.up", i === exports.State.THROW_UP && u),
            a("throwCount.forward", i === exports.State.THROW_FORWARD && u),
            a("throwCount.down", i === exports.State.THROW_DOWN && u),
            a("throwCount.back", i === exports.State.THROW_BACK && u),
            u)
          ) {
            a("groundTechCount.fail", (A = i) === exports.State.TECH_MISS_DOWN || A === exports.State.TECH_MISS_UP);
            let e = 1,
              t = !1;
            n.positionX > o.positionX && (e = -1),
              n.facingDirection == e && (t = !0),
              a("groundTechCount.in", i === exports.State.FORWARD_TECH && t),
              a("groundTechCount.in", i === exports.State.BACKWARD_TECH && !t),
              a("groundTechCount.neutral", i === exports.State.NEUTRAL_TECH),
              a("groundTechCount.away", i === exports.State.BACKWARD_TECH && t),
              a("groundTechCount.away", i === exports.State.FORWARD_TECH && !t),
              a("wallTechCount.success", i === exports.State.WALL_TECH),
              a("wallTechCount.fail", i === exports.State.MISSED_WALL_TECH);
          }
          var A;
          (function (e) {
            return e >= exports.State.AERIAL_ATTACK_START && e <= exports.State.AERIAL_ATTACK_END;
          })(i) && (a("lCancelCount.success", 1 === n.lCancelStatus), a("lCancelCount.fail", 2 === n.lCancelStatus)),
            (function (t, r) {
              const s = e.last(r) === exports.State.LANDING_FALL_SPECIAL,
                n = (function (e) {
                  if (e === exports.State.AIR_DODGE) return !0;
                  const t = e >= exports.State.CONTROLLED_JUMP_START,
                    r = e <= exports.State.CONTROLLED_JUMP_END;
                  return t && r;
                })(r[r.length - 2]);
              if (!s || !n) return;
              const o = r.slice(-8),
                a = e.keyBy(o, (e) => e);
              (2 === e.size(a) && a[exports.State.AIR_DODGE]) ||
                (a[exports.State.AIR_DODGE] && (t.airDodgeCount -= 1),
                a[exports.State.ACTION_KNEE_BEND] ? (t.wavedashCount += 1) : (t.wavelandCount += 1));
            })(t.playerCounts, t.animations);
        })(s, r, t);
    });
  }
  fetch() {
    return Array.from(this.state.values()).map((e) => e.playerCounts);
  }
}
function j(e) {
  return e === exports.State.ROLL_BACKWARD || e === exports.State.ROLL_FORWARD;
}
function Z(e) {
  return e === exports.State.SPOT_DODGE;
}
function X(e) {
  return e === exports.State.AIR_DODGE;
}
function V(e) {
  return e === exports.State.CLIFF_CATCH;
}
var q, Q, ee, te, re;
!(function (e) {
  (e.COMBO_START = "COMBO_START"), (e.COMBO_EXTEND = "COMBO_EXTEND"), (e.COMBO_END = "COMBO_END");
})(q || (q = {}));
class se extends t.EventEmitter {
  constructor(...e) {
    super(...e),
      (this.playerPermutations = new Array()),
      (this.state = new Map()),
      (this.combos = new Array()),
      (this.settings = null);
  }
  setup(e) {
    (this.settings = e),
      (this.state = new Map()),
      (this.combos = []),
      (this.playerPermutations = U(e)),
      this.playerPermutations.forEach((e) => {
        this.state.set(e, { combo: null, move: null, resetCounter: 0, lastHitAnimation: null, event: null });
      });
  }
  processFrame(t, r) {
    this.playerPermutations.forEach((s) => {
      const n = this.state.get(s);
      n &&
        ((function (e, t, r, s, n) {
          const o = s.frame,
            a = s.players[r.playerIndex].post,
            i = s.players[r.opponentIndex].post,
            l = o - 1;
          let c = null,
            u = null;
          e[l] && ((c = e[l].players[r.playerIndex].post), (u = e[l].players[r.opponentIndex].post));
          const p = i.actionStateId,
            T = b(p),
            E = W(p),
            m = K(p),
            h = u ? J(i, u) : 0;
          if (
            ((a.actionStateId !== t.lastHitAnimation || a.actionStateCounter < (c ? c.actionStateCounter : 0)) &&
              (t.lastHitAnimation = null),
            T || E || m)
          ) {
            let e = !1;
            var S, A;
            t.combo ||
              ((t.combo = {
                playerIndex: r.opponentIndex,
                startFrame: o,
                endFrame: null,
                startPercent: u && null != (S = u.percent) ? S : 0,
                currentPercent: null != (A = i.percent) ? A : 0,
                endPercent: null,
                moves: [],
                didKill: !1,
                lastHitBy: r.playerIndex,
              }),
              n.push(t.combo),
              (e = !0)),
              h &&
                (null === t.lastHitAnimation &&
                  ((t.move = {
                    playerIndex: r.playerIndex,
                    frame: o,
                    moveId: a.lastAttackLanded,
                    hitCount: 0,
                    damage: 0,
                  }),
                  t.combo.moves.push(t.move),
                  e || (t.event = q.COMBO_EXTEND)),
                t.move && ((t.move.hitCount += 1), (t.move.damage += h)),
                (t.lastHitAnimation = c ? c.actionStateId : null)),
              e && (t.event = q.COMBO_START);
          }
          if (!t.combo) return;
          const _ = k(p),
            d = H(p),
            f = u && v(i, u),
            R = Y(p);
          var C;
          f || (t.combo.currentPercent = null != (C = i.percent) ? C : 0),
            T || E || m || _ || d || R ? (t.resetCounter = 0) : (t.resetCounter += 1);
          let N = !1;
          var g;
          f && ((t.combo.didKill = !0), (N = !0)),
            t.resetCounter > P.COMBO_STRING_RESET_FRAMES && (N = !0),
            N &&
              ((t.combo.endFrame = a.frame),
              (t.combo.endPercent = u && null != (g = u.percent) ? g : 0),
              (t.event = q.COMBO_END),
              (t.combo = null),
              (t.move = null));
        })(r, n, s, t, this.combos),
        null !== n.event &&
          (this.emit(n.event, { combo: e.last(this.combos), settings: this.settings }), (n.event = null)));
    });
  }
  fetch() {
    return this.combos;
  }
}
class ne extends t.EventEmitter {
  constructor() {
    super(),
      (this.playerPermutations = new Array()),
      (this.conversions = new Array()),
      (this.state = new Map()),
      (this.metadata = void 0),
      (this.settings = null),
      (this.metadata = { lastEndFrameByOppIdx: {} });
  }
  setup(e) {
    (this.playerPermutations = U(e)),
      (this.conversions = []),
      (this.state = new Map()),
      (this.metadata = { lastEndFrameByOppIdx: {} }),
      (this.settings = e),
      this.playerPermutations.forEach((e) => {
        this.state.set(e, { conversion: null, move: null, resetCounter: 0, lastHitAnimation: null });
      });
  }
  processFrame(t, r) {
    this.playerPermutations.forEach((s) => {
      const n = this.state.get(s);
      if (n) {
        const o = (function (e, t, r, s, n) {
          const o = s.frame,
            a = s.players[r.playerIndex].post,
            i = s.players[r.opponentIndex].post,
            l = o - 1;
          let c = null,
            u = null;
          e[l] && ((c = e[l].players[r.playerIndex].post), (u = e[l].players[r.opponentIndex].post));
          const p = i.actionStateId,
            T = b(p),
            E = W(p),
            m = K(p),
            h = u ? J(i, u) : 0;
          var S, A;
          if (
            ((a.actionStateId !== t.lastHitAnimation || a.actionStateCounter < (c ? c.actionStateCounter : 0)) &&
              (t.lastHitAnimation = null),
            (T || E || m) &&
              (t.conversion ||
                ((t.conversion = {
                  playerIndex: r.opponentIndex,
                  lastHitBy: r.playerIndex,
                  startFrame: o,
                  endFrame: null,
                  startPercent: u && null != (S = u.percent) ? S : 0,
                  currentPercent: null != (A = i.percent) ? A : 0,
                  endPercent: null,
                  moves: [],
                  didKill: !1,
                  openingType: "unknown",
                }),
                n.push(t.conversion)),
              h &&
                (null === t.lastHitAnimation &&
                  ((t.move = {
                    playerIndex: r.playerIndex,
                    frame: o,
                    moveId: a.lastAttackLanded,
                    hitCount: 0,
                    damage: 0,
                  }),
                  t.conversion.moves.push(t.move)),
                t.move && ((t.move.hitCount += 1), (t.move.damage += h)),
                (t.lastHitAnimation = c ? c.actionStateId : null))),
            !t.conversion)
          )
            return !1;
          const _ = w(p),
            d = u && v(i, u);
          var f;
          d || (t.conversion.currentPercent = null != (f = i.percent) ? f : 0),
            (T || E || m) && (t.resetCounter = 0),
            ((0 === t.resetCounter && _) || t.resetCounter > 0) && (t.resetCounter += 1);
          let R = !1;
          var C;
          return (
            d && ((t.conversion.didKill = !0), (R = !0)),
            t.resetCounter > P.PUNISH_RESET_FRAMES && (R = !0),
            R &&
              ((t.conversion.endFrame = a.frame),
              (t.conversion.endPercent = u && null != (C = u.percent) ? C : 0),
              (t.conversion = null),
              (t.move = null)),
            R
          );
        })(r, n, s, t, this.conversions);
        o && this.emit("CONVERSION", { combo: e.last(this.conversions), settings: this.settings });
      }
    });
  }
  fetch() {
    return this._populateConversionTypes(), this.conversions;
  }
  _populateConversionTypes() {
    const t = e.filter(this.conversions, (e) => "unknown" === e.openingType),
      r = e.groupBy(t, "startFrame");
    e.orderBy(r, (t) => e.get(t, [0, "startFrame"])).forEach((t) => {
      const r = t.length >= 2;
      t.forEach((t) => {
        if (((this.metadata.lastEndFrameByOppIdx[t.playerIndex] = t.endFrame), r))
          return void (t.openingType = "trade");
        const s = e.last(t.moves),
          n = this.metadata.lastEndFrameByOppIdx[s ? s.playerIndex : t.playerIndex];
        t.openingType = n && n > t.startFrame ? "counter-attack" : "neutral-win";
      });
    });
  }
}
(exports.Command = void 0),
  ((Q = exports.Command || (exports.Command = {}))[(Q.MESSAGE_SIZES = 53)] = "MESSAGE_SIZES"),
  (Q[(Q.GAME_START = 54)] = "GAME_START"),
  (Q[(Q.PRE_FRAME_UPDATE = 55)] = "PRE_FRAME_UPDATE"),
  (Q[(Q.POST_FRAME_UPDATE = 56)] = "POST_FRAME_UPDATE"),
  (Q[(Q.GAME_END = 57)] = "GAME_END"),
  (Q[(Q.ITEM_UPDATE = 59)] = "ITEM_UPDATE"),
  (Q[(Q.FRAME_BOOKEND = 60)] = "FRAME_BOOKEND"),
  (exports.GameMode = void 0),
  ((ee = exports.GameMode || (exports.GameMode = {}))[(ee.VS = 2)] = "VS"),
  (ee[(ee.ONLINE = 8)] = "ONLINE"),
  (exports.Frames = void 0),
  ((te = exports.Frames || (exports.Frames = {}))[(te.FIRST = -123)] = "FIRST"),
  (te[(te.FIRST_PLAYABLE = -39)] = "FIRST_PLAYABLE"),
  (function (e) {
    (e[(e.DZ = 0)] = "DZ"),
      (e[(e.NE = 1)] = "NE"),
      (e[(e.SE = 2)] = "SE"),
      (e[(e.SW = 3)] = "SW"),
      (e[(e.NW = 4)] = "NW"),
      (e[(e.N = 5)] = "N"),
      (e[(e.E = 6)] = "E"),
      (e[(e.S = 7)] = "S"),
      (e[(e.W = 8)] = "W");
  })(re || (re = {}));
class oe {
  constructor() {
    (this.state = new Map()), (this.playerPermutations = new Array());
  }
  setup(e) {
    (this.state = new Map()),
      (this.playerPermutations = U(e)),
      this.playerPermutations.forEach((e) => {
        this.state.set(e, {
          playerIndex: e.playerIndex,
          opponentIndex: e.opponentIndex,
          inputCount: 0,
          joystickInputCount: 0,
          cstickInputCount: 0,
          buttonInputCount: 0,
          triggerInputCount: 0,
        });
      });
  }
  processFrame(e, t) {
    this.playerPermutations.forEach((r) => {
      const s = this.state.get(r);
      s &&
        (function (e, t, r, s) {
          const n = s.players[r.playerIndex].pre,
            o = n.frame,
            a = o - 1,
            i = e[a] ? e[a].players[r.playerIndex].pre : null;
          if (o < exports.Frames.FIRST_PLAYABLE || !i) return;
          const l = (function (e) {
            let t,
              r = e;
            for (t = 0; r; t += 1) r &= r - 1;
            return t;
          })(~i.physicalButtons & n.physicalButtons & 4095);
          (t.inputCount += l), (t.buttonInputCount += l);
          const c = ae(i.joystickX, i.joystickY),
            u = ae(n.joystickX, n.joystickY);
          c !== u && u !== re.DZ && ((t.inputCount += 1), (t.joystickInputCount += 1));
          const p = ae(i.cStickX, i.cStickY),
            T = ae(n.cStickX, n.cStickY);
          p !== T && T !== re.DZ && ((t.inputCount += 1), (t.cstickInputCount += 1)),
            i.physicalLTrigger < 0.3 && n.physicalLTrigger >= 0.3 && ((t.inputCount += 1), (t.triggerInputCount += 1)),
            i.physicalRTrigger < 0.3 && n.physicalRTrigger >= 0.3 && ((t.inputCount += 1), (t.triggerInputCount += 1));
        })(t, s, r, e);
    });
  }
  fetch() {
    return Array.from(this.state.values());
  }
}
function ae(e, t) {
  let r = re.DZ;
  return (
    e >= 0.2875 && t >= 0.2875
      ? (r = re.NE)
      : e >= 0.2875 && t <= -0.2875
      ? (r = re.SE)
      : e <= -0.2875 && t <= -0.2875
      ? (r = re.SW)
      : e <= -0.2875 && t >= 0.2875
      ? (r = re.NW)
      : t >= 0.2875
      ? (r = re.N)
      : e >= 0.2875
      ? (r = re.E)
      : t <= -0.2875
      ? (r = re.S)
      : e <= -0.2875 && (r = re.W),
    r
  );
}
function ie({ settings: t, inputs: r, conversions: s, playableFrameCount: n }) {
  const o = e.keyBy(r, "playerIndex"),
    a = s,
    i = e.groupBy(s, (e) => {
      var t;
      return null == (t = e.moves[0]) ? void 0 : t.playerIndex;
    }),
    l = e.mapValues(i, (t) => e.groupBy(t, "openingType")),
    c = n / 3600;
  return t.players.map((r) => {
    const s = r.playerIndex,
      n = e.get(o, s) || {},
      i = {
        buttons: e.get(n, "buttonInputCount"),
        triggers: e.get(n, "triggerInputCount"),
        cstick: e.get(n, "cstickInputCount"),
        joystick: e.get(n, "joystickInputCount"),
        total: e.get(n, "inputCount"),
      };
    let u = 0,
      p = 0;
    const T = t.players
      .filter((e) => e.playerIndex !== s && (!t.isTeams || e.teamId !== r.teamId))
      .map((e) => e.playerIndex);
    let E = 0,
      m = 0;
    return (
      a
        .filter((e) => e.playerIndex !== s)
        .forEach((e) => {
          u++,
            e.didKill && e.lastHitBy === s && (m += 1),
            e.moves.length > 1 && e.moves[0].playerIndex === s && p++,
            e.moves.forEach((e) => {
              e.playerIndex === s && (E += e.damage);
            });
        }),
      {
        playerIndex: s,
        inputCounts: i,
        conversionCount: u,
        totalDamage: E,
        killCount: m,
        successfulConversions: le(p, u),
        inputsPerMinute: le(i.total, c),
        digitalInputsPerMinute: le(i.buttons, c),
        openingsPerKill: le(u, m),
        damagePerOpening: le(E, u),
        neutralWinRatio: ce(l, s, T, "neutral-win"),
        counterHitRatio: ce(l, s, T, "counter-attack"),
        beneficialTradeRatio: ue(l, s, T),
      }
    );
  });
}
function le(e, t) {
  return { count: e, total: t, ratio: t ? e / t : null };
}
function ce(t, r, s, n) {
  const o = e.get(t, [r, n]) || [],
    a = e.flatten(s.map((r) => e.get(t, [r, n]) || []));
  return le(o.length, o.length + a.length);
}
function ue(t, r, s) {
  const n = e.get(t, [r, "trade"]) || [],
    o = e.flatten(s.map((r) => e.get(t, [r, "trade"]) || [])),
    a = [];
  return (
    e.zip(n, o).forEach((t) => {
      const r = e.first(t),
        s = e.last(t);
      if (r && s) {
        const e = r.currentPercent - r.startPercent,
          t = s.currentPercent - s.startPercent;
        ((r.didKill && !s.didKill) || e > t) && a.push(r);
      }
    }),
    le(a.length, n.length)
  );
}
const pe = { processOnTheFly: !1 };
class Te {
  constructor(e) {
    (this.options = void 0),
      (this.lastProcessedFrame = null),
      (this.frames = {}),
      (this.players = []),
      (this.allComputers = new Array()),
      (this.options = Object.assign({}, pe, e));
  }
  setup(e) {
    (this.frames = {}),
      (this.players = e.players.map((e) => e.playerIndex)),
      this.allComputers.forEach((t) => t.setup(e));
  }
  register(...e) {
    this.allComputers.push(...e);
  }
  process() {
    if (0 === this.players.length) return;
    let e = null !== this.lastProcessedFrame ? this.lastProcessedFrame + 1 : exports.Frames.FIRST;
    for (; this.frames[e]; ) {
      const t = this.frames[e];
      if (!Ee(this.players, t)) return;
      this.allComputers.forEach((e) => e.processFrame(t, this.frames)), (this.lastProcessedFrame = e), e++;
    }
  }
  addFrame(e) {
    (this.frames[e.frame] = e), this.options.processOnTheFly && this.process();
  }
}
function Ee(t, r) {
  if (!r) return !1;
  for (const s of t) if (!e.get(r, ["players", s, "post"])) return !1;
  return !0;
}
class me {
  constructor() {
    (this.state = new Map()), (this.playerPermutations = new Array()), (this.stocks = new Array());
  }
  setup(e) {
    (this.state = new Map()),
      (this.playerPermutations = U(e)),
      (this.stocks = []),
      this.playerPermutations.forEach((e) => {
        this.state.set(e, { stock: null });
      });
  }
  processFrame(e, t) {
    this.playerPermutations.forEach((r) => {
      const s = this.state.get(r);
      s &&
        (function (e, t, r, s, n) {
          const o = s.players[r.playerIndex].post,
            a = o.frame,
            i = a - 1,
            l = e[i] ? e[i].players[r.playerIndex].post : null;
          if (t.stock)
            if (l && v(o, l)) {
              var c;
              (t.stock.endFrame = o.frame),
                (t.stock.endPercent = null != (c = l.percent) ? c : 0),
                (t.stock.deathAnimation = o.actionStateId),
                (t.stock = null);
            } else {
              var u;
              t.stock.currentPercent = null != (u = o.percent) ? u : 0;
            }
          else {
            if (Y(o.actionStateId)) return;
            (t.stock = {
              playerIndex: r.playerIndex,
              startFrame: a,
              endFrame: null,
              startPercent: 0,
              endPercent: null,
              currentPercent: 0,
              count: o.stocksRemaining,
              deathAnimation: null,
            }),
              n.push(t.stock);
          }
        })(t, s, r, e, this.stocks);
    });
  }
  fetch() {
    return this.stocks;
  }
}
var he, Se, Ae, _e, de;
(exports.CommunicationType = void 0),
  ((he = exports.CommunicationType || (exports.CommunicationType = {}))[(he.HANDSHAKE = 1)] = "HANDSHAKE"),
  (he[(he.REPLAY = 2)] = "REPLAY"),
  (he[(he.KEEP_ALIVE = 3)] = "KEEP_ALIVE");
class fe {
  constructor() {
    (this.receiveBuf = Buffer.from([])), (this.messages = new Array());
  }
  receive(e) {
    for (this.receiveBuf = Buffer.concat([this.receiveBuf, e]); this.receiveBuf.length >= 4; ) {
      const e = this.receiveBuf.readUInt32BE(0);
      if (this.receiveBuf.length < e + 4) return;
      const t = this.receiveBuf.slice(4, e + 4);
      this.messages.push(o.decode(t)), (this.receiveBuf = this.receiveBuf.slice(e + 4));
    }
  }
  getReceiveBuffer() {
    return this.receiveBuf;
  }
  getMessages() {
    const e = this.messages;
    return (this.messages = []), e;
  }
  genHandshakeOut(e, t, r = !1) {
    const s = Buffer.from([0, 0, 0, 0]);
    s.writeUInt32BE(t, 0);
    const n = {
        type: exports.CommunicationType.HANDSHAKE,
        payload: { cursor: e, clientToken: Uint8Array.from(s), isRealtime: r },
      },
      a = o.encode(n, { optimizeArrays: !0 }),
      i = Buffer.concat([Buffer.from([0, 0, 0, 0]), Buffer.from(a)]);
    return i.writeUInt32BE(a.byteLength, 0), i;
  }
}
(exports.ConnectionEvent = void 0),
  ((Se = exports.ConnectionEvent || (exports.ConnectionEvent = {})).CONNECT = "connect"),
  (Se.MESSAGE = "message"),
  (Se.HANDSHAKE = "handshake"),
  (Se.STATUS_CHANGE = "statusChange"),
  (Se.DATA = "data"),
  (Se.ERROR = "error"),
  (exports.ConnectionStatus = void 0),
  ((Ae = exports.ConnectionStatus || (exports.ConnectionStatus = {}))[(Ae.DISCONNECTED = 0)] = "DISCONNECTED"),
  (Ae[(Ae.CONNECTING = 1)] = "CONNECTING"),
  (Ae[(Ae.CONNECTED = 2)] = "CONNECTED"),
  (Ae[(Ae.RECONNECT_WAIT = 3)] = "RECONNECT_WAIT"),
  (exports.Ports = void 0),
  ((_e = exports.Ports || (exports.Ports = {}))[(_e.DEFAULT = 51441)] = "DEFAULT"),
  (_e[(_e.LEGACY = 666)] = "LEGACY"),
  (_e[(_e.RELAY_START = 53741)] = "RELAY_START"),
  (function (e) {
    (e.INITIAL = "initial"), (e.LEGACY = "legacy"), (e.NORMAL = "normal");
  })(de || (de = {}));
const Re = {
    consoleNick: "unknown",
    gameDataCursor: Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),
    version: "",
    clientToken: 0,
  },
  Ce = { autoReconnect: !0 };
var Ne, ge, Ie;
function xe(t) {
  const r = e.map(t, (e) => {
    return (t = e.charCodeAt(0)) > 65280 && t < 65375
      ? t - 65280 + 32
      : 12288 === t
      ? 32
      : 8217 === t
      ? 39
      : 8221 === t
      ? 34
      : t;
    var t;
  });
  return String.fromCharCode(...r);
}
function Oe(e, t, r, s, n) {
  switch (e.source) {
    case ge.FILE:
      return h.default.readSync(e.fileDescriptor, t, r, s, n);
    case ge.BUFFER:
      return e.buffer.copy(t, r, n, n + s);
    default:
      throw new Error("Source type not supported");
  }
}
function De(e) {
  switch (e.source) {
    case ge.FILE:
      return h.default.fstatSync(e.fileDescriptor).size;
    case ge.BUFFER:
      return e.buffer.length;
    default:
      throw new Error("Source type not supported");
  }
}
function Ge(e) {
  const t = (function (e) {
      switch (e.source) {
        case ge.FILE:
          if (!e.filePath) throw new Error("File source requires a file path");
          const t = h.default.openSync(e.filePath, "r");
          return { source: e.source, fileDescriptor: t };
        case ge.BUFFER:
          return { source: e.source, buffer: e.buffer };
        default:
          throw new Error("Source type not supported");
      }
    })(e),
    r = (function (e) {
      const t = new Uint8Array(1);
      return Oe(e, t, 0, t.length, 0), 54 === t[0] || t[0] !== "{".charCodeAt(0) ? 0 : 15;
    })(t),
    s = (function (e, t) {
      const r = De(e);
      if (0 === t) return r;
      const s = new Uint8Array(4);
      Oe(e, s, 0, s.length, t - 4);
      const n = (s[0] << 24) | (s[1] << 16) | (s[2] << 8) | s[3];
      return n > 0 ? n : r - t;
    })(t, r),
    n = r + s + 10,
    o = (function (e, t) {
      return De(e) - t - 1;
    })(t, n),
    a = (function (e, t) {
      const r = {};
      if (0 === t) return (r[54] = 320), (r[55] = 6), (r[56] = 70), (r[57] = 1), r;
      const s = new Uint8Array(2);
      if ((Oe(e, s, 0, s.length, t), s[0] !== exports.Command.MESSAGE_SIZES)) return {};
      const n = s[1];
      r[53] = n;
      const o = new Uint8Array(n - 1);
      Oe(e, o, 0, o.length, t + 2);
      for (let e = 0; e < n - 1; e += 3) r[o[e]] = (o[e + 1] << 8) | o[e + 2];
      return r;
    })(t, r);
  return { ref: t, rawDataPosition: r, rawDataLength: s, metadataPosition: n, metadataLength: o, messageSizes: a };
}
function Fe(e) {
  e.ref.source === ge.FILE && h.default.closeSync(e.ref.fileDescriptor);
}
function ye(e, t) {
  const r = new DataView(t.buffer);
  switch (e) {
    case exports.Command.GAME_START:
      const e = (e) => {
        const s = 8 * e,
          n = Ue(r, 321 + s);
        let o = "None";
        n !== Ue(r, 325 + s) ? (o = "Mixed") : 1 === n ? (o = "UCF") : 2 === n && (o = "Dween");
        const a = 353 + 16 * e,
          i = t.slice(a, a + 16),
          l = d.default.decode(i, "Shift_JIS").split("\0").shift(),
          c = l ? xe(l) : "",
          u = 421 + 31 * e,
          p = t.slice(u, u + 31),
          T = d.default.decode(p, "Shift_JIS").split("\0").shift(),
          E = T ? xe(T) : "",
          m = 545 + 10 * e,
          h = t.slice(m, m + 10),
          S = d.default.decode(h, "Shift_JIS").split("\0").shift(),
          A = S ? xe(S) : "",
          _ = 36 * e;
        return {
          playerIndex: e,
          port: e + 1,
          characterId: we(r, 101 + _),
          characterColor: we(r, 104 + _),
          startStocks: we(r, 103 + _),
          type: we(r, 102 + _),
          teamId: we(r, 110 + _),
          controllerFix: o,
          nametag: c,
          displayName: E,
          connectCode: A,
        };
      };
      return {
        slpVersion: `${we(r, 1)}.${we(r, 2)}.${we(r, 3)}`,
        isTeams: ke(r, 13),
        isPAL: ke(r, 417),
        stageId: ve(r, 19),
        players: [0, 1, 2, 3].map(e),
        scene: we(r, 419),
        gameMode: we(r, 420),
      };
    case exports.Command.PRE_FRAME_UPDATE:
      return {
        frame: Be(r, 1),
        playerIndex: we(r, 5),
        isFollower: ke(r, 6),
        seed: Ue(r, 7),
        actionStateId: ve(r, 11),
        positionX: Le(r, 13),
        positionY: Le(r, 17),
        facingDirection: Le(r, 21),
        joystickX: Le(r, 25),
        joystickY: Le(r, 29),
        cStickX: Le(r, 33),
        cStickY: Le(r, 37),
        trigger: Le(r, 41),
        buttons: Ue(r, 45),
        physicalButtons: ve(r, 49),
        physicalLTrigger: Le(r, 51),
        physicalRTrigger: Le(r, 55),
        percent: Le(r, 60),
      };
    case exports.Command.POST_FRAME_UPDATE:
      const s = { airX: Le(r, 53), y: Le(r, 57), attackX: Le(r, 61), attackY: Le(r, 65), groundX: Le(r, 69) };
      return {
        frame: Be(r, 1),
        playerIndex: we(r, 5),
        isFollower: ke(r, 6),
        internalCharacterId: we(r, 7),
        actionStateId: ve(r, 8),
        positionX: Le(r, 10),
        positionY: Le(r, 14),
        facingDirection: Le(r, 18),
        percent: Le(r, 22),
        shieldSize: Le(r, 26),
        lastAttackLanded: we(r, 30),
        currentComboCount: we(r, 31),
        lastHitBy: we(r, 32),
        stocksRemaining: we(r, 33),
        actionStateCounter: Le(r, 34),
        miscActionState: Le(r, 43),
        isAirborne: ke(r, 47),
        lastGroundId: ve(r, 48),
        jumpsRemaining: we(r, 50),
        lCancelStatus: we(r, 51),
        hurtboxCollisionState: we(r, 52),
        selfInducedSpeeds: s,
      };
    case exports.Command.ITEM_UPDATE:
      return {
        frame: Be(r, 1),
        typeId: ve(r, 5),
        state: we(r, 7),
        facingDirection: Le(r, 8),
        velocityX: Le(r, 12),
        velocityY: Le(r, 16),
        positionX: Le(r, 20),
        positionY: Le(r, 24),
        damageTaken: ve(r, 28),
        expirationTimer: Le(r, 30),
        spawnId: Ue(r, 34),
        missileType: we(r, 38),
        turnipFace: we(r, 39),
        chargeShotLaunched: we(r, 40),
        chargePower: we(r, 41),
        owner: Pe(r, 42),
      };
    case exports.Command.FRAME_BOOKEND:
      return { frame: Be(r, 1), latestFinalizedFrame: Be(r, 5) };
    case exports.Command.GAME_END:
      return { gameEndMethod: we(r, 1), lrasInitiatorIndex: Pe(r, 2) };
    default:
      return null;
  }
}
function Me(e, t, r) {
  return t + r <= e.byteLength;
}
function Le(e, t) {
  return Me(e, t, 4) ? e.getFloat32(t) : null;
}
function Be(e, t) {
  return Me(e, t, 4) ? e.getInt32(t) : null;
}
function Pe(e, t) {
  return Me(e, t, 1) ? e.getInt8(t) : null;
}
function Ue(e, t) {
  return Me(e, t, 4) ? e.getUint32(t) : null;
}
function ve(e, t) {
  return Me(e, t, 2) ? e.getUint16(t) : null;
}
function we(e, t) {
  return Me(e, t, 1) ? e.getUint8(t) : null;
}
function ke(e, t) {
  return Me(e, t, 1) ? !!e.getUint8(t) : null;
}
(exports.DolphinMessageType = void 0),
  ((Ne = exports.DolphinMessageType || (exports.DolphinMessageType = {})).CONNECT_REPLY = "connect_reply"),
  (Ne.GAME_EVENT = "game_event"),
  (Ne.START_GAME = "start_game"),
  (Ne.END_GAME = "end_game"),
  (function (e) {
    (e.BUFFER = "buffer"), (e.FILE = "file");
  })(ge || (ge = {})),
  (exports.SlpStreamMode = void 0),
  ((Ie = exports.SlpStreamMode || (exports.SlpStreamMode = {})).AUTO = "AUTO"),
  (Ie.MANUAL = "MANUAL");
const He = { suppressErrors: !1, mode: exports.SlpStreamMode.AUTO };
var be;
(exports.SlpStreamEvent = void 0),
  ((be = exports.SlpStreamEvent || (exports.SlpStreamEvent = {})).RAW = "slp-raw"),
  (be.COMMAND = "slp-command");
class We extends n.Writable {
  constructor(e, t) {
    super(t),
      (this.gameEnded = !1),
      (this.settings = void 0),
      (this.payloadSizes = null),
      (this.previousBuffer = Buffer.from([])),
      (this.settings = Object.assign({}, He, e));
  }
  restart() {
    (this.gameEnded = !1), (this.payloadSizes = null);
  }
  _write(e, t, r) {
    if ("buffer" !== t) throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${t}'.`);
    const s = Uint8Array.from(Buffer.concat([this.previousBuffer, e]));
    this.previousBuffer = Buffer.from([]);
    const n = new DataView(s.buffer);
    let o = 0;
    for (; o < s.length; ) {
      if ("HELO\0" === Buffer.from(s.slice(o, o + 5)).toString()) {
        o += 5;
        continue;
      }
      const e = n.getUint8(o);
      let t = 0;
      var a;
      if ((this.payloadSizes && (t = null != (a = this.payloadSizes.get(e)) ? a : 0), s.length - o < t + 1)) {
        this.previousBuffer = s.slice(o);
        break;
      }
      if (this.settings.mode === exports.SlpStreamMode.MANUAL && this.gameEnded) break;
      o += 1;
      const r = s.slice(o),
        i = new DataView(s.buffer, o);
      let l = 0;
      try {
        l = this._processCommand(e, r, i);
      } catch (e) {
        if (!this.settings.suppressErrors) throw e;
        l = 0;
      }
      o += l;
    }
    r();
  }
  _writeCommand(e, t, r) {
    const s = t.slice(0, r),
      n = Buffer.concat([Buffer.from([e]), s]);
    return this.emit(exports.SlpStreamEvent.RAW, { command: e, payload: n }), new Uint8Array(n);
  }
  _processCommand(e, t, r) {
    if (e === exports.Command.MESSAGE_SIZES) {
      const s = r.getUint8(0);
      return (
        (this.payloadSizes = Ke(r)),
        this._writeCommand(e, t, s),
        this.emit(exports.SlpStreamEvent.COMMAND, { command: e, payload: this.payloadSizes }),
        s
      );
    }
    let s = 0;
    var n;
    this.payloadSizes && (s = null != (n = this.payloadSizes.get(e)) ? n : 0);
    let o,
      a = null;
    return (
      s > 0 && ((o = this._writeCommand(e, t, s)), (a = ye(e, o))),
      a
        ? (e === exports.Command.GAME_END &&
            this.settings.mode === exports.SlpStreamMode.MANUAL &&
            (this.gameEnded = !0),
          this.emit(exports.SlpStreamEvent.COMMAND, { command: e, payload: a }),
          s)
        : s
    );
  }
}
const Ke = (e) => {
  const t = new Map(),
    r = e.getUint8(0);
  for (let s = 1; s < r; s += 3) {
    const r = e.getUint8(s),
      n = e.getUint16(s + 1);
    t.set(r, n);
  }
  return t;
};
class Ye extends n.Writable {
  constructor(e, t, r) {
    super(r),
      (this.filePath = void 0),
      (this.metadata = void 0),
      (this.fileStream = null),
      (this.rawDataLength = 0),
      (this.slpStream = void 0),
      (this.usesExternalStream = !1),
      (this.filePath = e),
      (this.metadata = { consoleNickname: "unknown", startTime: S.default(), lastFrame: -124, players: {} }),
      (this.usesExternalStream = Boolean(t)),
      (this.slpStream = t || new We({ mode: exports.SlpStreamMode.MANUAL })),
      this._setupListeners(),
      this._initializeNewGame(this.filePath);
  }
  path() {
    return this.filePath;
  }
  setMetadata(e) {
    this.metadata = Object.assign({}, this.metadata, e);
  }
  _write(e, t, r) {
    if ("buffer" !== t) throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${t}'.`);
    this.fileStream && this.fileStream.write(e),
      this.usesExternalStream || this.slpStream.write(e),
      (this.rawDataLength += e.length),
      r();
  }
  _onCommand(t) {
    const { command: r, payload: s } = t;
    switch (r) {
      case exports.Command.GAME_START:
        const { players: t } = s;
        e.forEach(t, (e) => {
          3 !== e.type &&
            (this.metadata.players[e.playerIndex] = {
              characterUsage: {},
              names: { netplay: e.displayName, code: e.connectCode },
            });
        });
        break;
      case exports.Command.POST_FRAME_UPDATE:
        const { frame: r, playerIndex: n, isFollower: o, internalCharacterId: a } = s;
        if (o) break;
        this.metadata.lastFrame = r;
        const i = this.metadata.players[n],
          l = i.characterUsage,
          c = l[a] || 0,
          u = { ...i, characterUsage: { ...l, [a]: c + 1 } };
        this.metadata.players[n] = u;
    }
  }
  _setupListeners() {
    const e = (e) => {
      this._onCommand(e);
    };
    this.slpStream.on(exports.SlpStreamEvent.COMMAND, e),
      this.on("finish", () => {
        const t = h.default.openSync(this.filePath, "r+");
        h.default.writeSync(t, ze(this.rawDataLength), 0, 4, 11),
          h.default.closeSync(t),
          this.slpStream.removeListener(exports.SlpStreamEvent.COMMAND, e),
          this.usesExternalStream || this.slpStream.end();
      });
  }
  _initializeNewGame(e) {
    this.fileStream = h.default.createWriteStream(e, { encoding: "binary" });
    const t = Buffer.concat([Buffer.from("{U"), Buffer.from([3]), Buffer.from("raw[$U#l"), Buffer.from([0, 0, 0, 0])]);
    this.fileStream.write(t);
  }
  _final(t) {
    let r = Buffer.concat([Buffer.from("U"), Buffer.from([8]), Buffer.from("metadata{")]);
    const s = this.metadata.startTime.toISOString();
    r = Buffer.concat([
      r,
      Buffer.from("U"),
      Buffer.from([7]),
      Buffer.from("startAtSU"),
      Buffer.from([s.length]),
      Buffer.from(s),
    ]);
    const n = this.metadata.lastFrame;
    r = Buffer.concat([r, Buffer.from("U"), Buffer.from([9]), Buffer.from("lastFramel"), Je(n)]);
    const o = this.metadata.consoleNickname || "unknown";
    (r = Buffer.concat([
      r,
      Buffer.from("U"),
      Buffer.from([11]),
      Buffer.from("consoleNickSU"),
      Buffer.from([o.length]),
      Buffer.from(o),
    ])),
      (r = Buffer.concat([r, Buffer.from("U"), Buffer.from([7]), Buffer.from("players{")])),
      e.forEach(this.metadata.players, (t, s) => {
        (r = Buffer.concat([r, Buffer.from("U"), Buffer.from([s.length]), Buffer.from(`${s}{`)])),
          (r = Buffer.concat([r, Buffer.from("U"), Buffer.from([10]), Buffer.from("characters{")])),
          e.forEach(t.characterUsage, (e, t) => {
            r = Buffer.concat([r, Buffer.from("U"), Buffer.from([t.length]), Buffer.from(`${t}l`), ze(e)]);
          }),
          (r = Buffer.concat([r, Buffer.from("}")])),
          (r = Buffer.concat([r, Buffer.from("U"), Buffer.from([5]), Buffer.from("names{")])),
          (r = Buffer.concat([
            r,
            Buffer.from("U"),
            Buffer.from([7]),
            Buffer.from("netplaySU"),
            Buffer.from([t.names.netplay.length]),
            Buffer.from(`${t.names.netplay}`),
          ])),
          (r = Buffer.concat([
            r,
            Buffer.from("U"),
            Buffer.from([4]),
            Buffer.from("codeSU"),
            Buffer.from([t.names.code.length]),
            Buffer.from(`${t.names.code}`),
          ])),
          (r = Buffer.concat([r, Buffer.from("}}")]));
      }),
      (r = Buffer.concat([r, Buffer.from("}")])),
      (r = Buffer.concat([
        r,
        Buffer.from("U"),
        Buffer.from([8]),
        Buffer.from("playedOnSU"),
        Buffer.from([7]),
        Buffer.from("network"),
      ])),
      (r = Buffer.concat([r, Buffer.from("}}")])),
      this.fileStream && this.fileStream.write(r, t);
  }
}
const Je = (e) => {
    const t = Buffer.alloc(4);
    return t.writeInt32BE(e, 0), t;
  },
  ze = (e) => {
    const t = Buffer.alloc(4);
    return t.writeUInt32BE(e, 0), t;
  },
  $e = {
    outputFiles: !0,
    folderPath: ".",
    consoleNickname: "unknown",
    newFilename: function (e, t) {
      return f.default.join(e, `Game_${t.format("YYYYMMDD")}T${t.format("HHmmss")}.slp`);
    },
  };
var je, Ze;
(exports.SlpFileWriterEvent = void 0),
  ((je = exports.SlpFileWriterEvent || (exports.SlpFileWriterEvent = {})).NEW_FILE = "new-file"),
  (je.FILE_COMPLETE = "file-complete");
class Xe {
  constructor() {
    (this.rollbackFrames = {}),
      (this.rollbackFrameCount = 0),
      (this.rollbackPlayerIdx = null),
      (this.lastFrameWasRollback = !1),
      (this.currentRollbackLength = 0),
      (this.rollbackLengths = []);
  }
  checkIfRollbackFrame(e, t) {
    if (null === this.rollbackPlayerIdx) this.rollbackPlayerIdx = t;
    else if (this.rollbackPlayerIdx !== t) return;
    return (
      e
        ? (this.rollbackFrames[e.frame] ? this.rollbackFrames[e.frame].push(e) : (this.rollbackFrames[e.frame] = [e]),
          this.rollbackFrameCount++,
          this.currentRollbackLength++,
          (this.lastFrameWasRollback = !0))
        : this.lastFrameWasRollback &&
          (this.rollbackLengths.push(this.currentRollbackLength),
          (this.currentRollbackLength = 0),
          (this.lastFrameWasRollback = !1)),
      this.lastFrameWasRollback
    );
  }
  getFrames() {
    return this.rollbackFrames;
  }
  getCount() {
    return this.rollbackFrameCount;
  }
  getLengths() {
    return this.rollbackLengths;
  }
}
(exports.SlpParserEvent = void 0),
  ((Ze = exports.SlpParserEvent || (exports.SlpParserEvent = {})).SETTINGS = "settings"),
  (Ze.END = "end"),
  (Ze.FRAME = "frame"),
  (Ze.FINALIZED_FRAME = "finalized-frame"),
  (Ze.ROLLBACK_FRAME = "rollback-frame");
const Ve = { strict: !1 };
class qe extends t.EventEmitter {
  constructor(e) {
    super(),
      (this.frames = {}),
      (this.rollbackCounter = new Xe()),
      (this.settings = null),
      (this.gameEnd = null),
      (this.latestFrameIndex = null),
      (this.settingsComplete = !1),
      (this.lastFinalizedFrame = exports.Frames.FIRST - 1),
      (this.options = void 0),
      (this.options = Object.assign({}, Ve, e));
  }
  handleCommand(e, t) {
    switch (e) {
      case exports.Command.GAME_START:
        this._handleGameStart(t);
        break;
      case exports.Command.POST_FRAME_UPDATE:
        this._handlePostFrameUpdate(t), this._handleFrameUpdate(e, t);
        break;
      case exports.Command.PRE_FRAME_UPDATE:
        this._handleFrameUpdate(e, t);
        break;
      case exports.Command.ITEM_UPDATE:
        this._handleItemUpdate(t);
        break;
      case exports.Command.FRAME_BOOKEND:
        this._handleFrameBookend(t);
        break;
      case exports.Command.GAME_END:
        this._handleGameEnd(t);
    }
  }
  reset() {
    (this.frames = {}),
      (this.settings = null),
      (this.gameEnd = null),
      (this.latestFrameIndex = null),
      (this.settingsComplete = !1),
      (this.lastFinalizedFrame = exports.Frames.FIRST - 1);
  }
  getLatestFrameNumber() {
    var e;
    return null != (e = this.latestFrameIndex) ? e : exports.Frames.FIRST - 1;
  }
  getPlayableFrameCount() {
    return null === this.latestFrameIndex || this.latestFrameIndex < exports.Frames.FIRST_PLAYABLE
      ? 0
      : this.latestFrameIndex - exports.Frames.FIRST_PLAYABLE;
  }
  getLatestFrame() {
    const t = this.getFrames(),
      r = null !== this.latestFrameIndex ? this.latestFrameIndex : exports.Frames.FIRST;
    return e.get(t, this.gameEnd ? r : r - 1) || null;
  }
  getSettings() {
    return this.settingsComplete ? this.settings : null;
  }
  getGameEnd() {
    return this.gameEnd;
  }
  getFrames() {
    return this.frames;
  }
  getRollbackFrames() {
    return {
      frames: this.rollbackCounter.getFrames(),
      count: this.rollbackCounter.getCount(),
      lengths: this.rollbackCounter.getLengths(),
    };
  }
  getFrame(e) {
    return this.frames[e] || null;
  }
  _handleGameEnd(e) {
    null !== this.latestFrameIndex &&
      this.latestFrameIndex !== this.lastFinalizedFrame &&
      this._finalizeFrames(this.latestFrameIndex),
      (this.gameEnd = e = e),
      this.emit(exports.SlpParserEvent.END, this.gameEnd);
  }
  _handleGameStart(e) {
    (this.settings = e),
      (this.settings.players = e.players.filter((e) => 3 !== e.type)),
      e.slpVersion && R.default.gte(e.slpVersion, "1.6.0") && this._completeSettings();
  }
  _handlePostFrameUpdate(t) {
    if (!this.settingsComplete) {
      if (t.frame <= exports.Frames.FIRST) {
        const r = t.playerIndex,
          s = e.keyBy(this.settings.players, "playerIndex");
        switch (t.internalCharacterId) {
          case 7:
            s[r].characterId = 19;
            break;
          case 19:
            s[r].characterId = 18;
        }
      }
      t.frame > exports.Frames.FIRST && this._completeSettings();
    }
  }
  _handleFrameUpdate(t, r) {
    r = r;
    const s = t === exports.Command.PRE_FRAME_UPDATE ? "pre" : "post",
      n = r.isFollower ? "followers" : "players",
      o = r.frame;
    if (((this.latestFrameIndex = o), "pre" === s && !r.isFollower)) {
      const e = this.frames[o];
      this.rollbackCounter.checkIfRollbackFrame(e, r.playerIndex) &&
        this.emit(exports.SlpParserEvent.ROLLBACK_FRAME, e);
    }
    e.set(this.frames, [o, n, r.playerIndex, s], r), e.set(this.frames, [o, "frame"], o);
    const a = this.getSettings();
    !a || (a.slpVersion && !R.default.lte(a.slpVersion, "2.2.0"))
      ? e.set(this.frames, [o, "isTransferComplete"], !1)
      : (this.emit(exports.SlpParserEvent.FRAME, this.frames[o]), this._finalizeFrames(o - 1));
  }
  _handleItemUpdate(t) {
    var r, s;
    const n = t.frame,
      o = null != (r = null == (s = this.frames[n]) ? void 0 : s.items) ? r : [];
    o.push(t), e.set(this.frames, [n, "items"], o);
  }
  _handleFrameBookend(t) {
    const r = t.latestFinalizedFrame,
      s = t.frame;
    if (
      (e.set(this.frames, [s, "isTransferComplete"], !0),
      this.emit(exports.SlpParserEvent.FRAME, this.frames[s]),
      this.settings.gameMode === exports.GameMode.ONLINE && r >= exports.Frames.FIRST)
    ) {
      if (this.options.strict && r < s - 7) throw new Error(`latestFinalizedFrame should be within 7 frames of ${s}`);
      this._finalizeFrames(r);
    } else this._finalizeFrames(s - 7);
  }
  _finalizeFrames(e) {
    for (; this.lastFinalizedFrame < e; ) {
      const t = this.lastFinalizedFrame + 1,
        r = this.getFrame(t);
      if (this.options.strict)
        for (const s of this.settings.players) {
          const n = r.players[s.playerIndex];
          if (this.settings.players.length > 2 && !n) continue;
          const { pre: o, post: a } = n;
          if (!o || !a)
            throw new Error(
              `Could not finalize frame ${t} of ${e}: missing ${o ? "pre" : "post"}-frame update for player ${
                s.playerIndex
              }`,
            );
        }
      this.emit(exports.SlpParserEvent.FINALIZED_FRAME, r), (this.lastFinalizedFrame = t);
    }
  }
  _completeSettings() {
    this.settingsComplete || ((this.settingsComplete = !0), this.emit(exports.SlpParserEvent.SETTINGS, this.settings));
  }
}
(exports.ActionsComputer = $),
  (exports.ComboComputer = se),
  (exports.ConsoleCommunication = fe),
  (exports.ConsoleConnection = class extends t.EventEmitter {
    constructor(e) {
      super(),
        (this.ipAddress = void 0),
        (this.port = void 0),
        (this.isRealtime = void 0),
        (this.connectionStatus = exports.ConnectionStatus.DISCONNECTED),
        (this.connDetails = { ...Re }),
        (this.client = null),
        (this.connection = null),
        (this.options = void 0),
        (this.shouldReconnect = !1),
        (this.ipAddress = "0.0.0.0"),
        (this.port = exports.Ports.DEFAULT),
        (this.isRealtime = !1),
        (this.options = Object.assign({}, Ce, e));
    }
    getStatus() {
      return this.connectionStatus;
    }
    getSettings() {
      return { ipAddress: this.ipAddress, port: this.port };
    }
    getDetails() {
      return { ...this.connDetails };
    }
    connect(e, t, r = !1, s = 2e4) {
      (this.ipAddress = e), (this.port = t), (this.isRealtime = r), this._connectOnPort(e, t, s);
    }
    _connectOnPort(e, t, r) {
      const s = _.default(() => A.default.connect({ host: e, port: t, timeout: r }));
      this._setStatus(exports.ConnectionStatus.CONNECTING);
      const n = new fe(),
        o = s({ initialDelay: 2e3, maxDelay: 1e4, strategy: "fibonacci", failAfter: Infinity }, (s) => {
          var o;
          this.emit(exports.ConnectionEvent.CONNECT),
            (this.shouldReconnect = this.options.autoReconnect),
            (this.client = s);
          let a = de.INITIAL;
          s.on("data", (r) => {
            if (
              (a === de.INITIAL &&
                ((a = this._getInitialCommState(r)),
                console.log(`Connected to ${e}:${t} with type: ${a}`),
                this._setStatus(exports.ConnectionStatus.CONNECTED),
                console.log(r.toString("hex"))),
              a === de.LEGACY)
            )
              return void this._handleReplayData(r);
            try {
              n.receive(r);
            } catch (e) {
              return (
                console.error("Failed to process new data from server...", {
                  error: e,
                  prevDataBuf: n.getReceiveBuffer(),
                  rcvData: r,
                }),
                s.destroy(),
                void this.emit(exports.ConnectionEvent.ERROR, e)
              );
            }
            const o = n.getMessages();
            try {
              o.forEach((e) => this._processMessage(e));
            } catch (e) {
              console.error(e), s.destroy(), this.emit(exports.ConnectionEvent.ERROR, e);
            }
          }),
            s.on("timeout", () => {
              console.warn(`Attempted connection to ${e}:${t} timed out after ${r}ms`), s.destroy();
            }),
            s.on("end", () => {
              console.log("disconnect"), this.shouldReconnect || s.destroy();
            }),
            s.on("close", () => {
              console.log("connection was closed");
            });
          const i = n.genHandshakeOut(
            this.connDetails.gameDataCursor,
            null != (o = this.connDetails.clientToken) ? o : 0,
            this.isRealtime,
          );
          s.write(i);
        }),
        a = () => {
          this._setStatus(
            this.shouldReconnect ? exports.ConnectionStatus.RECONNECT_WAIT : exports.ConnectionStatus.CONNECTING,
          );
        };
      o.on("connect", a),
        o.on("reconnect", a),
        o.on("disconnect", () => {
          this.shouldReconnect ||
            ((o.reconnect = !1), o.disconnect(), this._setStatus(exports.ConnectionStatus.DISCONNECTED));
        }),
        o.on("error", (e) => {
          console.warn(`Connection on port ${t} encountered an error.`, e),
            this._setStatus(exports.ConnectionStatus.DISCONNECTED),
            this.emit(exports.ConnectionEvent.ERROR, `Connection on port ${t} encountered an error.\n${e}`);
        }),
        (this.connection = o),
        o.connect(t);
    }
    disconnect() {
      this.connection && ((this.connection.reconnect = !1), this.connection.disconnect(), (this.connection = null)),
        this.client && this.client.destroy();
    }
    _getInitialCommState(e) {
      if (e.length < 13) return de.LEGACY;
      const t = Buffer.from([123, 105, 4, 116, 121, 112, 101, 85, 1]);
      return e.slice(4, 13).equals(t) ? de.NORMAL : de.LEGACY;
    }
    _processMessage(e) {
      switch ((this.emit(exports.ConnectionEvent.MESSAGE, e), e.type)) {
        case exports.CommunicationType.KEEP_ALIVE:
          const t = Buffer.from("HELO\0");
          this._handleReplayData(t);
          break;
        case exports.CommunicationType.REPLAY:
          const r = Uint8Array.from(e.payload.pos),
            s = Buffer.compare(this.connDetails.gameDataCursor, r);
          if (!e.payload.forcePos && 0 !== s)
            throw new Error(
              `Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${r.toString()}`,
            );
          e.payload.forcePos &&
            console.warn(
              "Overflow occured in Nintendont, data has likely been skipped and replay corrupted. Expected, Received:",
              this.connDetails.gameDataCursor,
              r,
            ),
            (this.connDetails.gameDataCursor = Uint8Array.from(e.payload.nextPos));
          const n = Uint8Array.from(e.payload.data);
          this._handleReplayData(n);
          break;
        case exports.CommunicationType.HANDSHAKE:
          const { nick: o, nintendontVersion: a } = e.payload;
          o && (this.connDetails.consoleNick = o);
          const i = Buffer.from(e.payload.clientToken);
          (this.connDetails.clientToken = i.readUInt32BE(0)),
            a && (this.connDetails.version = a),
            (this.connDetails.gameDataCursor = Uint8Array.from(e.payload.pos)),
            this.emit(exports.ConnectionEvent.HANDSHAKE, this.connDetails);
      }
    }
    _handleReplayData(e) {
      this.emit(exports.ConnectionEvent.DATA, e);
    }
    _setStatus(e) {
      this.connectionStatus !== e &&
        ((this.connectionStatus = e), this.emit(exports.ConnectionEvent.STATUS_CHANGE, this.connectionStatus));
    }
  }),
  (exports.ConversionComputer = ne),
  (exports.DolphinConnection = class extends t.EventEmitter {
    constructor() {
      super(),
        (this.ipAddress = void 0),
        (this.port = void 0),
        (this.connectionStatus = exports.ConnectionStatus.DISCONNECTED),
        (this.gameCursor = 0),
        (this.nickname = "unknown"),
        (this.version = ""),
        (this.peer = null),
        (this.ipAddress = "0.0.0.0"),
        (this.port = exports.Ports.DEFAULT);
    }
    getStatus() {
      return this.connectionStatus;
    }
    getSettings() {
      return { ipAddress: this.ipAddress, port: this.port };
    }
    getDetails() {
      return { consoleNick: this.nickname, gameDataCursor: this.gameCursor, version: this.version };
    }
    async connect(e, t) {
      console.log(`Connecting to: ${e}:${t}`), (this.ipAddress = e), (this.port = t);
      const r = await Promise.resolve().then(function () {
          return T(require("enet"));
        }),
        s = r.createClient({ peers: 32, channels: 3, down: 0, up: 0 }, (e) => {
          e && console.error(e);
        });
      (this.peer = s.connect({ address: this.ipAddress, port: this.port }, 3, 1337, (e, t) => {
        e
          ? console.error(e)
          : (t.ping(), this.emit(exports.ConnectionEvent.CONNECT), this._setStatus(exports.ConnectionStatus.CONNECTED));
      })),
        this.peer.on("connect", () => {
          this.gameCursor = 0;
          const e = new r.Packet(
            JSON.stringify({ type: "connect_request", cursor: this.gameCursor }),
            r.PACKET_FLAG.RELIABLE,
          );
          this.peer.send(0, e);
        }),
        this.peer.on("message", (e) => {
          const t = e.data();
          if (0 === t.length) return;
          const r = t.toString("ascii"),
            s = JSON.parse(r),
            { dolphin_closed: n } = s;
          if (n) this.disconnect();
          else
            switch ((this.emit(exports.ConnectionEvent.MESSAGE, s), s.type)) {
              case exports.DolphinMessageType.CONNECT_REPLY:
                (this.connectionStatus = exports.ConnectionStatus.CONNECTED),
                  (this.gameCursor = s.cursor),
                  (this.nickname = s.nick),
                  (this.version = s.version),
                  this.emit(exports.ConnectionEvent.HANDSHAKE, this.getDetails());
                break;
              case exports.DolphinMessageType.GAME_EVENT: {
                const { payload: e } = s;
                if (!e) return void this.disconnect();
                this._updateCursor(s, r);
                const t = Buffer.from(e, "base64");
                this._handleReplayData(t);
                break;
              }
              case exports.DolphinMessageType.START_GAME:
              case exports.DolphinMessageType.END_GAME:
                this._updateCursor(s, r);
            }
        }),
        this.peer.on("disconnect", () => {
          this.disconnect();
        }),
        this._setStatus(exports.ConnectionStatus.CONNECTING);
    }
    disconnect() {
      this.peer && (this.peer.disconnect(), (this.peer = null)), this._setStatus(exports.ConnectionStatus.DISCONNECTED);
    }
    _handleReplayData(e) {
      this.emit(exports.ConnectionEvent.DATA, e);
    }
    _setStatus(e) {
      this.connectionStatus !== e &&
        ((this.connectionStatus = e), this.emit(exports.ConnectionEvent.STATUS_CHANGE, this.connectionStatus));
    }
    _updateCursor(e, t) {
      const { cursor: r, next_cursor: s } = e;
      if (this.gameCursor !== r) {
        const e = new Error(`Unexpected game data cursor. Expected: ${this.gameCursor} but got: ${r}. Payload: ${t}`);
        console.warn(e), this.emit(exports.ConnectionEvent.ERROR, e);
      }
      this.gameCursor = s;
    }
  }),
  (exports.InputComputer = oe),
  (exports.MAX_ROLLBACK_FRAMES = 7),
  (exports.NETWORK_MESSAGE = "HELO\0"),
  (exports.SlippiGame = class {
    constructor(e, t) {
      if (
        ((this.input = void 0),
        (this.metadata = null),
        (this.finalStats = null),
        (this.parser = void 0),
        (this.readPosition = null),
        (this.actionsComputer = new $()),
        (this.conversionComputer = new ne()),
        (this.comboComputer = new se()),
        (this.stockComputer = new me()),
        (this.inputComputer = new oe()),
        (this.statsComputer = void 0),
        "string" == typeof e)
      )
        this.input = { source: ge.FILE, filePath: e };
      else if (e instanceof Buffer) this.input = { source: ge.BUFFER, buffer: e };
      else {
        if (!(e instanceof ArrayBuffer)) throw new Error("Cannot create SlippiGame with input of that type");
        this.input = { source: ge.BUFFER, buffer: Buffer.from(e) };
      }
      (this.statsComputer = new Te(t)),
        this.statsComputer.register(
          this.actionsComputer,
          this.comboComputer,
          this.conversionComputer,
          this.inputComputer,
          this.stockComputer,
        ),
        (this.parser = new qe()),
        this.parser.on(exports.SlpParserEvent.SETTINGS, (e) => {
          this.statsComputer.setup(e);
        }),
        this.parser.on(exports.SlpParserEvent.FINALIZED_FRAME, (e) => {
          this.statsComputer.addFrame(e);
        });
    }
    _process(t = !1) {
      if (null !== this.parser.getGameEnd()) return;
      const r = Ge(this.input);
      (this.readPosition = (function (t, r, s = null) {
        const n = t.ref;
        let o = null !== s && s > 0 ? s : t.rawDataPosition;
        const a = t.rawDataPosition + t.rawDataLength,
          i = e.mapValues(t.messageSizes, (e) => new Uint8Array(e + 1)),
          l = new Uint8Array(1);
        for (; o < a; ) {
          Oe(n, l, 0, 1, o);
          const e = l[0],
            t = i[e];
          if (void 0 === t) return o;
          if (t.length > a - o) return o;
          if ((Oe(n, t, 0, t.length, o), r(e, ye(e, t)))) break;
          o += t.length;
        }
        return o;
      })(
        r,
        (e, r) => !!r && (this.parser.handleCommand(e, r), t && null !== this.parser.getSettings()),
        this.readPosition,
      )),
        Fe(r);
    }
    getSettings() {
      return this._process(!0), this.parser.getSettings();
    }
    getLatestFrame() {
      return this._process(), this.parser.getLatestFrame();
    }
    getGameEnd() {
      return this._process(), this.parser.getGameEnd();
    }
    getFrames() {
      return this._process(), this.parser.getFrames();
    }
    getRollbackFrames() {
      return this._process(), this.parser.getRollbackFrames();
    }
    getStats() {
      if (this.finalStats) return this.finalStats;
      this._process();
      const e = this.parser.getSettings();
      if (null === e) return null;
      this.statsComputer.process();
      const t = this.inputComputer.fetch(),
        r = this.stockComputer.fetch(),
        s = this.conversionComputer.fetch(),
        n = this.parser.getPlayableFrameCount(),
        o = ie({ settings: e, inputs: t, conversions: s, playableFrameCount: n }),
        a = {
          lastFrame: this.parser.getLatestFrameNumber(),
          playableFrameCount: n,
          stocks: r,
          conversions: s,
          combos: this.comboComputer.fetch(),
          actionCounts: this.actionsComputer.fetch(),
          overall: o,
          gameComplete: null !== this.parser.getGameEnd(),
        };
      return null !== this.parser.getGameEnd() && (this.finalStats = a), a;
    }
    getMetadata() {
      if (this.metadata) return this.metadata;
      const e = Ge(this.input);
      return (
        (this.metadata = (function (e) {
          if (e.metadataLength <= 0) return null;
          const t = new Uint8Array(e.metadataLength);
          Oe(e.ref, t, 0, t.length, e.metadataPosition);
          let r = null;
          try {
            r = o.decode(t);
          } catch (e) {}
          return r;
        })(e)),
        Fe(e),
        this.metadata
      );
    }
    getFilePath() {
      var e;
      return this.input.source !== ge.FILE ? null : null != (e = this.input.filePath) ? e : null;
    }
  }),
  (exports.SlpFile = Ye),
  (exports.SlpFileWriter = class extends We {
    constructor(e, t) {
      super(e, t),
        (this.currentFile = null),
        (this.options = void 0),
        (this.options = Object.assign({}, $e, e)),
        this._setupListeners();
    }
    _writePayload(e) {
      this.currentFile && this.currentFile.write(e);
    }
    _setupListeners() {
      this.on(exports.SlpStreamEvent.RAW, (e) => {
        const { command: t, payload: r } = e;
        switch (t) {
          case exports.Command.MESSAGE_SIZES:
            this._handleNewGame(), this._writePayload(r);
            break;
          case exports.Command.GAME_END:
            this._writePayload(r), this._handleEndGame();
            break;
          default:
            this._writePayload(r);
        }
      });
    }
    getCurrentFilename() {
      return null !== this.currentFile ? f.default.resolve(this.currentFile.path()) : null;
    }
    endCurrentFile() {
      this._handleEndGame();
    }
    updateSettings(e) {
      this.options = Object.assign({}, this.options, e);
    }
    _handleNewGame() {
      if (this.options.outputFiles) {
        const e = this.options.newFilename(this.options.folderPath, S.default());
        (this.currentFile = new Ye(e, this)), this.emit(exports.SlpFileWriterEvent.NEW_FILE, e);
      }
    }
    _handleEndGame() {
      this.currentFile &&
        (this.currentFile.setMetadata({ consoleNickname: this.options.consoleNickname }),
        this.currentFile.end(),
        this.emit(exports.SlpFileWriterEvent.FILE_COMPLETE, this.currentFile.path()),
        (this.currentFile = null));
    }
  }),
  (exports.SlpParser = qe),
  (exports.SlpStream = We),
  (exports.Stats = Te),
  (exports.StockComputer = me),
  (exports.Timers = P),
  (exports.animations = {
    __proto__: null,
    getDeathDirection: function (e) {
      if (e > 10) return null;
      switch (e) {
        case 0:
          return "down";
        case 1:
          return "left";
        case 2:
          return "right";
        default:
          return "up";
      }
    },
  }),
  (exports.calcDamageTaken = J),
  (exports.characters = I),
  (exports.didLoseStock = v),
  (exports.generateOverallStats = ie),
  (exports.getSinglesPlayerPermutationsFromSettings = U),
  (exports.isCommandGrabbed = K),
  (exports.isDamaged = b),
  (exports.isDead = Y),
  (exports.isDown = H),
  (exports.isGrabbed = W),
  (exports.isInControl = w),
  (exports.isTeching = k),
  (exports.moves = G),
  (exports.stages = B);
//# sourceMappingURL=slippi-js.cjs.production.min.js.map
